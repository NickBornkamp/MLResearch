/**     * Fen Ye Chu Li      * @param batchParams     * @param offset     * @param pageSize     * @param object     * @return     * @throws BatchException     */
/**     *{"status":0,"msg":"aaa","date":{}}     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_cart.id     *     * @return the value of neuedu_cart.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_cart.id     *     * @param id the value for neuedu_cart.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_cart.user_id     *     * @return the value of neuedu_cart.user_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_cart.user_id     *     * @param userId the value for neuedu_cart.user_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_cart.product_id     *     * @return the value of neuedu_cart.product_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_cart.product_id     *     * @param productId the value for neuedu_cart.product_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_cart.quantity     *     * @return the value of neuedu_cart.quantity     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_cart.quantity     *     * @param quantity the value for neuedu_cart.quantity     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_cart.checked     *     * @return the value of neuedu_cart.checked     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_cart.checked     *     * @param checked the value for neuedu_cart.checked     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_cart.create_time     *     * @return the value of neuedu_cart.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_cart.create_time     *     * @param createTime the value for neuedu_cart.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_cart.update_time     *     * @return the value of neuedu_cart.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_cart.update_time     *     * @param updateTime the value for neuedu_cart.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_category.id     *     * @return the value of neuedu_category.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_category.id     *     * @param id the value for neuedu_category.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_category.parent_id     *     * @return the value of neuedu_category.parent_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_category.parent_id     *     * @param parentId the value for neuedu_category.parent_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_category.name     *     * @return the value of neuedu_category.name     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_category.name     *     * @param name the value for neuedu_category.name     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_category.status     *     * @return the value of neuedu_category.status     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_category.status     *     * @param status the value for neuedu_category.status     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_category.sort_order     *     * @return the value of neuedu_category.sort_order     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_category.sort_order     *     * @param sortOrder the value for neuedu_category.sort_order     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_category.create_time     *     * @return the value of neuedu_category.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_category.create_time     *     * @param createTime the value for neuedu_category.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_category.update_time     *     * @return the value of neuedu_category.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_category.update_time     *     * @param updateTime the value for neuedu_category.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order.id     *     * @return the value of neuedu_order.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order.id     *     * @param id the value for neuedu_order.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order.user_id     *     * @return the value of neuedu_order.user_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order.user_id     *     * @param userId the value for neuedu_order.user_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order.order_no     *     * @return the value of neuedu_order.order_no     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order.order_no     *     * @param orderNo the value for neuedu_order.order_no     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order.shipping_id     *     * @return the value of neuedu_order.shipping_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order.shipping_id     *     * @param shippingId the value for neuedu_order.shipping_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order.payment     *     * @return the value of neuedu_order.payment     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order.payment     *     * @param payment the value for neuedu_order.payment     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order.payment_type     *     * @return the value of neuedu_order.payment_type     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order.payment_type     *     * @param paymentType the value for neuedu_order.payment_type     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order.postage     *     * @return the value of neuedu_order.postage     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order.postage     *     * @param postage the value for neuedu_order.postage     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order.status     *     * @return the value of neuedu_order.status     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order.status     *     * @param status the value for neuedu_order.status     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order.payment_time     *     * @return the value of neuedu_order.payment_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order.payment_time     *     * @param paymentTime the value for neuedu_order.payment_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order.send_time     *     * @return the value of neuedu_order.send_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order.send_time     *     * @param sendTime the value for neuedu_order.send_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order.end_time     *     * @return the value of neuedu_order.end_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order.end_time     *     * @param endTime the value for neuedu_order.end_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order.close_time     *     * @return the value of neuedu_order.close_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order.close_time     *     * @param closeTime the value for neuedu_order.close_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order.create_time     *     * @return the value of neuedu_order.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order.create_time     *     * @param createTime the value for neuedu_order.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order.update_time     *     * @return the value of neuedu_order.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order.update_time     *     * @param updateTime the value for neuedu_order.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order_item.id     *     * @return the value of neuedu_order_item.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order_item.id     *     * @param id the value for neuedu_order_item.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order_item.user_id     *     * @return the value of neuedu_order_item.user_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order_item.user_id     *     * @param userId the value for neuedu_order_item.user_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order_item.order_no     *     * @return the value of neuedu_order_item.order_no     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order_item.order_no     *     * @param orderNo the value for neuedu_order_item.order_no     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order_item.product_id     *     * @return the value of neuedu_order_item.product_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order_item.product_id     *     * @param productId the value for neuedu_order_item.product_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order_item.product_name     *     * @return the value of neuedu_order_item.product_name     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order_item.product_name     *     * @param productName the value for neuedu_order_item.product_name     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order_item.product_image     *     * @return the value of neuedu_order_item.product_image     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order_item.product_image     *     * @param productImage the value for neuedu_order_item.product_image     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order_item.current_unit_price     *     * @return the value of neuedu_order_item.current_unit_price     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order_item.current_unit_price     *     * @param currentUnitPrice the value for neuedu_order_item.current_unit_price     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order_item.quantity     *     * @return the value of neuedu_order_item.quantity     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order_item.quantity     *     * @param quantity the value for neuedu_order_item.quantity     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order_item.total_price     *     * @return the value of neuedu_order_item.total_price     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order_item.total_price     *     * @param totalPrice the value for neuedu_order_item.total_price     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order_item.create_time     *     * @return the value of neuedu_order_item.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order_item.create_time     *     * @param createTime the value for neuedu_order_item.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_order_item.update_time     *     * @return the value of neuedu_order_item.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_order_item.update_time     *     * @param updateTime the value for neuedu_order_item.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_payinfo.id     *     * @return the value of neuedu_payinfo.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_payinfo.id     *     * @param id the value for neuedu_payinfo.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_payinfo.user_id     *     * @return the value of neuedu_payinfo.user_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_payinfo.user_id     *     * @param userId the value for neuedu_payinfo.user_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_payinfo.order_no     *     * @return the value of neuedu_payinfo.order_no     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_payinfo.order_no     *     * @param orderNo the value for neuedu_payinfo.order_no     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_payinfo.pay_platform     *     * @return the value of neuedu_payinfo.pay_platform     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_payinfo.pay_platform     *     * @param payPlatform the value for neuedu_payinfo.pay_platform     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_payinfo.platform_number     *     * @return the value of neuedu_payinfo.platform_number     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_payinfo.platform_number     *     * @param platformNumber the value for neuedu_payinfo.platform_number     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_payinfo.platform_status     *     * @return the value of neuedu_payinfo.platform_status     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_payinfo.platform_status     *     * @param platformStatus the value for neuedu_payinfo.platform_status     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_payinfo.create_time     *     * @return the value of neuedu_payinfo.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_payinfo.create_time     *     * @param createTime the value for neuedu_payinfo.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_payinfo.update_time     *     * @return the value of neuedu_payinfo.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_payinfo.update_time     *     * @param updateTime the value for neuedu_payinfo.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_product.id     *     * @return the value of neuedu_product.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_product.id     *     * @param id the value for neuedu_product.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_product.category_id     *     * @return the value of neuedu_product.category_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_product.category_id     *     * @param categoryId the value for neuedu_product.category_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_product.name     *     * @return the value of neuedu_product.name     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_product.name     *     * @param name the value for neuedu_product.name     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_product.subtitle     *     * @return the value of neuedu_product.subtitle     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_product.subtitle     *     * @param subtitle the value for neuedu_product.subtitle     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_product.main_image     *     * @return the value of neuedu_product.main_image     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_product.main_image     *     * @param mainImage the value for neuedu_product.main_image     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_product.price     *     * @return the value of neuedu_product.price     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_product.price     *     * @param price the value for neuedu_product.price     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_product.stock     *     * @return the value of neuedu_product.stock     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_product.stock     *     * @param stock the value for neuedu_product.stock     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_product.status     *     * @return the value of neuedu_product.status     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_product.status     *     * @param status the value for neuedu_product.status     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_product.create_time     *     * @return the value of neuedu_product.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_product.create_time     *     * @param createTime the value for neuedu_product.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_product.update_time     *     * @return the value of neuedu_product.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_product.update_time     *     * @param updateTime the value for neuedu_product.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_product.sub_images     *     * @return the value of neuedu_product.sub_images     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_product.sub_images     *     * @param subImages the value for neuedu_product.sub_images     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_product.detail     *     * @return the value of neuedu_product.detail     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_product.detail     *     * @param detail the value for neuedu_product.detail     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_shipping.id     *     * @return the value of neuedu_shipping.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_shipping.id     *     * @param id the value for neuedu_shipping.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_shipping.user_id     *     * @return the value of neuedu_shipping.user_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_shipping.user_id     *     * @param userId the value for neuedu_shipping.user_id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_shipping.receiver_name     *     * @return the value of neuedu_shipping.receiver_name     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_shipping.receiver_name     *     * @param receiverName the value for neuedu_shipping.receiver_name     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_shipping.receiver_phone     *     * @return the value of neuedu_shipping.receiver_phone     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_shipping.receiver_phone     *     * @param receiverPhone the value for neuedu_shipping.receiver_phone     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_shipping.receiver_mobile     *     * @return the value of neuedu_shipping.receiver_mobile     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_shipping.receiver_mobile     *     * @param receiverMobile the value for neuedu_shipping.receiver_mobile     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_shipping.receiver_province     *     * @return the value of neuedu_shipping.receiver_province     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_shipping.receiver_province     *     * @param receiverProvince the value for neuedu_shipping.receiver_province     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_shipping.receiver_city     *     * @return the value of neuedu_shipping.receiver_city     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_shipping.receiver_city     *     * @param receiverCity the value for neuedu_shipping.receiver_city     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_shipping.receiver_district     *     * @return the value of neuedu_shipping.receiver_district     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_shipping.receiver_district     *     * @param receiverDistrict the value for neuedu_shipping.receiver_district     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_shipping.receiver_address     *     * @return the value of neuedu_shipping.receiver_address     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_shipping.receiver_address     *     * @param receiverAddress the value for neuedu_shipping.receiver_address     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_shipping.receiver_zip     *     * @return the value of neuedu_shipping.receiver_zip     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_shipping.receiver_zip     *     * @param receiverZip the value for neuedu_shipping.receiver_zip     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_shipping.create_time     *     * @return the value of neuedu_shipping.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_shipping.create_time     *     * @param createTime the value for neuedu_shipping.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_shipping.update_time     *     * @return the value of neuedu_shipping.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_shipping.update_time     *     * @param updateTime the value for neuedu_shipping.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_user.id     *     * @return the value of neuedu_user.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_user.id     *     * @param id the value for neuedu_user.id     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_user.username     *     * @return the value of neuedu_user.username     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_user.username     *     * @param username the value for neuedu_user.username     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_user.password     *     * @return the value of neuedu_user.password     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_user.password     *     * @param password the value for neuedu_user.password     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_user.email     *     * @return the value of neuedu_user.email     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_user.email     *     * @param email the value for neuedu_user.email     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_user.phone     *     * @return the value of neuedu_user.phone     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_user.phone     *     * @param phone the value for neuedu_user.phone     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_user.question     *     * @return the value of neuedu_user.question     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_user.question     *     * @param question the value for neuedu_user.question     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_user.answer     *     * @return the value of neuedu_user.answer     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_user.answer     *     * @param answer the value for neuedu_user.answer     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_user.role     *     * @return the value of neuedu_user.role     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_user.role     *     * @param role the value for neuedu_user.role     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_user.create_time     *     * @return the value of neuedu_user.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_user.create_time     *     * @param createTime the value for neuedu_user.create_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_user.update_time     *     * @return the value of neuedu_user.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_user.update_time     *     * @param updateTime the value for neuedu_user.update_time     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method returns the value of the database column neuedu_user.ip     *     * @return the value of neuedu_user.ip     *     * @mbggenerated     */
/**     * This method was generated by MyBatis Generator.     * This method sets the value of the database column neuedu_user.ip     *     * @param ip the value for neuedu_user.ip     *     * @mbggenerated     */
/**memberScoreAssessor will assess risk score for each member.  *  * @param memberData * @return */
/** * This addScoreForMembers will assign penalty points to members based on their age, blood pressure, BMI and disease in family (if any). * @ */
/** * This is a required default constructor to handle the Xml serialization. */
/** Constructor used to set the values  *  * @param fname * @param lname * @param age * @param height * @param weight * @param bpSystolic * @param bpDiastolic * @param cancer * @param diabetes * @param alzheimers */
/** Getters and Setters used to access data *  * @return */
/** * Insurance score constructor that will calculate the riskLevel within itself.   * @param fname * @param lname * @param score */
/** * Default constructor in case we need to serialize in Xml. */
/** * toString function will print the insurance details with risk assessment of members in a formatted way. */
/**writeRiskInformation function will write the risk assessment information for each member.  *  * @param assess */
/** * WriteMembersToJSON function will allow the member risk assessment to be stored in a JSON file format.  * @param fname * @param assessment * @return */
/** This function will read the tab delimited test file and store into an ArrayList. *  * @param fname * @return */
/**readDataFromBinary function will read back data from stored binary file, it will be used to count number of members read/stored from binary. *   * @param fname * @return */
/**readMemberDataFromXml function will read back data from stored XML file, it will be used to count/read number of members from the file.  *  * @param fname * @return */
/** this function will print members from file to the screen with formatting. *  * @param memberData */
/** This function will save member data from ArrayList to the text file in tab delimited file format. *  * @param fname * @param memberData * @return */
/** This function will save member data from ArrayList into BinaryFile format *  * @param fname * @param memberData * @return */
/** This function will save members in Array List in a XML file format *  * @param fname * @param memberData * @return */
/* * Welcome function will print the greeting message to the screen. */
/** * This Show Menu function will print list of options that user can choose from. */
/** * This addMember function will allow the user to enter a new member. */
/* * Begin Main function ... */
/*This method(geneseegame()) uses the the above final values/arraylists     when calling the method Playgame(hole_g, yardage_g, par_g) from the class playgame.*/
/*This method(geneseegame()) uses the the above final values/arraylists      when calling the method Playgame(hole_o, yardage_o, par_o) from the class playgame.*/
/*This method(geneseegame()) uses the the above final values/arraylists     when calling the method Playgame(hole_m, yardage_m, par_m) from the class playgame.*/
/*This method has instances of type course and asks the user for Course Number and based on the user preferences, it calls for the type of course the user chose to play. If the user chooses a course Numberwhich is not in the list, the program will quit executing a print line statement with information.*/
/** * Lee el fichero, y rellena distances y stations */
/** * Lee el fichero, y rellena distances y stations */
/** * Rellena station con todas la estaciones encontradas en el fichero *  * @param s */
/** * Rellena distances[][] con s por la estacion stationTreat *  * @param s * @param stationTreat */
/**     * Create the test case     *     * @param testName name of the test case     */
/**     * @return the suite of tests being tested     */
/**     * Rigourous Test :-)     */
/**     * @see HttpServlet#HttpServlet()     */
/** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */
/** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */
/** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */
/** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */
/** * Cha Xun Quan Bu  * @return */
/** * Xiu Gai Xin Xi  * @param stu * @throws SQLException */
/** * Zhong Zhi Mi Ma  * @param sno * @throws SQLException */
/** *Cha Zhao Quan Bu  * @return */
/** * Xiu Gai Xin Xi  * @param tea * @throws SQLException */
/** * Zhong Zhi Mi Ma  * @param sno * @throws SQLException */
/** * Pan Duan Shi Fou Cheng Gong  * @param count * @return */
/*@Overridepublic String toString() {return "Bank [compte=" + compte + ", client=" + client + "]";}*/
/*@Overridepublic String toString() {return "Bank [compte=" + compte + ", client=" + client + "]";}*/
/** * Reads an image from a file inside the current classpath. *  * @return the image; can be displayed and used in ImageIcons. */
/** * Extracts the first match of a pattern against a string. *  * @param pattern *            to use, which MUST contain parenthesis. For example, to *            extract 15 from <code>"a: 12, b: 15, c: -8"</code>, the *            pattern <code>"b: ([0-9-]+)"</code> could be used. * @param source *            string, which is expected to contain the pattern * @return the first match; or an exception if no matches are found. */
/** * Generates an iterator for generating random colors. It generates the same * sequences of colors over different runs since it always uses the same * seed. *  *  * @return An iterator for generating random colors. */
/** * A game error * @param msg that describes the error */
/** * A game error that wraps an exception * @param msg that describes the error * @param cause of the error */
/** * @return the current number of players */
/** * @return the name of the game, by defualt the name of the class */
/** * Evaluates how close playerNumber is to winning (1) or losing (-1). A draw * or game that has not started is considered neutral. * * @param playerNumber *            to evaluate for * @return 0 if the game is a draw, or not yet in play and not won, 1 (-1) *         if the game is a win (loss) for that player, intermediate values *         for other scenarios. */
/** * @param file *            to save to; can later be loaded via <code>load</code> */
/** * @param file *            written in a previous call to <code>save()</code> */
/**     * Constructor.     * @param threads to run concurrently. The actual number of concurrently running     *                threads can be calculated as     *                Min(threads, actualProcessors, validMovesInInitialState)     */
/**     * @return the number of board evaluations performed during the last     *  chooseNode() search     */
/**     * Create a simple non-special move. Notice that the check     * field, if needed, must be set externally. This is because checking     * for check usually involves testing out the move.     *     * @param player that moves     * @param srcRow for moving piece     * @param srcCol for moving piece     * @param dstRow for moving piece     * @param dstCol for moving piece     */
/**     * Initializes a chess-board with the pieces at their start positions.     */
/**     * checks if a piece has a given turn     * @param p board-piece     * @param turn (WHITE=0 or BLACK=1)     * @return true if and only if piece is of same turn as indicated     */
/**         * Returns icon-names for each piece.         * @param p (as obtained by ChessBoard.get())         * @return icon names such as "p_b.png" for a pawn that is black         */
/**     * Creates an empty chess board;     */
/**     * Creates a chess board with a given position     * @param previous board (used mostly to look at turn)     * @param board to use     * @param canCastle representing the state of castling; canCastle[WHITE] is     *                  0 if not allowed,     *                  1 if only short castling still possible,     *                  2 if only long castling still possible     *                  3 if both types of castling are still possible     * @param enPassant with column where enemy pawn just finished a double-advance     * @param inCheck if king is currently in check     */
/**     * @param player     * @return opposite player     */
/**     * @param board to search in     * @param turn of king to search for     * @param kingPos to write position into     * @return true if found, false if not     */
/**     * Generates valid moves for current player.     * This can only be called once per state     * (as states are immutable, and results get cached).     */
/**     * Returns a list of valid actions for the current player.     * @param playerNumber     *            to generate actions for     * @return     */
/**     * Returns the piece (see ChessBoard) at the given position.     * @param row     * @param col     * @return piece at the given position. Note that     *  chess piece codes are NOT player codes (there are many piece types).     *  See ChessBoard to make sense of the returned int:     *  ChessBoard.black(p) and ChessBoard.white(p) will tell you piece-color     *  ChessBoard.Piece.valueOf(p) will tell you piece-type.     */
/**     * @return a copy of the board     */
/**     * Used to generate non-pawn actions. Simply looks for empty-or-enemy squares     * along a given direction, given by row and column deltas. If 'multiple' is se to true,     * continues looking until non-empty square found (useful for rook, bishop, queen)     */
/**     * @param b board to check in     * @param turn of player that threatens     * @param row of victim     * @param col of victim     * @return true if there is at least 1 piece of turn that can capture the victim     */
/**     * @return true if the current player is in check     */
/** * Repeatedly plays a game-state with a vs b *  * @param initialState * @param a *            player * @param b *            player * @param times *            to play */
/** * Plays tick-tack-toe with a console player against a smart player. The * smart player should never lose. */
/** * Main method. *  * @param args */
/**     * Creates a new GameEvent. Not all fields are needed.     * @param type of action. Always present.     * @param action that caused this event. Can be null.     * @param state of the game when event was sent. Can be null if not yet started.     * @param error reported in an Error event. Must be null if not an error event.     * @param description intended for use in toString; must NOT be null     */
/**     * @return a copy of the board     */
/** * Shang Shu Fang Fa You Ge Yan Zhong De bug! * Ruo Yi Ge Zheng Shu You Yi nWei ,Ze Xu Yao Yong nGe 1Lai Bu Qi Zui Gao Wei .  * Yin Ci ,Dang Yi Ge Zheng Shu You Yi Liao Ruo Gan Ci Zhi Hou ,Ta De Suo You Wei Zhi Du Bei 1Qu Dai , * Ci Shi Yu 1Jin Xing Yu Yun Suan De Jie Guo Yong Yuan Shi 1,Cong Er Chu Xian Liao Si Xun Huan .  *  * Ru He Jie Jue Ni ? *  * Chu Xian Shang Shu Qing Kuang De Yuan Yin You Liang Ge :1.You Yi , 2.Zheng Shu , * Zhi Yao Po Pi Liao Zhe Liang Ge Tiao Jian Zhong De Ren He Yi Ge ,Jiu Neng Bi Mian Si Xun Huan De Xian Xiang .  * You Yu Ben Ti De Shu Ru Yao Qiu Zhong Bao Han Liao Zheng Zheng Shu ,Yin Ci Wo Men Zhi Neng Po Pi Di Yi Ge Tiao Jian .  *  * Sui Ran You Yi Yu Zheng Fu You Guan ,Dan Zuo Yi Yu Zheng Fu Wu Guan ! * Bing Qie Yao Da Dao He Fang Fa 1Yi Yang De Xiao Guo ,Wo Men Jiu Rang "00000001"Zhe Ge Xu Lie Zuo Yi .  *  * Dai Ma Ru Xia : */
/** * Shang Shu Cheng Xu You Ge Zhi Ming De Que Dian :You Yu nShi Wei Shu ,Ruo nHen Da Shi ,longDu Wu Fa Biao Shi Zhe Ge Shu Zi Gai Zen Yao Ban ? * Xiang Dao Zhe Dian ,Zhe Ge Wen Ti Qi Shi Jiu Shi Yi Dao Da Shu Wen Ti .  * Jie Jue Fang Fa :Cai Yong Shu Zu Lai Biao Shi Zhe Ge Da Shu ,Mei Wei Cun Yi Ge 0-9.  * You Yu Shu Zu De Nei Cun Da Xiao Ke Yi Wu Xian Zeng Da ,Yin Ci Shi Yong Shu Zu Cun Chu Da Shu Fei Chang He Gua .  * Dan Yong Shu Zu Cun Chu You Ge Que Dian ,Na Jiu Shi Xu Yao Wo Men Zi Ji Ding Yi Shu Zu De Di Zeng Han Shu ,Yi Bian Da Yin Shi Shi Yong ,Dai Ma Ru Xia : */
/** * Fan Zhuan Lian Biao  * @param first Lian Biao De Tou Jie Dian  * @return Fan Hui Fan Zhuan Hou Lian Biao De Tou Jie Dian  */
/** * Chu Zhan  * @return Fan Hui Zhan Ding Yuan Su  */
/** * Ru Dui   * @param obj Ru Dui De Yuan Su  */
/** * Cai Yong Di Gui De Fang Fa  */
/* please be Hannah */
/* decided to give Micah the win here in accordance with the poster itself */
/**   * TODO: provide a declarative way for beanshell command scripts to call   * back to Elisp.  Do it through this factory method, which will return a   * special bsh.This object with an overloaded namespace that has the same   * methods that are in the incoming object.  But when these methods are   * invoked, they actually do the printing of the arguments to stdout as   * lisp forms just like the invokeElisp method of ConnectionImpl does.   * More research to be done on this approach.   *   * @param bshObject a <code>This</code> value   * @return a <code>This</code> value   */
/**   * Package-local method for unit tests to be able to circumvent some   * protective checks in order to test the smallest possible units.   *   * @param flag whether unit testing is on or off   */
/**   * Creates a new <code>ConnectionImpl</code> instance.   */
/**   * Creates a new <code>ConnectionImpl</code> instance.   */
/**   * Set the output writer where lisp forms are written.   *   * @param writer a <code>PrintWriter</code> value   */
/**   * Creates a new <code>ConnectionUnavailableException</code> instance.   *   */
/**   * Creates a new <code>ConnectionUnavailableException</code> instance.   *   * @param msg custom error message   */
/**   * Creates a new <code>ElispError</code> instance.   *   */
/**     * Creates a new <code>LispWriter</code> instance.     */
/**   * Creates a new <code>Logger</code> instance.   */
/**   * Creates a new <code>Logger</code> instance.   */
/**   * Creates a new <code>NoMoreResultsException</code> instance.   *   */
/**   * Creates a new <code>Quoted</code> instance.   *   * @param quotedValue the <code>Object</code> to quote   */
/**   * Creates a new <code>Symbol</code> instance.   */
/**   * <p>Convert a camel-case java name (such as <code>jdeDoWorkNow</code>) to   * an elisp name with constituents separated by dashes   * (<code>jdee-do-work-now</code>).</p>   *   * <p>In general, convert a possibly fully-qualified java name to an elisp   * name, by the following algorithm:</p>   *   * <ul>   *   <li>Convert all non-letters and digits to dashes ('-').</li>   *   <li>Convert the transition from a lowercase letter to an uppercase   *   letter to a dash.</li>   *   <li>Downcase all letters.</li>   * </ul>   *   * <p>For example, the following java names all convert to the elisp name   * <code>jdee-foo-call-left-right</code>:</p>   *   * <ul>   *   <li><code>jdeFooCallLeftRight</code></li>   *   <li><code>jde.foo.Call.leftRight</code></li>   *   <li><code>jde.foo.CALL_LEFT_RIGHT</code></li>   * </ul>   *   * @param javaName    a java name   * @return            the converted elisp name   */
/**   * @deprecated    * @see #getEndColumn   */
/**   * @deprecated    * @see #getEndLine   */
/**   * Method to adjust line and column numbers for the start of a token.<BR>   */
/**   * Used to convert raw characters to their escaped version   * when these raw version cannot be used as part of an ASCII   * string literal.   */
/**   * This field is used to access special tokens that occur prior to this   * token, but after the immediately preceding regular (non-special) token.   * If there are no such special tokens, this field is set to null.   * When there are more than one such special token, this field refers   * to the last of these special tokens, which in turn refers to the next   * previous special token through its specialToken field, and so on   * until the first special token (whose specialToken field is null).   * The next fields of special tokens refer to other special tokens that   * immediately follow it (without an intervening regular token).  If there   * is no such token, this field is null.   */
/**   * Returns the image.   */
/**   * Returns a new Token object, by default. However, if you want, you   * can create and return subclass objects based on the value of ofKind.   * Simply add the cases to the switch for all those special cases.   * For example, if you have a subclass of Token called IDToken that   * you want to create if ofKind is ID, simlpy add something like :   *   *    case MyParserConstants.ID : return new IDToken();   *   * to the following switch statement. Then you can cast matchedToken   * variable to the appropriate type and use it in your lexical actions.   */
/*    * Constructors of various flavors follow.    */
/**    * Replaces unprintable characters by their espaced (or unicode escaped)    * equivalents in the given string    */
/**    * Returns a detailed message for the Error when it is thrown by the    * token manager to indicate a lexical error.    * Parameters :     *    EOFSeen     : indicates if EOF caused the lexicl error    *    curLexState : lexical state in which this error occured    *    errorLine   : line number when the error occured    *    errorColumn : column number when the error occured    *    errorAfter  : prefix that was seen before this error occured    *    curchar     : the offending character    * Note: You can customize the lexical error message by modifying this method.    */
/**    * You can also modify the body of this method to customize your error messages.    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not    * of end-users concern, so you can return something like :     *    *     "Internal Error : Please file a bug report .... "    *    * from this method for such cases in the release version of your parser.    */
/**    * <PRE>    * f0 -> "try"    * f1 -> Block()    * f2 -> ( "catch" "(" FormalParameter() ")" Block() )*    * f3 -> [ "finally" Block() ]    * </PRE>    */
/**    * The default constructor uses System.out as its output location.    * You may specify your own Writer or OutputStream using one of the    * other constructors.    */
/**    * Flushes the OutputStream or Writer that this TreeDumper is using.    */
/**    * Resets the position of the output "cursor" to the first line and    * column.  When using a dumper on a syntax tree more than once, you    * either need to call this method or startAtNextToken() between each    * dump.    */
/**    * Dumps the current NodeToken to the output stream being used.    *    * @throws  IllegalStateException   if the token position is invalid    *   relative to the current position, i.e. its location places it    *   before the previous token.    */
/**    * The default constructor assumes an indentation amount of 3 spaces    * and no line-wrap.  You may alternately use the other constructor to    * specify your own indentation amount and line width.    */
/**    * This constructor accepts an indent amount and a line width which is    * used to wrap long lines.  If a token's beginColumn value is greater    * than the specified wrapWidth, it will be moved to the next line and    * indented one extra level.  To turn off line-wrapping, specify a    * wrapWidth of 0.    *    * @param   indentAmt   Amount of spaces per indentation level.    * @param   wrapWidth   Wrap lines longer than wrapWidth.  0 for no wrap.    */
/**    * Use this method to add FormatCommands to the command queue to be    * executed when the next token in the tree is visited.    */
/**    * <PRE>    * f0 -> "try"    * f1 -> Block()    * f2 -> ( "catch" "(" FormalParameter() ")" Block() )*    * f3 -> [ "finally" Block() ]    * </PRE>    */
/**    * Inserts token location (beginLine, beginColumn, endLine, endColumn)    * information into the NodeToken.  Takes into account line-wrap.    * Does not update curLine and curColumn.    */
/**   * Tests whether a class is an ancestor of another class.   * This method prints "t" to standard out if the class is an ancestor   * of the other class. If the class is not an ancestor or either class   * cannot be found, this method prints nil to standard out.   * @param ancestor Name of the ancestor class   * @param child  Name of the supposed child class   */
/**   * Returns true if the entity is accessible to the specified level of   * protection.   * @param modifiers the modifiers as returned by Member.getModifiers()   * or Class.getModifiers()    * @param level the level of protection   * @return if the Member is accessible to the specified level of   * protection.   * @see Member.getModifiers()   * @see Class.getModifiers()   */
/**   * Creates a field info list. The list has the following form   *   *  (0 name access-level type)   *   * where 0 indicates that this info list is for a field, name is    * the name of the field, access-level is one of   * PUBLIC, PROTECTED, PACKAGE, or PRIVATE, and type is   * the type of the field.    *     * @param field field name    */
/**   * Prints (list "name" "params") to the system output.   *   * @param name constructor name   * @param params parameter type   */
/**   * Prints (list "name" "returnType" "args") to the system output.   *   * @param name method name   * @param returnType method return type   * @param args method arguments   */
/**   * Get (list INNERCLASSINFO "className" access)   *   * @param name className   */
/**   * Prints item within quotes i.e "item"   *   * @param item string to be quoted.   */
/**   * Looks up an unqualified class name in the class path to find possible   * fully qualified matches.   *   * @param className a value of type 'String'   * @param imports   an array of imported packages   */
/**   * Tests whether a class has a member of a specified name.   * If so, prints t to standard out; if not, nil.   *   * @param className Name of class   * @param memberName Name of member   */
/**     * Perform a recursive scan of the directory and set the loaded     * flag to true.     *     */
/**     * Search for classes in <code>directory</code> rooted at     * <code>rootDir</code>     *     * @param directory a <code>File</code> value     * @param rootDir a <code>File</code> value     */
/**     * return the directory as our string value.     *     * @return a <code>String</code> value     */
/**     * Returns the singleton/flyweight instance for     * <code>resource</code>.  The specific instance type returned is     * based on the extension of the file or on it being a directory.     *     * @param resource a <code>File</code> value     * @return a <code>ClassPathEntry</code> value     * @exception IOException if an error occurs     * @exception IllegalArgumentException if resource is not a     * zip/jar or a directory.     */
/**     * clears the class list in the entry.     *     */
/**     * clears and reloads the class list in the entry.     *     * @exception IOException if an error occurs     */
/**     * adds an unqualified => qualified mapping.     *     * @param qualifiedName a <code>String</code> value     */
/**     * Returns the list of qualified names that map to the specified     * unqualified name.  Lazily loads the classes.     *     * @param unqualifiedName a <code>String</code> value     * @return a <code>List</code> value     * @exception IOException if an error occurs     */
/**     * Get the value of loaded.     * @return value of loaded.     */
/**     * Set the value of loaded.     *     * @param loaded a <code>boolean</code> value     */
/**     *     * @param commands a <code>String[]</code> with     * the arguments to passed to compiler.     * @see com.sun.tools.javac.Main#compiler(String[] args)     */
/**   * Tests whether a class is an ancestor of another class.   * This method prints "t" to standard out if the class is an ancestor   * of the other class. If the class is not an ancestor or either class   * cannot be found, this method prints nil to standard out.   * @param ancestor Name of the ancestor class   * @param child  Name of the supposed child class   */
/**   * Returns true if the entity is accessible to the specified level of   * protection.   * @param modifiers the modifiers as returned by Member.getModifiers()   * or Class.getModifiers()    * @param level the level of protection   * @return if the Member is accessible to the specified level of   * protection.   * @see Member.getModifiers()   * @see Class.getModifiers()   */
/**   * Prints (list "name" "type") to the system output.   *   * @param name field name    * @param type field type   */
/**   * Prints (list "name" "params") to the system output.   *   * @param name constructor name   * @param params parameter type   */
/**   * Prints (list "name" "returnType" "args") to the system output.   *   * @param name method name   * @param returnType method return type   * @param args method arguments   */
/**   * Prints (list "className") to the system output.   *   * @param name className   */
/**   * <code>printExceptions</code>   *   * @param exceptions a <code>Class[]</code>   * @return a <code>String</code>   */
/**   * Recursively finds fields of the specified access level in the   * supplied class and superclasses.   *   * @param c the class to start the search in - nothing is done if   * this is NULL   * @param level  the access level to look for   * @param sb the StringBuffer where the results should be added   */
/**   * Finds constructors of the specified access level in the supplied class.   *   * @param c the class to search in   * @param level  the access level to look for   * @param sb the StringBuffer where the results should be added   */
/**   * Recursively finds methods of the specified access level in the   * supplied class and superclasses.   *   * @param c the class to start the search in - nothing is done if this is   * NULL   * @param level  the access level to look for   * @param sb the StringBuffer where the results should be added   */
/**   * Recursively finds inner classes of the specified access level   * in the supplied class and superclasses.   *   * @param c the class to start the search in - nothing is done if this is   * NULL   * @param level  the access level to look for   * @param sb the StringBuffer where the results should be added   */
/**   * Looks up an unqualified class name in the class path to find possible   * fully qualified matches.   *   * @param className a value of type 'String'   * @param imports   an array of imported packages   */
/**   * Loads a class information from the file system,   * if it fails it tries Class.forName(argClassName)   *   * @param argClassName name of the class to be loaded.   * @return Class of the type argClassName   * @exception ClassNotFoundException if the class cannot be found.   */
/**     *     * @param param1 <description>     */
/**     *     * @param param1 <description>     */
/**     *     * @param param1 <description>     */
/**     *     * @param param1 <description>     */
/**     *     * @param param1 <description>     */
/**     *     * @param param1 <description>     * @param param2 <description>     */
/**     *     * @param param1 <description>     * @param param2 <description>     * @param param3 <description>     */
/**     *     * @param param1 <description>     */
/**   * Jde should call this everytime the project changes, or if the   * classpath needs to be updated.   *   * @param projectName a <code>String</code> value   * @param projectClassPath a <code>String</code> value   */
/* Convenience to get current project's name */
/**   * Determine whether a class exists on the JDEE classpath.   *   * @param fqn Fully qualified name of the class to be found.   */
/**   * Reload the current project's classpath.   */
/**   * Looks up an unqualified class name in the class path to find possible   * fully qualified matches.  Given `List,' this will find   * `java.util.List' and `java.awt.List'   *   * @param className a value of type 'String'   */
/**     * Convenience method for retrieving the value for     * <code>key</code> as a List, even when there is only a single     * value for that key in the map.  The EMPTY_LIST is returned when     * no value is found for <code>key</code> making null checks     * unnecessary.     *     * @param key an <code>Object</code> value     * @return a <code>List</code> value     */
/**     * inserts value into the map for key as a single element or, if     * values already exist, as an entry in key's list.     *     * @param key an <code>Object</code> value     * @param value an <code>Object</code> value     * @return null     */
/**   * Reload all classes in classpath.   *   * @exception IOException if an error occurs   */
/**   * Get the classpath represented by this project.   *   * @return a <code>String</code> value   */
/**   * Get fully qualified classnames in this classpath that   * matching the specified unqualified name.   *   * @param unqualifiedName Unqualified name for which matching   * qualified names are to be found.   * @return list of qualified names.   * @exception IOException if an error occurs   */
/**   * loads the boot classpath entries.   *   * @exception IOException if an error occurs   */
/**      * Creates an AbstractClassFactory that uses the specified NameFactory for     * generating parameter names     *     * @param factory Factory for generating parameter names     */
/**     * Generates signatures based on introspection of the specified class.     *     * @param name the abstract class to process for signatures.     * @param truncate toggles truncation of package specifiers in signatures.     *     * @exception NotAnAbstractClassException the requested class isn't an     * abstract class     * @exception java.lang.ClassNotFoundException the requested class cannot     * be loaded     */
/**     * Creates a list of the abstract methods in argClass     *     * @param argClass Class to obtained the abstract methods from     * @param abstractMethods Contains a list of the abstract methods.     * @return a <code>Methods[]</code> containing abstract methods     */
/**     * Adds the abstract methods in <code>methods</code> into abstractMethods.     *     * @param methods a <code>Method[]</code> to be added     * @param abstractMethods a <code>Vector</code> to add abstract methods.     */
/**     * Makes an implementation of the abstract methods of an abstract class.     * This method delegates the creation of the implementation to     * makeAbstractClassInternal.     *     * @param name Name of abstract class to be implemented.     * @param truncate If <code>true</code>, truncate package specifier     * when generating code.     */
/**     * Makes an implementation of the abstract methods of an abstract class.     *     * @param name Name of abstract class to be implemented.     * @param truncate If <code>true</code>, truncate package specifier     * when generating code.     */
/**   * Make up a name for the nth parameter of a method.   * First this method tries to recognize bean methods, if the method is named   * "setName" and has one parameter, the parameter returned is the   * lowercased method name with "set" stripped: "name".   *   * Index Bean Properties are methods starting with "set" and having two   * parameters, the first one of which is an int, or methods starting with   * "get" and having only one int parameter. In both cases the first   * parameter is given the name "index".    *        * Examples:   *   *   void setName(String name);   *   void setNames(String[] names);   *   void setName(int index, String name);   *   String getName(int index);   *   * For other method names the parameters are named according to their   * type.    *   * Primitive types are named after the following mapping (now   * hardcoded, can perhaps be made configurable):   *   *   boolean: flag   *   byte: b   *   char: c   *   short: s   *   int: n   *   long: l   *   float: f   *   double: d   *    * Array types are named like their base type with the String "Array"   * appended, so a "byte[]" parameter will be named "byteArray":   *   *    void fill(char[] charArray);   *   * All other parameters will be named according to their type's unqualified   * lowercased classname:   *   *    void actionPerformed(ActionEvent actionEvent);   *   * To avoid any name clashes, the parameters will have a number appended   * if there is another parameter of the same type in the methods   * parameterlist:   *   *   void write(byte[] byteArray, int n, int n1);   *   void put(String string, String string1);   *   * @param sig  - signature of the declaring method   * @param num     - the parameter number whose name we want.   * @return a name for the n'th parameter of the method.   */
/**   * Generate a name for a parameter from the type of the parameter.   *   * @param className  the parameters type   * @return a more or less fitting name.   */
/**   * Make name unique, look if there a more parameters of this type   * before us. In this case append a number.   *   * @param parameters all parameter types of the method   * @param type the type of the current parameter   * @param num the position of the current parameter   * @param name parameter basename   * @return a unique parameter name   */
/**   * Strip the first characters from the string and decapitalize   * the rest.   *   * @param name the original name.   * @param strip number of characters to strip from the front of the name.   * @return the decapitalized and shortened name.   */
/**   * Creates a new <code>DelegateFactory</code> instance.   *   */
/**    * Creates a DelegateFactory that uses the specified NameFactory   * for generating parameter names    *   * @param factory Factory for generating parameter names   */
/**   * Gets a container containing the signatures of the delegation   * methods.   *   * @return the value of signatures   */
/**   * Specifies a container to hold the signatures of the   * delegator methods.   *   * @param argSignatures signature container   */
/**   * Gets the Delegate Factory   *   * @return the Delegate Factory   */
/**   * Sets the Delegate Factory   *   * @param argDelegateFactory the Delegate Factory   */
/**   * Gets the name of the delegator field that references the delegee.   *   * @return name of the delegee   */
/**   * Specifies the name of the delegator field that references the delegee.   *   * @param argDelegee the delegee   */
/**    * Clears the method signatures container.   */
/**   * Generates signatures for the public methods of the delegee   * class.    *   * @param delegeeClassName name of the delegee's class   * @param truncate toggles truncation of package specifiers in signatures.   *   * @exception ClassNotFoundException the requested class cannot   * be loaded    */
/**   * Generate delegator methods.   *   * @param delegeeFieldName Name of delagator field that reference   * the delegee.   * @param delegeeClassName  Name of delegee class.   * @param truncate If <code>true</code>, truncate package specifier   * when generating code.   *    */
/**   * Generates delegator methods.   *   * @param delegeeFieldName Name of delegator field that   * references the delegee.   * @param delegeeClassName Name of delegee's class.   * @param truncate If <code>true</code>, truncate package specifier   * when generating code.   */
/**   * Describe <code>getImportedClasses</code> method here.   *   */
/**   * Return a default body for the implementation of the method described   * by <code>sig</code>.   *   * @param sig a <code>Signature</code> value   * @return a <code>String</code> value   */
/**   * Prints delegator methods to the standard out of   * the current process, i.e., to Emacs.   *   * @param out a <code>PrintWriter</code> value   * @param truncate a <code>boolean</code> value   */
/**    * Creates an EventSourceFactory that uses the specified NameFactory   * for generating parameter names    *   * @param factory Factory for generating parameter names   */
/**   * Makes an implementation of an interface. This method delegates   * the creation of the implementation to makeInterfaceInternal.   *   * @param name Name of interface to be implemented.   * @param truncate If <code>true</code>, truncate package specifier   * when generating code.   */
/**   * Makes an implementation of an interface.   *   * @param name Name of interface to be implemented.   * @param truncate If <code>true</code>, truncate package specifier   * when generating code.   */
/**   * Adds the classes from the supplied Zip file to the class list.   *   * @param classList the Vector to add the classes to   * @param classPathFile the File to scan as a zip file   */
/**   * Adds the classes from the supplied directory to the class list.   *   * @param classList the Vector to add the classes to   * @param classPathFile the File to recursively scan as a directory   */
/**   * Looks up an unqualified class name in the class path to find possible   * fully qualified matches.   *   * @param className a value of type 'String'   */
/**   * Tests the ImportWizard from the command line   *   * @param args an array of strings containing class names to look up   */
/**    * Creates an InterfaceFactory that uses the specified NameFactory   * for generating parameter names    *   * @param factory Factory for generating parameter names   */
/**   * Gets the value of signatures   *   * @return the value of signatures   */
/**   * Sets the value of signatures   *   * @param argSignatures Value to assign to this.signatures   */
/**   * Gets the value of interfaceFactory   *   * @return the value of interfaceFactory   */
/**   * Sets the value of interfaceFactory   *   * @param argInterfaceFactory Value to assign to this.interfaceFactory   */
/**    * Adds a signature to signature container.   *   * @param sig Signature to be stored in the signature table.   */
/**    * Clears import hashtable and interface container for this factory so they   * can be re-used to process a new set of interfaces.   */
/**   * Generates signatures based on introspection of the specified class.    *   * @param name the interface to process for signatures.   * @param truncate toggles truncation of package specifiers in signatures..   *   * @exception NotAnInterfaceException the requested class isn't an interface   * @exception ClassNotFoundException Cannot find requested class   */
/**   * Makes an implementation of an interface.   *   * @param name Name of interface to be implemented.   * @param truncate If <code>true</code>, truncate package specifier   * when generating code.   */
/**   * Makes an expression for generating the implementation of an   * interface. This method delegates the creation of the   * implementation to makeInterfaceExpressionInternal.   *   * @param name Name of interface to be implemented.   * @param truncate If <code>true</code>, truncate package specifier   * when generating code.   */
/**   * Prints imported classes to standard out.   *   */
/**   * Describe <code>dumpExpression</code> method here.   *   * @param out a <code>PrintWriter</code> value   * @param truncate a <code>boolean</code> value   */
/**   * Constructs a default method factory.   */
/**    * Creates a method factory that uses the specified NameFactory   * for generating parameter names    *   * @param factory Factory for generating parameter names   */
/**    * Sets the factory for generating parameter names.   *   * @param factory Factory for generating parameter names.   */
/**    * Gets the factory used to generating parameter names for    * methods generated by this interface factory.   *   * @return Name factory   */
/**    * Gets a table containing the classes that must be imported to   * implement an interface generated by this factory.   *   * @return Classes required to implement the current interface.   */
/**   * Return the fully qualified names of classes that   * need to be imported to compile this interface   * implementation.   *   * @return Class names as elisp list of strings.   */
/**    * Registers a class that needs to be imported by the interface    * implementation generated by this factory. Store the class in the    * import hashtable if it passes the shouldImport test.     * Arrays have to be handled differently here.    *   * @param register Imported class candidate   */
/**   * Tests whether a specified class needs to be imported by the interface   * implementation generated by this factory.   * We don't import primitives.   *    * @param c the <code>Class</code> object to be tested   * @return <code>true</code> if the class should be imported   */
/**   * Return a default body for the implementation of the method described   * by <code>sig</code>.   *   * @param sig a <code>Signature</code> value   * @return a <code>String</code> value   */
/**   * Get a Lisp form that generates a skeleton   * implementation of a specified method. The   * List form is of the form   *   *   <code>(jdee-wiz-gen-method ... )</code>   *   * where <code>jdee-wiz-gen-method</code> is a   * function defined by the JDEE's jdee-wiz package.   *   * @param sig a <code>Signature</code> value   * @return a <code>String</code> value   */
/**    * Clears the import hashtables for this factory so it   * can be re-used to process a new set of methods.   */
/**   * Print a string and flush the output buffer to   * ensure that the string reaches Emacs immediately.   *   * @param s a <code>String</code> value   */
/**    * Creates a MethodOverrideFactory that uses the specified NameFactory   * for generating parameter names    *   * @param factory Factory for generating parameter names   */
/**   * Return a <code>Vector</code> containing all <code>Method</code>   * objects for the argument class and methodName which can be   * overridden.   *   * @param cl the <code>Class</code> for which all methods that can   * be overridden will be returned.   * @param methodName the name of the Method to be returned.   * @return a <code>Vector</code> of <code>Method</code> objects.   */
/**   * Get a list of signatures for all methods of a specified name defined   * or inherited by a specified class. The signatures returned by this method   * including only the types of the method parameters as the generated names   * are unnecessary for signature matching. This method prints the signature   * list to standard out as a Lisp list form.   *   * @param baseClassName a <code>String</code> value that specifies the name of   * the class that defines or inherits the methods whose signatures are to be   * returned.   * @param methodName a <code>String</code> value that specifies the name of the   * methods whose signatures are to be returned.   */
/**    * Clears the import and candidate hashtables for this factory so they   * can be re-used to process a new set of interfaces.   */
/**   * Gets the candidate signatures for the class and method   * passed as arguments on the command line.   *   * @param args a <code>String[]</code> value   */
/**    * Creates a signature for the specified method and register   * its types with the specified registry (which may be null).   * Removes package info from generated signatures.   *   * @param meth Method represented by this signature   * @param aregistry Registry containing this signature   */
/**    * Creates a signature for the specified method and register its   * types with the specified registry (which may be null).   *   * @param meth Method represented by thi signature   * @param aregistry Registry containing this signature   * @param truncate toggles removal of package info from generated signatures    */
/**    * Creates a signature for the specified method and register its   * types with the specified registry (which may be null).   *   * @param meth Method represented by thi signature   * @param aregistry Registry containing this signature   * @param truncate toggles removal of package info from generated signatures    */
/**    * Toggles truncation of package info .   *    * @param b Truncation toggle   */
/**    * Sets the registry used to register this signature's types.   *    * @param registry Registry used to register this signature's type.   */
/**    * Gets the class that declared the method represented by this signature.   *   * @return The class this method was declared in    */
/**    * Generates a javadoc string for this signature.   *    * @return A javadoc for this method   */
/**    * Gets the signature as a string.   *   * @return Signature of this method.   */
/**   * Describe <code>paramsEqual</code> method here.   *   * @param p a <code>Class[]</code> value   * @return a <code>boolean</code> value   */
/**   * Tests whether a given object equals this signature.   * The object is considered equal if it is a signature   * and it has the same method name and parameter list.   *   * @param compare Test object   * @return <code>true</code> if the test object equals this signature.   */
/**   * Gets the method of which this is a signature.   *   * @return Method of which this is a signature.   */
/**    *  Computes the basename of the specified class.  This returns   *  "Object" from "java.lang.Object."  It returns the "single"   *  form of an Array object.   *   *  In the case of inner classes, the base name includes   *  the outer class name, e.g.,   *   *    mypackage.OuterClass$InnerClass   *   *  is returned as   *   *    OuterClass.InnerClass   *   * @param type Class whose basename is required   *    * @return basename   */
/**   * Make a list of all given exceptions separated by commas.   *   * @param except Array of exception types   * @return Comma-separated list of exceptions   */
/**    * Gets a throw clause listing the exceptions thrown by this method.   *    * @param except Vector of exceptions   *   * @return Exceptions thrown by this method.   */
/**    * Gets a parameter list for this method; parameters are named   * by the NameFactory whose default implementation uses param1   * .. paramn    *   * @param params Parameters of this method   * @param withName toggles parameter names   *   * @return Parameter list in string form   */
/**    * Gets a list of parameter names for this method; parameters are   * named by the NameFactory whose default implementation uses param1   * .. paramn.  Class type names are not included in the result   * Contributed by Charles Hart <cfhart@Z-TEL.com>   *   * @param params Parameters of this method   *   * @return Parameter list in string form */
/**   * Gets list of modifiers for this method.   * Interface methods are always public and may be synchronized    *   * @return a <code>String</code> containing a list of modifiers   */
/**    * Gets the base type of the return value.   *   * @return Base type of return value.   */
/**    * Register this Signature's types with the SignatureRegistry   */
/**    * Adds a signature to the container. Signatures are not   * added if they're already registered because we do not want   * duplicate method implementations even though a class might   * implement interfaces that inherit from some common   * super-interface.   *   * @param sig Signature to be stored in the signature table.   */
/**   * Check whether container already contains signature.   *   * @param sig a <code>Signature</code> value   * @return a <code>boolean</code> value   */
/**    * Clear the signature container.   */
/**   * True if this container is empty of signatures.   *   * @return a <code>boolean</code> value   */
/**   * Visit each signature in the container.   *   * @param visitor the SignatureVisitor object visiting the signatures   */
/**     * Creates a new <code>CallbackImpl</code> instance.     */
/**     * De Dao Xian Xing Biao De Chang Du      * @return     */
/**     * Huo Qu Lian Biao Di iGe Zhi      * @param i     * @return     * @throws Exception     */
/**     * Zai You Xu De Xian Xing Biao Zhong Cha Ru Yi Ge Jie Dian Zhi Wei x     * @param x     */
/**     * Da Zheng Shu Xiang Jia      * @param x1     * @param x2     * @return     * @throws Exception     */
/**     * Da Zheng Shu Xiang Jian      * @param x1     * @param x2     * @return     * @throws Exception     */
/**     * Pan Duan Biao Da Shi Shi Fou He Fa      * @param str     * @return     * @throws Exception     */
/**     * Huo Qu Di Zhi      * @param key     * @return     */
/**     * Huo Qu Di Zhi      * @param key     * @return     */
/**     * Huo Qu Di Zhi      * @param key     * @return     */
/**     * Huo Qu Di Zhi      * @param key     * @return     */
/**     * Pan Duan Jie Dian Shi Fou Cun Zai      * @param element     * @return     */
/**     * Yi Chu Yuan Su      * @param element     */
/*if (biTree.insertBST(key[i],elem[i])){                System.out.println("["+key[i]+","+elem[i]+"]");            }*/
/*if (biTree.insertBST(key[i],elem[i])){                System.out.println("["+key[i]+","+elem[i]+"]");            }*/
/**     * Ke Long Dui Xiang      * @param obj     * @return     */
/**     * He Bing Liang Ban You Xu Shu Zu      * @param a     * @param begin     * @param k (begin:k-1)(k:end) Liang Zu      * @param end     */
/**     * Ji Suan Shu Zu aNei De Zhong Shu      * @param a     * @param begin     * @param end     * @return     */
/**     * Fan Zhuan Shu Zu  arrays Cong Wei Zhi l-r     * @param arrays     * @param l     * @param r     */
/* *     * getQing Qiu      * @author slx     * @date 2019/03/13 16:51     * @param [url, map]     * @return HttpResult     */
/* *     * getQing Qiu      * @author slx     * @date 2019/03/13 16:51     * @param [url, map]     * @return HttpResult     */
/* *     * postQing Qiu      * @author slx     * @date 2019/03/13 18:13     * @param [url, map]     * @return com.example.HttpClient.HttpResult     */
/* *     * PutQing Qiu      * @author slx     * @date 2019/03/13 13:14     * @param [url, map]     * @return com.example.HttpClient.HttpResult     */
/* *     *  DeleteQing Qiu      * @author slx     * @date 2019/03/13 18:20     * @param [url, map]     * @return com.example.HttpClient.HttpResult     */
/**     * Huo Qu Ke Hu Duan ipDi Zhi      * @param request     * @return     */
/**     * Pan Duan Shi Fou Wei ajaxQing Qiu      * @param request     * @return     */
/**     * She Zhi You Jian Biao Ti      * @param title Biao Ti Xin Xi      * @return     */
/**     * She Zhi You Jian Nei Rong      * @param content     * @return     */
/**     * She Zhi You Jian Ge Shi      * @param typeEnum     * @return     */
/**     * She Zhi Qing Qiu Mu Biao You Jian Di Zhi      * @param targets     * @return     */
/**     * She Zhi You Jian Biao Ti      * @param title Biao Ti Xin Xi      * @return     */
/**     * She Zhi You Jian Nei Rong      * @param content     * @return     */
/**     * She Zhi You Jian Ge Shi      * @param typeEnum     * @return     */
/**     * She Zhi Qing Qiu Mu Biao You Jian Di Zhi      * @param targets     * @return     */
/**     * Zhi Xing Fa Song You Jian      * @throws Exception Ru Guo Fa Song Shi Bai Hui Pao Chu Yi Chang Xin Xi      */
/**     * Ce Shi Chuang Jian Lu Jing      * @throws InterruptedException     */
/**     * Ce Shi Chuang Jian Lu Jing      * @throws InterruptedException     */
/** * Construct message from array of bytes (e.g. received through socket). * The values are expected to be encoded in Network Byte Order. *  * @param buffer Array of bytes (size `MESSAGE_SIZE`) * @return Parsed message */
/** * Serialize the message as a byte array. All values * are stored with MSB first, Network Byte Order. *  * @return The message serialized as an array of bytes  */
/* public void K3(){        public void J3(){    System.out.println("J3");//java doesnot support inner method    }        System.out.println("K3");    }*/
/* public void K3(){        public void J3(){    System.out.println("J3");//java doesnot support inner method    }        System.out.println("K3");    }*/
/* public void K3(){        public void J3(){    System.out.println("J3");//java doesnot support inner method    }        System.out.println("K3");    }*/
/**     * Remember that float only stores a precision of 6-7 digits, if you need more use double     * <p>     * https://www.educba.com/java-float-vs-double/     */
/**     * Remember that float only stores a precision of 6-7 digits, if you need more use double     * <p>     * https://www.educba.com/java-float-vs-double/     */
/**     * Remember that float only stores a precision of 6-7 digits, if you need more use double     * <p>     * https://www.educba.com/java-float-vs-double/     */
/**     * Remember that float only stores a precision of 6-7 digits, if you need more use double     * <p>     * https://www.educba.com/java-float-vs-double/     */
/**     * Java has support for some of the mathematical constants     * <p>     * https://examples.javacodegeeks.com/core-java/math/using-math-constants/     */
/**     * Calculate:     * 1. Acceleration - A = deltaV (difference in speed) / deltaT (difference in time)     * 1.1 deltaV = finalSpeed - startSpeed     *  1.2 deltaT = finalTime - startTime (or time used in total)     * @param startSpeed     * @param finalSpeed     * @param timeUsedInSeconds     * @param objectMass     */
/**     * Printing can be done in many different ways in java     *     * Check out format printing: https://www.baeldung.com/java-printstream-printf     */
/**     * String offers quite a few built in methods like toLowerCase, toUpperCase, trim, etc     *     * https://www.w3schools.com/java/java_ref_string.asp     */
/**     * StringBuilder is a utility class that offers additional functionality when working with strings     *     * https://www.javatpoint.com/StringBuilder-class     */
/**     * Length and substring are two of the very useful built in string methods     *     * https://beginnersbook.com/2013/12/java-string-substring-method-example/     */
/**     * For simple string concatenations it's ok to use + but when concatenating in a loop always remember     * to use StringBuilder     *     * https://stackoverflow.com/questions/1532461/stringbuilder-vs-string-concatenation-in-tostring-in-java     */
/**     * Comparing string in java can be done with == or equals     * ==     - compares references (addresses in memory)     * equals - compares values     *     * https://www.javatpoint.com/string-comparison-in-java     */
/**     * Regexes help you identify certain patterns in a String     *     * https://www.vogella.com/tutorials/JavaRegularExpressions/article.html     */
/**     * @param arr   - the array in which the value is searhed     * @param left  - left index of the interval used for searching     * @param right - right index of the interval used for searching     * @param x     - the searched value     * @return - the index where the value was found or -1 in case the value is not found in the array     */
/**     * Method that computes the factorial value of the parameter received.     */
/**     * Method that computes the fibonacci value.     * @return - the n(th) value from the fibonacci numbers.     */
/**     * Sort the array using the bubble sort algorithm.     *     * @param arr - array to be sorted.     */
/**     * Sort the array using the insertion sort algorithm.     * @param arr - array to be sorted.     */
/**     * Sort the array using the selection sort algorithm.     *     * @param arr - array to be sorted.     */
/**     * Constructor to initialize an object of this class.     */
/**     * This method implements the functionality of adding a new element to the list.     * The element will be added in the beginning of the list.     * @param newNode - the node to be inserted.     */
/**     * Inserts a new node at the end of the list.     * @param newNode - node to be added     */
/**     * Display in the console all the elements from the list.     */
/**     * Constructor to initialize the queue.     */
/**     * Method to add a new element to the queue.     *     * @param value - value to be added     */
/**     * @return - and remove the first node from the queue.     */
/**     * @return - the front node without removing it.     */
/**     * Constructor to initialize the stack.     *     * @param s - the size of the stack     */
/**     * Method that adds a new element to the stack.     *     * @param value - the value to be added     * @return - true if the value was inserted successfully and false otherwise     */
/**     * Method that returns end removes the top element from the stack. Program will close if the stack is empty.     *     * @return - the top element from the stack     */
/**     * @return - the top element from the stack without removing it.     */
/**     * Method that checks if the stack is empty.     *     * @return - true if the stack is empty and false otherwise.     */
/**     * Method that check if the stack is full.     *     * @return - true if the stack is full and false otherwise     */
/**    @Deprecated    reason - we will not be using this anymore     */
/*         * LIST - ordered collection of elements.         * Elements can be accessed by their index.         */
/*    If we had used inheritance and one of our other subclasses    had used this method but we wanted to remove it we would    have been locked in, composition keeps things flexible.     */
/*    If we had used inheritance and one of our other subclasses    had used this method but we wanted to remove it we would    have been locked in, composition keeps things flexible.     */
/*    If we had used inheritance and one of our other subclasses    had used this method but we wanted to remove it we would    have been locked in, composition keeps things flexible.     */
/*The Java throws keyword is used to declare an exception.It gives an information to the programmer that there may occur an exceptionso it is better for the programmer to provide the exception handlingcode so that normal flow can be maintained. Exception Handling ismainly used to handle the checked exceptions. */
/*The Java throws keyword is used to declare an exception.It gives an information to the programmer that there may occur an exceptionso it is better for the programmer to provide the exception handlingcode so that normal flow can be maintained. Exception Handling ismainly used to handle the checked exceptions. */
/** Puts an X or O mark at position i,j. */
/** Puts an X or O mark at position i,j. */
/** Checks whether the board configuration is a win for the given player. */
/** display the winning player or indicate a tie (or unfinished game). */
/**     * Constructor - opens database connection to database, This version     * determines if the app is running locally or not (by checking if     * "temple.edu" is at the end of the hostname of the machine on which you     * are running your app).     */
/**     * Constructor - opens database connection to database, This version uses     * boolean input parameter to determine if the app is running locally or not     */
/**     * Open a connection to your database either using the Temple connection     * string or the local connection string.     *     * @param isTemple: if this is true, it will use the Temple connection     * string (else it will use the local connection string).     */
/* Returns database connection for use in SQL classes.  */
/* Returns database connection error message or "" if there is none.  */
/**     * Close database connection.     */
/**     * Checks the hostname to see if app is running at Temple or not.     */
/** * Create a simple Java program PrintHometown.java (console application) * to print the name of your hometown, compile and run it.  */
/** * Create a simple Java program CurrentDateTime.java to print * the current date and time. */
/** * Write a program SumTwoNumbers.java that enters two integers from the console, * calculates and prints their sum. Search in Internet to learn how to read  * numbers from the console.  */
/** * Write a program that enters from the console number n and n strings, * then sorts them alphabetically and prints them. Note: you might need * to learn how to use loops and arrays in Java (search in Internet).  */
/** * Write a program to generate a PDF document called Deck-of-Cards.pdf and print  * in it a standard deck of 52 cards, following one after another.  * Each card should be a rectangle holding its face and suit.  */
/** * Write a program that enters the sides of a rectangle (two integers a and b)  * and calculates and prints the rectangle's area */
/** * Write a program that enters 3 points in the plane (as integer x and y coordinates), *  calculates and prints the area of the triangle composed by these 3 points. *  Round the result to a whole number. In case the three points do not form a triangle,  *  print "0" as result. */
/** * Write a program to check whether a point is inside or outside of the figure below. * The point is given as a pair of floating-point numbers, separated by a space.  * Your program should print "Inside" or "Outside" */
/** * Write a program that finds the smallest of three numbers.  */
/** * Write a program that enters a positive integer number num and converts  * and prints it in hexadecimal form. You may use some built-in method from *  the standard Java libraries */
/** * Write a program that reads 3 numbers: an integer a (0 <= a <= 500), * a floating-point b and a floating-point c and prints them in  * 4 virtual columns on the console. Each column should have a width of 10 characters. * The number a should be printed in hexadecimal, left aligned; * then the number a should be printed in binary form, padded with zeroes, * then the number b should be printed with 2 digits after the decimal point, right aligned; * the number c should be printed with 3 digits after the decimal point, left aligned */
/** * Write a program to calculate the count of bits 1 in the binary * representation of given integer number n */
/** * Write a program to calculate the count of bits 1 in the binary * representation of given integer number n */
/** * Write a program to count how many sequences of two equal bits ("00" or "11") can be found  * in the binary representation of given integer number n (with overlapping). */
/** * Write a program to count how many sequences of two equal bits ("00" or "11") can be found  * in the binary representation of given integer number n (with overlapping). */
/**     * This is the main swing application method.   It sets up and displays the     * initial GUI, and controls execution thereafter.  Everything else in     * this class is 'private', please read the code.     */
/*     * usage A private static method to display usage information to     * the user before an error exit.     */
/*     * go This method reads the file, creates the table to display,     * the window to display it in, and displays the window.     * @param fileName the name of the file to read.     * @param tryLines An estimate of the number of lines in     * the file.     */
/*    * setDefaultTableView    */
/*     * A private method to dump the arrays of Object[][]     * if desired by the developer     * @param objs The array of arrays to be dumped.     */
/*     * enableAll     */
/*     * getADate Returns a new DateTime object reference if possible,     * otherwise null.     * @return retDT A DateTime object reference.     */
/*     * LPad Return a String, left padded with '0's as specified     * by the caller.     */
/*     * resetDefaults     */
/*         * validateFile         */
/*         * genColNames is required by the base class.         */
/*         * genCalcdValues is required by the base class.         */
/*         * actionPerformed         */
/**     * Constructor     */
/**     * Constructor     */
/**     * Start the stopwatch.     */
/**     * End the stopwatch and print the result.     */
/**     * Constructs an instance set to the current system millisecond time     * using <code>ISOChronology</code> in the default time zone.     * The constructed object will have a local time of midnight.     *      * @see #now()     */
/**     * Constructs an instance set to the current system millisecond time     * using <code>ISOChronology</code> in the specified time zone.     * The constructed object will have a local time of midnight.     * <p>     * If the specified time zone is null, the default zone is used.     *     * @param zone  the time zone, null means default zone     * @see #now(DateTimeZone)     */
/**     * Constructs an instance set to the current system millisecond time     * using the specified chronology.     * The constructed object will have a local time of midnight.     * <p>     * If the chronology is null, <code>ISOChronology</code>     * in the default time zone is used.     *     * @param chronology  the chronology, null means ISOChronology in default zone     * @see #now(Chronology)     */
/**     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z     * using <code>ISOChronology</code> in the default time zone.     * The constructed object will have a local time of midnight.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     */
/**     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z     * using <code>ISOChronology</code> in the specified time zone.     * The constructed object will have a local time of midnight.     * <p>     * If the specified time zone is null, the default zone is used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param zone  the time zone, null means default zone     */
/**     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z     * using the specified chronology.     * The constructed object will have a local time of midnight.     * <p>     * If the chronology is null, <code>ISOChronology</code>     * in the default time zone is used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param chronology  the chronology, null means ISOChronology in default zone     */
/**     * Constructs an instance from an Object that represents a datetime.     * The constructed object will have a local time of midnight.     * <p>     * If the object implies a chronology (such as GregorianCalendar does),     * then that chronology will be used. Otherwise, ISO default is used.     * Thus if a GregorianCalendar is passed in, the chronology used will     * be GJ, but if a Date is passed in the chronology will be ISO.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.     *     * @param instant  the datetime object, null means now     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs an instance from an Object that represents a datetime,     * forcing the time zone to that specified.     * The constructed object will have a local time of midnight.     * <p>     * If the object implies a chronology (such as GregorianCalendar does),     * then that chronology will be used, but with the time zone adjusted.     * Otherwise, ISO is used in the specified time zone.     * If the specified time zone is null, the default zone is used.     * Thus if a GregorianCalendar is passed in, the chronology used will     * be GJ, but if a Date is passed in the chronology will be ISO.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.     *     * @param instant  the datetime object, null means now     * @param zone  the time zone, null means default time zone     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs an instance from an Object that represents a datetime,     * using the specified chronology.     * The constructed object will have a local time of midnight.     * <p>     * If the chronology is null, ISO in the default time zone is used.     * Any chronology implied by the object (such as GregorianCalendar does)     * is ignored.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.     *     * @param instant  the datetime object, null means now     * @param chronology  the chronology, null means ISOChronology in default zone     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs an instance from datetime field values     * using <code>ISOChronology</code> in the default time zone.     * The constructed object will have a local time of midnight.     *     * @param year  the year     * @param monthOfYear  the month of the year, from 1 to 12     * @param dayOfMonth  the day of the month, from 1 to 31     */
/**     * Constructs an instance from datetime field values     * using <code>ISOChronology</code> in the specified time zone.     * The constructed object will have a local time of midnight.     * <p>     * If the specified time zone is null, the default zone is used.     *     * @param year  the year     * @param monthOfYear  the month of the year, from 1 to 12     * @param dayOfMonth  the day of the month, from 1 to 31     * @param zone  the time zone, null means default time zone     */
/**     * Constructs an instance from datetime field values     * using the specified chronology.     * The constructed object will have a local time of midnight.     * <p>     * If the chronology is null, <code>ISOChronology</code>     * in the default time zone is used.     *     * @param year  the year, valid values defined by the chronology     * @param monthOfYear  the month of the year, valid values defined by the chronology     * @param dayOfMonth  the day of the month, valid values defined by the chronology     * @param chronology  the chronology, null means ISOChronology in default zone     */
/**     * Returns a copy of this date with a different millisecond instant.     * The returned object will have a local time of midnight.     * <p>     * Only the millis will change, the chronology and time zone are kept.     * The returned object will be either be a new instance or <code>this</code>.     *     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z     * @return a copy of this instant with different millis     */
/**     * Returns a copy of this date with a different chronology, potentially     * changing the day in unexpected ways.     * <p>     * This method creates a new DateMidnight using the midnight millisecond value     * and the new chronology. If the same or similar chronology is specified, but     * with a different time zone, the day may change. This occurs because the new     * DateMidnight rounds down the millisecond value to get to midnight, and the     * time zone change may result in a rounding down to a different day.     * <p>     * For example, changing time zone from London (+00:00) to Paris (+01:00) will     * retain the same day, but changing from Paris to London will change the day.     * (When its midnight in London its the same day in Paris, but when its midnight     * in Paris its still the previous day in London)     * <p>     * To avoid these unusual effects, use {@link #withZoneRetainFields(DateTimeZone)}     * to change time zones.     *     * @param newChronology  the new chronology     * @return a copy of this instant with a different chronology     */
/**     * Returns a copy of this date with a different time zone, preserving the day     * The returned object will have a local time of midnight in the new zone on     * the same day as the original instant.     *     * @param newZone  the new time zone, null means default     * @return a copy of this instant with a different time zone     */
/**     * Returns a copy of this date with the partial set of fields replacing those     * from this instance.     * <p>     * For example, if the partial is a <code>LocalDate</code> then the date fields     * would be changed in the returned instance.     * If the partial is null, then <code>this</code> is returned.     *     * @param partial  the partial set of fields to apply to this datetime, null ignored     * @return a copy of this datetime with a different set of fields     * @throws IllegalArgumentException if any value is invalid     */
/**     * Returns a copy of this date with the specified field set to a new value.     * <p>     * For example, if the field type is <code>dayOfMonth</code> then the day of month     * field would be changed in the returned instance.     * If the field type is null, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);     * DateTime updated = dt.dayOfMonth().setCopy(6);     * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this datetime with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this date with the value of the specified field increased.     * <p>     * If the addition is zero or the field is null, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * DateMidnight added = dt.withFieldAdded(DateTimeFieldType.year(), 6);     * DateMidnight added = dt.plusYears(6);     * DateMidnight added = dt.year().addToCopy(6);     * </pre>     *      * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this datetime with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date with the specified duration added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     *      * @param durationToAdd  the duration to add to this one     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this datetime with the duration added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date with the specified duration added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     *      * @param durationToAdd  the duration to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this datetime with the duration added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusYears(int)}.     *      * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this datetime with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date with the specified duration added.     * <p>     * If the amount is zero, then <code>this</code> is returned.     *      * @param duration  the duration, in millis, to add to this one     * @return a copy of this datetime with the duration added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date with the specified duration added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *      * @param duration  the duration to add to this one, null means zero     * @return a copy of this datetime with the duration added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusYears(int)}.     *      * @param period  the duration to add to this one, null means zero     * @return a copy of this datetime with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date plus the specified number of years.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateMidnight added = dt.plusYears(6);     * DateMidnight added = dt.plus(Period.years(6));     * DateMidnight added = dt.withFieldAdded(DurationFieldType.years(), 6);     * </pre>     *     * @param years  the amount of years to add, may be negative     * @return the new datetime plus the increased years     * @since 1.1     */
/**     * Returns a copy of this date plus the specified number of months.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateMidnight added = dt.plusMonths(6);     * DateMidnight added = dt.plus(Period.months(6));     * DateMidnight added = dt.withFieldAdded(DurationFieldType.months(), 6);     * </pre>     *     * @param months  the amount of months to add, may be negative     * @return the new datetime plus the increased months     * @since 1.1     */
/**     * Returns a copy of this date plus the specified number of weeks.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateMidnight added = dt.plusWeeks(6);     * DateMidnight added = dt.plus(Period.weeks(6));     * DateMidnight added = dt.withFieldAdded(DurationFieldType.weeks(), 6);     * </pre>     *     * @param weeks  the amount of weeks to add, may be negative     * @return the new datetime plus the increased weeks     * @since 1.1     */
/**     * Returns a copy of this date plus the specified number of days.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateMidnight added = dt.plusDays(6);     * DateMidnight added = dt.plus(Period.days(6));     * DateMidnight added = dt.withFieldAdded(DurationFieldType.days(), 6);     * </pre>     *     * @param days  the amount of days to add, may be negative     * @return the new datetime plus the increased days     * @since 1.1     */
/**     * Returns a copy of this date with the specified duration taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *      * @param duration  the duration, in millis, to reduce this instant by     * @return a copy of this datetime with the duration taken away     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date with the specified duration taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *      * @param duration  the duration to reduce this instant by     * @return a copy of this datetime with the duration taken away     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date with the specified period taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusYears(int)}.     *      * @param period  the period to reduce this instant by     * @return a copy of this datetime with the period taken away     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date minus the specified number of years.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusYears(6);     * DateTime subtracted = dt.minus(Period.years(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);     * </pre>     *     * @param years  the amount of years to subtract, may be negative     * @return the new datetime minus the increased years     * @since 1.1     */
/**     * Returns a copy of this date minus the specified number of months.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateMidnight subtracted = dt.minusMonths(6);     * DateMidnight subtracted = dt.minus(Period.months(6));     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);     * </pre>     *     * @param months  the amount of months to subtract, may be negative     * @return the new datetime minus the increased months     * @since 1.1     */
/**     * Returns a copy of this date minus the specified number of weeks.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateMidnight subtracted = dt.minusWeeks(6);     * DateMidnight subtracted = dt.minus(Period.weeks(6));     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);     * </pre>     *     * @param weeks  the amount of weeks to subtract, may be negative     * @return the new datetime minus the increased weeks     * @since 1.1     */
/**     * Returns a copy of this date minus the specified number of days.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateMidnight subtracted = dt.minusDays(6);     * DateMidnight subtracted = dt.minus(Period.days(6));     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);     * </pre>     *     * @param days  the amount of days to subtract, may be negative     * @return the new datetime minus the increased days     * @since 1.1     */
/**     * Returns a copy of this date with the era field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * era changed.     *     * @param era  the era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the century of era field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * century of era changed.     *     * @param centuryOfEra  the centurey of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the year of era field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of era changed.     *     * @param yearOfEra  the year of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the year of century field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of century changed.     *     * @param yearOfCentury  the year of century to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the year field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year changed.     *     * @param year  the year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the weekyear field updated.     * <p>     * The weekyear is the year that matches with the weekOfWeekyear field.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * The weekyear allows you to query the effective year for that day.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * weekyear changed.     *     * @param weekyear  the weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the month of year field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * month of year changed.     *     * @param monthOfYear  the month of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the week of weekyear field updated.     * <p>     * This field is associated with the "weekyear" via {@link #withWeekyear(int)}.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * week of weekyear changed.     *     * @param weekOfWeekyear  the week of weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the day of year field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of year changed.     *     * @param dayOfYear  the day of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the day of month field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of month changed.     *     * @param dayOfMonth  the day of month to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the day of week field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of week changed.     *     * @param dayOfWeek  the day of week to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**         * Gets the datetime being used.         *          * @return the datetime         */
/**         * Adds to this field in a copy of this DateMidnight.         * <p>         * The DateMidnight attached to this property is unchanged by this call.         * This operation is faster than converting a DateMidnight to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param value  the value to add to the field in the copy         * @return a copy of the DateMidnight with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to this field in a copy of this DateMidnight.         * <p>         * The DateMidnight attached to this property is unchanged by this call.         * This operation is faster than converting a DateMidnight to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param value  the value to add to the field in the copy         * @return a copy of the DateMidnight with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to this field, possibly wrapped, in a copy of this DateMidnight.         * A wrapped operation only changes this field.         * Thus 31st January addWrapField one day goes to the 1st January.         * <p>         * The DateMidnight attached to this property is unchanged by this call.         * This operation is faster than converting a DateMidnight to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param value  the value to add to the field in the copy         * @return a copy of the DateMidnight with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the DateMidnight.         * <p>         * The DateMidnight attached to this property is unchanged by this call.         * This operation is faster than converting a DateMidnight to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param value  the value to set the field in the copy to         * @return a copy of the DateMidnight with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the DateMidnight to a parsed text value.         * <p>         * The DateMidnight attached to this property is unchanged by this call.         * This operation is faster than converting a DateMidnight to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param text  the text value to set         * @param locale  optional locale to use for selecting a text symbol         * @return a copy of the DateMidnight with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Sets this field in a copy of the DateMidnight to a parsed text value.         * <p>         * The DateMidnight attached to this property is unchanged by this call.         * This operation is faster than converting a DateMidnight to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param text  the text value to set         * @return a copy of the DateMidnight with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new DateMidnight with this field set to the maximum value         * for this field.         * <p>         * This operation is useful for obtaining a DateTime on the last day         * of the month, as month lengths vary.         * <pre>         * DateMidnight lastDayOfMonth = dt.dayOfMonth().withMaximumValue();         * </pre>         * <p>         * The DateMidnight attached to this property is unchanged by this call.         *         * @return a copy of the DateMidnight with this field set to its maximum         * @since 1.2         */
/**         * Returns a new DateMidnight with this field set to the minimum value         * for this field.         * <p>         * The DateMidnight attached to this property is unchanged by this call.         *         * @return a copy of the DateMidnight with this field set to its minimum         * @since 1.2         */
/**         * Rounds to the lowest whole unit of this field on a copy of this DateMidnight.         *         * @return a copy of the DateMidnight with the field value changed         */
/**         * Rounds to the highest whole unit of this field on a copy of this DateMidnight.         *         * @return a copy of the DateMidnight with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,         * favoring the floor if halfway.         *         * @return a copy of the DateMidnight with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,         * favoring the ceiling if halfway.         *         * @return a copy of the DateMidnight with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight.         * If halfway, the ceiling is favored over the floor only if it makes this field's value even.         *         * @return a copy of the DateMidnight with the field value changed         */
/**     * Obtains a {@code DateMidnight} set to the current system millisecond time     * using the specified chronology.     * The constructed object will have a local time of midnight.     *     * @param chronology  the chronology, not null     * @return the current date, not null     * @since 2.0     */
/**     * Parses a {@code DateMidnight} from the specified string using a formatter.     *      * @param str  the string to parse, not null     * @param formatter  the formatter to use, not null     * @since 2.0     */
/**     * Rounds the specified instant to midnight.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round     * @param chronology  the chronology to use, not null     * @return the updated instant, rounded to midnight     */
/**     * Returns a copy of this date with a different millisecond instant.     * The returned object will have a local time of midnight.     * <p>     * Only the millis will change, the chronology and time zone are kept.     * The returned object will be either be a new instance or <code>this</code>.     *     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z     * @return a copy of this instant with different millis     */
/**     * Returns a copy of this date with a different chronology, potentially     * changing the day in unexpected ways.     * <p>     * This method creates a new DateMidnight using the midnight millisecond value     * and the new chronology. If the same or similar chronology is specified, but     * with a different time zone, the day may change. This occurs because the new     * DateMidnight rounds down the millisecond value to get to midnight, and the     * time zone change may result in a rounding down to a different day.     * <p>     * For example, changing time zone from London (+00:00) to Paris (+01:00) will     * retain the same day, but changing from Paris to London will change the day.     * (When its midnight in London its the same day in Paris, but when its midnight     * in Paris its still the previous day in London)     * <p>     * To avoid these unusual effects, use {@link #withZoneRetainFields(DateTimeZone)}     * to change time zones.     *     * @param newChronology  the new chronology     * @return a copy of this instant with a different chronology     */
/**     * Returns a copy of this date with a different time zone, preserving the day     * The returned object will have a local time of midnight in the new zone on     * the same day as the original instant.     *     * @param newZone  the new time zone, null means default     * @return a copy of this instant with a different time zone     */
/**     * Returns a copy of this date with the partial set of fields replacing those     * from this instance.     * <p>     * For example, if the partial is a <code>LocalDate</code> then the date fields     * would be changed in the returned instance.     * If the partial is null, then <code>this</code> is returned.     *     * @param partial  the partial set of fields to apply to this datetime, null ignored     * @return a copy of this datetime with a different set of fields     * @throws IllegalArgumentException if any value is invalid     */
/**     * Returns a copy of this date with the specified field set to a new value.     * <p>     * For example, if the field type is <code>dayOfMonth</code> then the day of month     * field would be changed in the returned instance.     * If the field type is null, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);     * DateTime updated = dt.dayOfMonth().setCopy(6);     * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this datetime with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this date with the value of the specified field increased.     * <p>     * If the addition is zero or the field is null, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * DateMidnight added = dt.withFieldAdded(DateTimeFieldType.year(), 6);     * DateMidnight added = dt.plusYears(6);     * DateMidnight added = dt.year().addToCopy(6);     * </pre>     *      * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this datetime with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date with the specified duration added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     *      * @param durationToAdd  the duration to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this datetime with the duration added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusYears(int)}.     *      * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this datetime with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusYears(int)}.     *      * @param period  the duration to add to this one, null means zero     * @return a copy of this datetime with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date plus the specified number of years.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateMidnight added = dt.plusYears(6);     * DateMidnight added = dt.plus(Period.years(6));     * DateMidnight added = dt.withFieldAdded(DurationFieldType.years(), 6);     * </pre>     *     * @param years  the amount of years to add, may be negative     * @return the new datetime plus the increased years     * @since 1.1     */
/**     * Returns a copy of this date plus the specified number of months.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateMidnight added = dt.plusMonths(6);     * DateMidnight added = dt.plus(Period.months(6));     * DateMidnight added = dt.withFieldAdded(DurationFieldType.months(), 6);     * </pre>     *     * @param months  the amount of months to add, may be negative     * @return the new datetime plus the increased months     * @since 1.1     */
/**     * Returns a copy of this date plus the specified number of weeks.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateMidnight added = dt.plusWeeks(6);     * DateMidnight added = dt.plus(Period.weeks(6));     * DateMidnight added = dt.withFieldAdded(DurationFieldType.weeks(), 6);     * </pre>     *     * @param weeks  the amount of weeks to add, may be negative     * @return the new datetime plus the increased weeks     * @since 1.1     */
/**     * Returns a copy of this date plus the specified number of days.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateMidnight added = dt.plusDays(6);     * DateMidnight added = dt.plus(Period.days(6));     * DateMidnight added = dt.withFieldAdded(DurationFieldType.days(), 6);     * </pre>     *     * @param days  the amount of days to add, may be negative     * @return the new datetime plus the increased days     * @since 1.1     */
/**     * Returns a copy of this date with the specified period taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusYears(int)}.     *      * @param period  the period to reduce this instant by     * @return a copy of this datetime with the period taken away     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date minus the specified number of years.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusYears(6);     * DateTime subtracted = dt.minus(Period.years(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);     * </pre>     *     * @param years  the amount of years to subtract, may be negative     * @return the new datetime minus the increased years     * @since 1.1     */
/**     * Returns a copy of this date minus the specified number of months.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateMidnight subtracted = dt.minusMonths(6);     * DateMidnight subtracted = dt.minus(Period.months(6));     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);     * </pre>     *     * @param months  the amount of months to subtract, may be negative     * @return the new datetime minus the increased months     * @since 1.1     */
/**     * Returns a copy of this date minus the specified number of weeks.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateMidnight subtracted = dt.minusWeeks(6);     * DateMidnight subtracted = dt.minus(Period.weeks(6));     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);     * </pre>     *     * @param weeks  the amount of weeks to subtract, may be negative     * @return the new datetime minus the increased weeks     * @since 1.1     */
/**     * Returns a copy of this date minus the specified number of days.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateMidnight subtracted = dt.minusDays(6);     * DateMidnight subtracted = dt.minus(Period.days(6));     * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);     * </pre>     *     * @param days  the amount of days to subtract, may be negative     * @return the new datetime minus the increased days     * @since 1.1     */
/**     * Gets the property object for the specified type, which contains many useful methods.     *     * @param type  the field type to get the chronology for     * @return the property object     * @throws IllegalArgumentException if the field is null or unsupported     */
/**     * Converts this object to a <code>LocalDate</code> with the     * same date and chronology.     *     * @return a LocalDate with the same date and chronology     * @since 1.3     */
/**     * Converts this object to an <code>Interval</code> encompassing     * the whole of this day.     * <p>     * The interval starts at midnight 00:00 and ends at 00:00 the following day,     * (which is not included in the interval, as intervals are half-open).     *      * @return an interval over the day     */
/**     * Returns a copy of this date with the era field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * era changed.     *     * @param era  the era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the century of era field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * century of era changed.     *     * @param centuryOfEra  the centurey of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the year of era field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of era changed.     *     * @param yearOfEra  the year of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the year of century field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of century changed.     *     * @param yearOfCentury  the year of century to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the year field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year changed.     *     * @param year  the year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the weekyear field updated.     * <p>     * The weekyear is the year that matches with the weekOfWeekyear field.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * The weekyear allows you to query the effective year for that day.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * weekyear changed.     *     * @param weekyear  the weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the month of year field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * month of year changed.     *     * @param monthOfYear  the month of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the week of weekyear field updated.     * <p>     * This field is associated with the "weekyear" via {@link #withWeekyear(int)}.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * week of weekyear changed.     *     * @param weekOfWeekyear  the week of weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the day of year field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of year changed.     *     * @param dayOfYear  the day of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the day of month field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of month changed.     *     * @param dayOfMonth  the day of month to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the day of week field updated.     * <p>     * DateMidnight is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of week changed.     *     * @param dayOfWeek  the day of week to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Get the era property which provides access to advanced functionality.     *      * @return the era property     */
/**     * Get the century of era property which provides access to advanced functionality.     *      * @return the year of era property     */
/**     * Get the year of century property which provides access to advanced functionality.     *      * @return the year of era property     */
/**     * Get the year of era property which provides access to advanced functionality.     *      * @return the year of era property     */
/**     * Get the year property which provides access to advanced functionality.     *      * @return the year property     */
/**     * Get the year of a week based year property which provides access to advanced functionality.     *      * @return the year of a week based year property     */
/**     * Get the month of year property which provides access to advanced functionality.     *      * @return the month of year property     */
/**     * Get the week of a week based year property which provides access to advanced functionality.     *      * @return the week of a week based year property     */
/**     * Get the day of year property which provides access to advanced functionality.     *      * @return the day of year property     */
/**     * Get the day of month property which provides access to advanced functionality.     *      * @return the day of month property     */
/**     * Get the day of week property which provides access to advanced functionality.     *      * @return the day of week property     */
/**         * Writes the property in a safe serialization format.         */
/**         * Reads the property from a safe serialization format.         */
/**         * Gets the field being used.         *          * @return the field         */
/**         * Gets the milliseconds of the datetime that this property is linked to.         *          * @return the milliseconds         */
/**         * Gets the chronology of the datetime that this property is linked to.         *          * @return the chronology         * @since 1.4         */
/**         * Gets the datetime being used.         *          * @return the datetime         */
/**         * Adds to this field in a copy of this DateMidnight.         * <p>         * The DateMidnight attached to this property is unchanged by this call.         * This operation is faster than converting a DateMidnight to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param value  the value to add to the field in the copy         * @return a copy of the DateMidnight with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to this field, possibly wrapped, in a copy of this DateMidnight.         * A wrapped operation only changes this field.         * Thus 31st January addWrapField one day goes to the 1st January.         * <p>         * The DateMidnight attached to this property is unchanged by this call.         * This operation is faster than converting a DateMidnight to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param value  the value to add to the field in the copy         * @return a copy of the DateMidnight with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the DateMidnight to a parsed text value.         * <p>         * The DateMidnight attached to this property is unchanged by this call.         * This operation is faster than converting a DateMidnight to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param text  the text value to set         * @return a copy of the DateMidnight with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new DateMidnight with this field set to the maximum value         * for this field.         * <p>         * This operation is useful for obtaining a DateTime on the last day         * of the month, as month lengths vary.         * <pre>         * DateMidnight lastDayOfMonth = dt.dayOfMonth().withMaximumValue();         * </pre>         * <p>         * The DateMidnight attached to this property is unchanged by this call.         *         * @return a copy of the DateMidnight with this field set to its maximum         * @since 1.2         */
/**         * Returns a new DateMidnight with this field set to the minimum value         * for this field.         * <p>         * The DateMidnight attached to this property is unchanged by this call.         *         * @return a copy of the DateMidnight with this field set to its minimum         * @since 1.2         */
/**         * Rounds to the lowest whole unit of this field on a copy of this DateMidnight.         *         * @return a copy of the DateMidnight with the field value changed         */
/**         * Rounds to the highest whole unit of this field on a copy of this DateMidnight.         *         * @return a copy of the DateMidnight with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,         * favoring the floor if halfway.         *         * @return a copy of the DateMidnight with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight,         * favoring the ceiling if halfway.         *         * @return a copy of the DateMidnight with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this DateMidnight.         * If halfway, the ceiling is favored over the floor only if it makes this field's value even.         *         * @return a copy of the DateMidnight with the field value changed         */
/**     * Constructs an instance set to the current system millisecond time     * using <code>ISOChronology</code> in the default time zone.     *      * @see #now()     */
/**     * Constructs an instance set to the current system millisecond time     * using <code>ISOChronology</code> in the specified time zone.     * <p>     * If the specified time zone is null, the default zone is used.     *     * @param zone  the time zone, null means default zone     * @see #now(DateTimeZone)     */
/**     * Constructs an instance set to the current system millisecond time     * using the specified chronology.     * <p>     * If the chronology is null, <code>ISOChronology</code>     * in the default time zone is used.     *     * @param chronology  the chronology, null means ISOChronology in default zone     * @see #now(Chronology)     */
/**     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z     * using <code>ISOChronology</code> in the default time zone.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     */
/**     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z     * using <code>ISOChronology</code> in the specified time zone.     * <p>     * If the specified time zone is null, the default zone is used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param zone  the time zone, null means default zone     */
/**     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z     * using the specified chronology.     * <p>     * If the chronology is null, <code>ISOChronology</code>     * in the default time zone is used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param chronology  the chronology, null means ISOChronology in default zone     */
/**     * Constructs an instance from an Object that represents a datetime.     * <p>     * If the object implies a chronology (such as GregorianCalendar does),     * then that chronology will be used. Otherwise, ISO default is used.     * Thus if a GregorianCalendar is passed in, the chronology used will     * be GJ, but if a Date is passed in the chronology will be ISO.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.     *     * @param instant  the datetime object, null means now     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs an instance from an Object that represents a datetime,     * forcing the time zone to that specified.     * <p>     * If the object implies a chronology (such as GregorianCalendar does),     * then that chronology will be used, but with the time zone adjusted.     * Otherwise, ISO is used in the specified time zone.     * If the specified time zone is null, the default zone is used.     * Thus if a GregorianCalendar is passed in, the chronology used will     * be GJ, but if a Date is passed in the chronology will be ISO.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.     *     * @param instant  the datetime object, null means now     * @param zone  the time zone, null means default time zone     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs an instance from an Object that represents a datetime,     * using the specified chronology.     * <p>     * If the chronology is null, ISO in the default time zone is used.     * Any chronology implied by the object (such as GregorianCalendar does)     * is ignored.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}.     *     * @param instant  the datetime object, null means now     * @param chronology  the chronology, null means ISO in default zone     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Get this object as a DateTime by returning <code>this</code>.     *      * @return <code>this</code>     */
/**     * Get this object as a DateTime using ISOChronology in the default zone,     * returning <code>this</code> if possible.     *      * @return a DateTime using the same millis     */
/**     * Get this object as a DateTime, returning <code>this</code> if possible.     *      * @param zone time zone to apply, or default if null     * @return a DateTime using the same millis     */
/**     * Get this object as a DateTime, returning <code>this</code> if possible.     *      * @param chronology chronology to apply, or ISOChronology if null     * @return a DateTime using the same millis     */
/**     * Returns a copy of this datetime with different millis.     * <p>     * The returned object will be either be a new instance or <code>this</code>.     * Only the millis will change, the chronology and time zone are kept.     *     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z     * @return a copy of this datetime with different millis     */
/**     * Returns a copy of this datetime with a different chronology.     * <p>     * The returned object will be either be a new instance or <code>this</code>.     * Only the chronology will change, the millis are kept.     *     * @param newChronology  the new chronology, null means ISO default     * @return a copy of this datetime with a different chronology     */
/**     * Returns a copy of this datetime with a different time zone, preserving the     * millisecond instant.     * <p>     * This method is useful for finding the local time in another timezone.     * For example, if this instant holds 12:30 in Europe/London, the result     * from this method with Europe/Paris would be 13:30.     * <p>     * The returned object will be a new instance of the same implementation type.     * This method changes the time zone, and does not change the     * millisecond instant, with the effect that the field values usually change.     * The returned object will be either be a new instance or <code>this</code>.     *     * @param newZone  the new time zone     * @return a copy of this datetime with a different time zone     * @see #withZoneRetainFields     */
/**     * Returns a copy of this datetime with a different time zone, preserving the     * field values.     * <p>     * This method is useful for finding the millisecond time in another timezone.     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).     * <p>     * The returned object will be a new instance of the same implementation type.     * This method changes the time zone and the millisecond instant to keep     * the field values the same.     * The returned object will be either be a new instance or <code>this</code>.     *     * @param newZone  the new time zone, null means default     * @return a copy of this datetime with a different time zone     * @see #withZone     */
/**     * Returns a copy of this ZonedDateTime changing the zone offset to the earlier     * of the two valid offsets at a local time-line overlap.     * <p>     * This method only has any effect when the local time-line overlaps, such as at     * an autumn daylight savings cutover. In this scenario, there are two valid offsets     * for the local date-time. Calling this method will return a date-time with the     * earlier of the two selected.     * <p>     * If this method is called when it is not an overlap, this is returned.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @return a copy of this datetime with the earliest valid offset for the local datetime     */
/**     * Returns a copy of this ZonedDateTime changing the zone offset to the later     * of the two valid offsets at a local time-line overlap.     * <p>     * This method only has any effect when the local time-line overlaps, such as at     * an autumn daylight savings cutover. In this scenario, there are two valid offsets     * for the local date-time. Calling this method will return a date-time with the     * later of the two selected.     * <p>     * If this method is called when it is not an overlap, this is returned.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @return a copy of this datetime with the latest valid offset for the local datetime     */
/**     * Returns a copy of this datetime with the specified date, retaining the time fields.     * <p>     * If the date is already the date passed in, then <code>this</code> is returned.     * <p>     * To set a single field use the properties, for example:     * <pre>     * DateTime set = monthOfYear().setCopy(6);     * </pre>     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param year  the new year value     * @param monthOfYear  the new monthOfYear value     * @param dayOfMonth  the new dayOfMonth value     * @return a copy of this datetime with a different date     * @throws IllegalArgumentException if any value if invalid     */
/**     * Returns a copy of this datetime with the specified time, retaining the date fields.     * <p>     * If the time is already the time passed in, then <code>this</code> is returned.     * <p>     * To set a single field use the properties, for example:     * <pre>     * DateTime set = dt.hourOfDay().setCopy(6);     * </pre>     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param hourOfDay  the hour of the day     * @param minuteOfHour  the minute of the hour     * @param secondOfMinute  the second of the minute     * @param millisOfSecond  the millisecond of the second     * @return a copy of this datetime with a different time     * @throws IllegalArgumentException if any value if invalid     */
/**     * Returns a copy of this datetime with the time set to the start of the day.     * <p>     * The time will normally be midnight, as that is the earliest time on     * any given day. However, in some time zones when Daylight Savings Time     * starts, there is no midnight because time jumps from 11:59 to 01:00.     * This method handles that situation by returning 01:00 on that date.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @return a copy of this datetime with the time set to the start of the day, not null     */
/**     * Returns a copy of this datetime with the partial set of fields replacing those     * from this instance.     * <p>     * For example, if the partial is a <code>TimeOfDay</code> then the time fields     * would be changed in the returned instance.     * If the partial is null, then <code>this</code> is returned.     *     * @param partial  the partial set of fields to apply to this datetime, null ignored     * @return a copy of this datetime with a different set of fields     * @throws IllegalArgumentException if any value is invalid     */
/**     * Returns a copy of this datetime with the specified field set to a new value.     * <p>     * For example, if the field type is <code>hourOfDay</code> then the hour of day     * field would be changed in the returned instance.     * If the field type is null, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);     * DateTime updated = dt.dayOfMonth().setCopy(6);     * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this datetime with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this datetime with the value of the specified field increased.     * <p>     * If the addition is zero or the field is null, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);     * DateTime added = dt.plusYears(6);     * DateTime added = dt.plus(Period.years(6));     * </pre>     *      * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this datetime with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime with the specified duration added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     *      * @param durationToAdd  the duration to add to this one     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this datetime with the duration added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime with the specified duration added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     *      * @param durationToAdd  the duration to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this datetime with the duration added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusYears(int)}.     *      * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this datetime with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime with the specified duration added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * This datetime instance is immutable and unaffected by this method call.     *      * @param duration  the duration, in millis, to add to this one     * @return a copy of this datetime with the duration added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime with the specified duration added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * This datetime instance is immutable and unaffected by this method call.     *      * @param duration  the duration to add to this one, null means zero     * @return a copy of this datetime with the duration added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime with the specified period added.     * <p>     * This method will add each element of the period one by one, from largest     * to smallest, adjusting the datetime to be accurate between each.     * <p>     * Thus, adding a period of one month and one day to 2007-03-31 will     * work as follows:     * First add one month and adjust, resulting in 2007-04-30     * Then add one day and adjust, resulting in 2007-05-01.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusYears(int)}.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * This datetime instance is immutable and unaffected by this method call.     *      * @param period  the duration to add to this one, null means zero     * @return a copy of this datetime with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime plus the specified number of years.     * <p>     * The calculation will do its best to only change the year field     * retaining the same month of year.     * However, in certain circumstances, it may be necessary to alter     * smaller fields. For example, 2008-02-29 plus one year cannot result     * in 2009-02-29, so the day of month is adjusted to 2009-02-28.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusYears(6);     * DateTime added = dt.plus(Period.years(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to add, may be negative     * @return the new datetime plus the increased years     * @since 1.1     */
/**     * Returns a copy of this datetime plus the specified number of months.     * <p>     * The calculation will do its best to only change the month field     * retaining the same day of month.     * However, in certain circumstances, it may be necessary to alter     * smaller fields. For example, 2007-03-31 plus one month cannot result     * in 2007-04-31, so the day of month is adjusted to 2007-04-30.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusMonths(6);     * DateTime added = dt.plus(Period.months(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to add, may be negative     * @return the new datetime plus the increased months     * @since 1.1     */
/**     * Returns a copy of this datetime plus the specified number of weeks.     * <p>     * The calculation operates as if it were adding the equivalent in days.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusWeeks(6);     * DateTime added = dt.plus(Period.weeks(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to add, may be negative     * @return the new datetime plus the increased weeks     * @since 1.1     */
/**     * Returns a copy of this datetime plus the specified number of days.     * <p>     * The calculation will do its best to only change the day field     * retaining the same time of day.     * However, in certain circumstances, typically daylight savings cutover,     * it may be necessary to alter the time fields.     * <p>     * In spring an hour is typically removed. If adding one day results in     * the time being within the cutover then the time is adjusted to be     * within summer time. For example, if the cutover is from 01:59 to 03:00     * and the result of this method would have been 02:30, then the result     * will be adjusted to 03:30.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusDays(6);     * DateTime added = dt.plus(Period.days(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to add, may be negative     * @return the new datetime plus the increased days     * @since 1.1     */
/**     * Returns a copy of this datetime plus the specified number of hours.     * <p>     * The calculation will add a duration equivalent to the number of hours     * expressed in milliseconds.     * <p>     * For example, if a spring daylight savings cutover is from 01:59 to 03:00     * then adding one hour to 01:30 will result in 03:30. This is a duration     * of one hour later, even though the hour field value changed from 1 to 3.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusHours(6);     * DateTime added = dt.plus(Period.hours(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to add, may be negative     * @return the new datetime plus the increased hours     * @since 1.1     */
/**     * Returns a copy of this datetime plus the specified number of minutes.     * <p>     * The calculation will add a duration equivalent to the number of minutes     * expressed in milliseconds.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusMinutes(6);     * DateTime added = dt.plus(Period.minutes(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to add, may be negative     * @return the new datetime plus the increased minutes     * @since 1.1     */
/**     * Returns a copy of this datetime plus the specified number of seconds.     * <p>     * The calculation will add a duration equivalent to the number of seconds     * expressed in milliseconds.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusSeconds(6);     * DateTime added = dt.plus(Period.seconds(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to add, may be negative     * @return the new datetime plus the increased seconds     * @since 1.1     */
/**     * Returns a copy of this datetime plus the specified number of millis.     * <p>     * The calculation will add a duration equivalent to the number of milliseconds.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusMillis(6);     * DateTime added = dt.plus(Period.millis(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param millis  the amount of millis to add, may be negative     * @return the new datetime plus the increased millis     * @since 1.1     */
/**     * Returns a copy of this datetime with the specified duration taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * This datetime instance is immutable and unaffected by this method call.     *      * @param duration  the duration, in millis, to reduce this instant by     * @return a copy of this datetime with the duration taken away     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime with the specified duration taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * This datetime instance is immutable and unaffected by this method call.     *      * @param duration  the duration to reduce this instant by     * @return a copy of this datetime with the duration taken away     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime with the specified period taken away.     * <p>     * This method will subtract each element of the period one by one, from     * largest to smallest, adjusting the datetime to be accurate between each.     * <p>     * Thus, subtracting a period of one month and one day from 2007-05-31 will     * work as follows:     * First subtract one month and adjust, resulting in 2007-04-30     * Then subtract one day and adjust, resulting in 2007-04-29.     * Note that the day has been adjusted by two.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusYears(int)}.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * This datetime instance is immutable and unaffected by this method call.     *      * @param period  the period to reduce this instant by     * @return a copy of this datetime with the period taken away     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime minus the specified number of years.     * <p>     * The calculation will do its best to only change the year field     * retaining the same month of year.     * However, in certain circumstances, it may be necessary to alter     * smaller fields. For example, 2008-02-29 minus one year cannot result     * in 2007-02-29, so the day of month is adjusted to 2007-02-28.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusYears(6);     * DateTime subtracted = dt.minus(Period.years(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to subtract, may be negative     * @return the new datetime minus the increased years     * @since 1.1     */
/**     * Returns a copy of this datetime minus the specified number of months.     * <p>     * The calculation will do its best to only change the month field     * retaining the same day of month.     * However, in certain circumstances, it may be necessary to alter     * smaller fields. For example, 2007-05-31 minus one month cannot result     * in 2007-04-31, so the day of month is adjusted to 2007-04-30.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusMonths(6);     * DateTime subtracted = dt.minus(Period.months(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to subtract, may be negative     * @return the new datetime minus the increased months     * @since 1.1     */
/**     * Returns a copy of this datetime minus the specified number of weeks.     * <p>     * The calculation operates as if it were subtracting the equivalent in days.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusWeeks(6);     * DateTime subtracted = dt.minus(Period.weeks(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to subtract, may be negative     * @return the new datetime minus the increased weeks     * @since 1.1     */
/**     * Returns a copy of this datetime minus the specified number of days.     * <p>     * The calculation will do its best to only change the day field     * retaining the same time of day.     * However, in certain circumstances, typically daylight savings cutover,     * it may be necessary to alter the time fields.     * <p>     * In spring an hour is typically removed. If subtracting one day results     * in the time being within the cutover then the time is adjusted to be     * within summer time. For example, if the cutover is from 01:59 to 03:00     * and the result of this method would have been 02:30, then the result     * will be adjusted to 03:30.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusDays(6);     * DateTime subtracted = dt.minus(Period.days(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to subtract, may be negative     * @return the new datetime minus the increased days     * @since 1.1     */
/**     * Returns a copy of this datetime minus the specified number of hours.     * <p>     * The calculation will subtract a duration equivalent to the number of     * hours expressed in milliseconds.     * <p>     * For example, if a spring daylight savings cutover is from 01:59 to 03:00     * then subtracting one hour from 03:30 will result in 01:30. This is a     * duration of one hour earlier, even though the hour field value changed     * from 3 to 1.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusHours(6);     * DateTime subtracted = dt.minus(Period.hours(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to subtract, may be negative     * @return the new datetime minus the increased hours     * @since 1.1     */
/**     * Returns a copy of this datetime minus the specified number of minutes.     * <p>     * The calculation will subtract a duration equivalent to the number of     * minutes expressed in milliseconds.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusMinutes(6);     * DateTime subtracted = dt.minus(Period.minutes(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to subtract, may be negative     * @return the new datetime minus the increased minutes     * @since 1.1     */
/**     * Returns a copy of this datetime minus the specified number of seconds.     * <p>     * The calculation will subtract a duration equivalent to the number of     * seconds expressed in milliseconds.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusSeconds(6);     * DateTime subtracted = dt.minus(Period.seconds(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to subtract, may be negative     * @return the new datetime minus the increased seconds     * @since 1.1     */
/**     * Returns a copy of this datetime minus the specified number of millis.     * <p>     * The calculation will subtract a duration equivalent to the number of     * milliseconds.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusMillis(6);     * DateTime subtracted = dt.minus(Period.millis(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param millis  the amount of millis to subtract, may be negative     * @return the new datetime minus the increased millis     * @since 1.1     */
/**     * Returns a copy of this datetime with the era field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * era changed.     *     * @param era  the era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the century of era field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * century of era changed.     *     * @param centuryOfEra  the centurey of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the year of era field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of era changed.     *     * @param yearOfEra  the year of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the year of century field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of century changed.     *     * @param yearOfCentury  the year of century to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the year field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year changed.     *     * @param year  the year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the weekyear field updated.     * <p>     * The weekyear is the year that matches with the weekOfWeekyear field.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * The weekyear allows you to query the effective year for that day.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * weekyear changed.     *     * @param weekyear  the weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the month of year field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * month of year changed.     *     * @param monthOfYear  the month of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the week of weekyear field updated.     * <p>     * This field is associated with the "weekyear" via {@link #withWeekyear(int)}.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * week of weekyear changed.     *     * @param weekOfWeekyear  the week of weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the day of year field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of year changed.     *     * @param dayOfYear  the day of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the day of month field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of month changed.     *     * @param dayOfMonth  the day of month to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the day of week field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of week changed.     *     * @param dayOfWeek  the day of week to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the hour of day field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * hour of day changed.     *     * @param hour  the hour of day to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the minute of hour updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * minute of hour changed.     *     * @param minute  the minute of hour to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the second of minute field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * second of minute changed.     *     * @param second  the second of minute to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the millis of second field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * millis of second changed.     *     * @param millis  the millis of second to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the millis of day field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * millis of day changed.     *     * @param millis  the millis of day to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**         * Gets the field being used.         *          * @return the field         */
/**         * Gets the datetime being used.         *          * @return the datetime         */
/**         * Adds to this field in a copy of this DateTime.         * <p>         * The DateTime attached to this property is unchanged by this call.         * This operation is faster than converting a DateTime to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param value  the value to add to the field in the copy         * @return a copy of the DateTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to this field in a copy of this DateTime.         * <p>         * The DateTime attached to this property is unchanged by this call.         * This operation is faster than converting a DateTime to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param value  the value to add to the field in the copy         * @return a copy of the DateTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to this field, possibly wrapped, in a copy of this DateTime.         * A wrapped operation only changes this field.         * Thus 31st January addWrapField one day goes to the 1st January.         * <p>         * The DateTime attached to this property is unchanged by this call.         * This operation is faster than converting a DateTime to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param value  the value to add to the field in the copy         * @return a copy of the DateTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the DateTime.         * <p>         * The DateTime attached to this property is unchanged by this call.         * This operation is faster than converting a DateTime to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param value  the value to set the field in the copy to         * @return a copy of the DateTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the DateTime to a parsed text value.         * <p>         * The DateTime attached to this property is unchanged by this call.         * This operation is faster than converting a DateTime to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param text  the text value to set         * @param locale  optional locale to use for selecting a text symbol         * @return a copy of the DateTime with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Sets this field in a copy of the DateTime to a parsed text value.         * <p>         * The DateTime attached to this property is unchanged by this call.         * This operation is faster than converting a DateTime to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param text  the text value to set         * @return a copy of the DateTime with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new DateTime with this field set to the maximum value         * for this field.         * <p>         * This operation is useful for obtaining a DateTime on the last day         * of the month, as month lengths vary.         * <pre>         * DateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();         * </pre>         * <p>         * Where possible, the offset from UTC will be retained, thus applications         * may need to call {@link DateTime#withLaterOffsetAtOverlap()} on the result         * to force the later time during a DST overlap if desired.         * <p>         * From v2.2, this method handles a daylight svaings time gap, setting the         * time to the last instant before the gap.         * <p>         * The DateTime attached to this property is unchanged by this call.         *         * @return a copy of the DateTime with this field set to its maximum         * @since 1.2         */
/**         * Returns a new DateTime with this field set to the minimum value         * for this field.         * <p>         * Where possible, the offset from UTC will be retained, thus applications         * may need to call {@link DateTime#withEarlierOffsetAtOverlap()} on the result         * to force the earlier time during a DST overlap if desired.         * <p>         * From v2.2, this method handles a daylight svaings time gap, setting the         * time to the first instant after the gap.         * <p>         * The DateTime attached to this property is unchanged by this call.         *         * @return a copy of the DateTime with this field set to its minimum         * @since 1.2         */
/**         * Rounds to the lowest whole unit of this field on a copy of this DateTime.         *         * @return a copy of the DateTime with the field value changed         */
/**         * Rounds to the highest whole unit of this field on a copy of this DateTime.         *         * @return a copy of the DateTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this DateTime,         * favoring the floor if halfway.         *         * @return a copy of the DateTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this DateTime,         * favoring the ceiling if halfway.         *         * @return a copy of the DateTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * DateTime.  If halfway, the ceiling is favored over the floor only if         * it makes this field's value even.         *         * @return a copy of the DateTime with the field value changed         */
/**     * Obtains a {@code DateTime} set to the current system millisecond time     * using the specified chronology.     *     * @param chronology  the chronology, not null     * @return the current date-time, not null     * @since 2.0     */
/**     * Parses a {@code DateTime} from the specified string using a formatter.     *      * @param str  the string to parse, not null     * @param formatter  the formatter to use, not null     * @since 2.0     */
/**     * Get this object as a DateTime, returning <code>this</code> if possible.     *      * @param chronology chronology to apply, or ISOChronology if null     * @return a DateTime using the same millis     */
/**     * Get this object as a DateTime using ISOChronology in the default zone,     * returning <code>this</code> if possible.     *      * @return a DateTime using the same millis     */
/**     * Returns a copy of this datetime with different millis.     * <p>     * The returned object will be either be a new instance or <code>this</code>.     * Only the millis will change, the chronology and time zone are kept.     *     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z     * @return a copy of this datetime with different millis     */
/**     * Returns a copy of this datetime with a different chronology.     * <p>     * The returned object will be either be a new instance or <code>this</code>.     * Only the chronology will change, the millis are kept.     *     * @param newChronology  the new chronology, null means ISO default     * @return a copy of this datetime with a different chronology     */
/**     * Returns a copy of this datetime with a different time zone, preserving the     * millisecond instant.     * <p>     * This method is useful for finding the local time in another timezone.     * For example, if this instant holds 12:30 in Europe/London, the result     * from this method with Europe/Paris would be 13:30.     * <p>     * The returned object will be a new instance of the same implementation type.     * This method changes the time zone, and does not change the     * millisecond instant, with the effect that the field values usually change.     * The returned object will be either be a new instance or <code>this</code>.     *     * @param newZone  the new time zone     * @return a copy of this datetime with a different time zone     * @see #withZoneRetainFields     */
/**     * Returns a copy of this datetime with a different time zone, preserving the     * field values.     * <p>     * This method is useful for finding the millisecond time in another timezone.     * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),     * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).     * <p>     * The returned object will be a new instance of the same implementation type.     * This method changes the time zone and the millisecond instant to keep     * the field values the same.     * The returned object will be either be a new instance or <code>this</code>.     *     * @param newZone  the new time zone, null means default     * @return a copy of this datetime with a different time zone     * @see #withZone     */
/**     * Returns a copy of this ZonedDateTime changing the zone offset to the earlier     * of the two valid offsets at a local time-line overlap.     * <p>     * This method only has any effect when the local time-line overlaps, such as at     * an autumn daylight savings cutover. In this scenario, there are two valid offsets     * for the local date-time. Calling this method will return a date-time with the     * earlier of the two selected.     * <p>     * If this method is called when it is not an overlap, this is returned.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @return a copy of this datetime with the earliest valid offset for the local datetime     */
/**     * Returns a copy of this ZonedDateTime changing the zone offset to the later     * of the two valid offsets at a local time-line overlap.     * <p>     * This method only has any effect when the local time-line overlaps, such as at     * an autumn daylight savings cutover. In this scenario, there are two valid offsets     * for the local date-time. Calling this method will return a date-time with the     * later of the two selected.     * <p>     * If this method is called when it is not an overlap, this is returned.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @return a copy of this datetime with the latest valid offset for the local datetime     */
/**     * Returns a copy of this datetime with the specified date, retaining the time fields.     * <p>     * If the date is already the date passed in, then <code>this</code> is returned.     * <p>     * To set a single field use the properties, for example:     * <pre>     * DateTime set = monthOfYear().setCopy(6);     * </pre>     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param year  the new year value     * @param monthOfYear  the new monthOfYear value     * @param dayOfMonth  the new dayOfMonth value     * @return a copy of this datetime with a different date     * @throws IllegalArgumentException if any value if invalid     */
/**     * Returns a copy of this datetime with the specified time, retaining the date fields.     * <p>     * If the time is already the time passed in, then <code>this</code> is returned.     * <p>     * To set a single field use the properties, for example:     * <pre>     * DateTime set = dt.hourOfDay().setCopy(6);     * </pre>     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param hourOfDay  the hour of the day     * @param minuteOfHour  the minute of the hour     * @param secondOfMinute  the second of the minute     * @param millisOfSecond  the millisecond of the second     * @return a copy of this datetime with a different time     * @throws IllegalArgumentException if any value if invalid     */
/**     * Returns a copy of this datetime with the time set to the start of the day.     * <p>     * The time will normally be midnight, as that is the earliest time on     * any given day. However, in some time zones when Daylight Savings Time     * starts, there is no midnight because time jumps from 11:59 to 01:00.     * This method handles that situation by returning 01:00 on that date.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @return a copy of this datetime with the time set to the start of the day, not null     */
/**     * Returns a copy of this datetime with the partial set of fields replacing those     * from this instance.     * <p>     * For example, if the partial is a <code>TimeOfDay</code> then the time fields     * would be changed in the returned instance.     * If the partial is null, then <code>this</code> is returned.     *     * @param partial  the partial set of fields to apply to this datetime, null ignored     * @return a copy of this datetime with a different set of fields     * @throws IllegalArgumentException if any value is invalid     */
/**     * Returns a copy of this datetime with the specified field set to a new value.     * <p>     * For example, if the field type is <code>hourOfDay</code> then the hour of day     * field would be changed in the returned instance.     * If the field type is null, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);     * DateTime updated = dt.dayOfMonth().setCopy(6);     * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this datetime with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this datetime with the value of the specified field increased.     * <p>     * If the addition is zero or the field is null, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);     * DateTime added = dt.plusYears(6);     * DateTime added = dt.plus(Period.years(6));     * </pre>     *      * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this datetime with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime with the specified duration added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     *      * @param durationToAdd  the duration to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this datetime with the duration added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusYears(int)}.     *      * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this datetime with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime with the specified period added.     * <p>     * This method will add each element of the period one by one, from largest     * to smallest, adjusting the datetime to be accurate between each.     * <p>     * Thus, adding a period of one month and one day to 2007-03-31 will     * work as follows:     * First add one month and adjust, resulting in 2007-04-30     * Then add one day and adjust, resulting in 2007-05-01.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusYears(int)}.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * This datetime instance is immutable and unaffected by this method call.     *      * @param period  the duration to add to this one, null means zero     * @return a copy of this datetime with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime plus the specified number of years.     * <p>     * The calculation will do its best to only change the year field     * retaining the same month of year.     * However, in certain circumstances, it may be necessary to alter     * smaller fields. For example, 2008-02-29 plus one year cannot result     * in 2009-02-29, so the day of month is adjusted to 2009-02-28.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusYears(6);     * DateTime added = dt.plus(Period.years(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to add, may be negative     * @return the new datetime plus the increased years     * @since 1.1     */
/**     * Returns a copy of this datetime plus the specified number of months.     * <p>     * The calculation will do its best to only change the month field     * retaining the same day of month.     * However, in certain circumstances, it may be necessary to alter     * smaller fields. For example, 2007-03-31 plus one month cannot result     * in 2007-04-31, so the day of month is adjusted to 2007-04-30.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusMonths(6);     * DateTime added = dt.plus(Period.months(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to add, may be negative     * @return the new datetime plus the increased months     * @since 1.1     */
/**     * Returns a copy of this datetime plus the specified number of weeks.     * <p>     * The calculation operates as if it were adding the equivalent in days.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusWeeks(6);     * DateTime added = dt.plus(Period.weeks(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to add, may be negative     * @return the new datetime plus the increased weeks     * @since 1.1     */
/**     * Returns a copy of this datetime plus the specified number of days.     * <p>     * The calculation will do its best to only change the day field     * retaining the same time of day.     * However, in certain circumstances, typically daylight savings cutover,     * it may be necessary to alter the time fields.     * <p>     * In spring an hour is typically removed. If adding one day results in     * the time being within the cutover then the time is adjusted to be     * within summer time. For example, if the cutover is from 01:59 to 03:00     * and the result of this method would have been 02:30, then the result     * will be adjusted to 03:30.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusDays(6);     * DateTime added = dt.plus(Period.days(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to add, may be negative     * @return the new datetime plus the increased days     * @since 1.1     */
/**     * Returns a copy of this datetime plus the specified number of hours.     * <p>     * The calculation will add a duration equivalent to the number of hours     * expressed in milliseconds.     * <p>     * For example, if a spring daylight savings cutover is from 01:59 to 03:00     * then adding one hour to 01:30 will result in 03:30. This is a duration     * of one hour later, even though the hour field value changed from 1 to 3.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusHours(6);     * DateTime added = dt.plus(Period.hours(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to add, may be negative     * @return the new datetime plus the increased hours     * @since 1.1     */
/**     * Returns a copy of this datetime plus the specified number of minutes.     * <p>     * The calculation will add a duration equivalent to the number of minutes     * expressed in milliseconds.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusMinutes(6);     * DateTime added = dt.plus(Period.minutes(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to add, may be negative     * @return the new datetime plus the increased minutes     * @since 1.1     */
/**     * Returns a copy of this datetime plus the specified number of seconds.     * <p>     * The calculation will add a duration equivalent to the number of seconds     * expressed in milliseconds.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusSeconds(6);     * DateTime added = dt.plus(Period.seconds(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to add, may be negative     * @return the new datetime plus the increased seconds     * @since 1.1     */
/**     * Returns a copy of this datetime plus the specified number of millis.     * <p>     * The calculation will add a duration equivalent to the number of milliseconds.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime added = dt.plusMillis(6);     * DateTime added = dt.plus(Period.millis(6));     * DateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param millis  the amount of millis to add, may be negative     * @return the new datetime plus the increased millis     * @since 1.1     */
/**     * Returns a copy of this datetime with the specified period taken away.     * <p>     * This method will subtract each element of the period one by one, from     * largest to smallest, adjusting the datetime to be accurate between each.     * <p>     * Thus, subtracting a period of one month and one day from 2007-05-31 will     * work as follows:     * First subtract one month and adjust, resulting in 2007-04-30     * Then subtract one day and adjust, resulting in 2007-04-29.     * Note that the day has been adjusted by two.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusYears(int)}.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * This datetime instance is immutable and unaffected by this method call.     *      * @param period  the period to reduce this instant by     * @return a copy of this datetime with the period taken away     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this datetime minus the specified number of years.     * <p>     * The calculation will do its best to only change the year field     * retaining the same month of year.     * However, in certain circumstances, it may be necessary to alter     * smaller fields. For example, 2008-02-29 minus one year cannot result     * in 2007-02-29, so the day of month is adjusted to 2007-02-28.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusYears(6);     * DateTime subtracted = dt.minus(Period.years(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to subtract, may be negative     * @return the new datetime minus the increased years     * @since 1.1     */
/**     * Returns a copy of this datetime minus the specified number of months.     * <p>     * The calculation will do its best to only change the month field     * retaining the same day of month.     * However, in certain circumstances, it may be necessary to alter     * smaller fields. For example, 2007-05-31 minus one month cannot result     * in 2007-04-31, so the day of month is adjusted to 2007-04-30.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusMonths(6);     * DateTime subtracted = dt.minus(Period.months(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to subtract, may be negative     * @return the new datetime minus the increased months     * @since 1.1     */
/**     * Returns a copy of this datetime minus the specified number of weeks.     * <p>     * The calculation operates as if it were subtracting the equivalent in days.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusWeeks(6);     * DateTime subtracted = dt.minus(Period.weeks(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to subtract, may be negative     * @return the new datetime minus the increased weeks     * @since 1.1     */
/**     * Returns a copy of this datetime minus the specified number of days.     * <p>     * The calculation will do its best to only change the day field     * retaining the same time of day.     * However, in certain circumstances, typically daylight savings cutover,     * it may be necessary to alter the time fields.     * <p>     * In spring an hour is typically removed. If subtracting one day results     * in the time being within the cutover then the time is adjusted to be     * within summer time. For example, if the cutover is from 01:59 to 03:00     * and the result of this method would have been 02:30, then the result     * will be adjusted to 03:30.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusDays(6);     * DateTime subtracted = dt.minus(Period.days(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to subtract, may be negative     * @return the new datetime minus the increased days     * @since 1.1     */
/**     * Returns a copy of this datetime minus the specified number of hours.     * <p>     * The calculation will subtract a duration equivalent to the number of     * hours expressed in milliseconds.     * <p>     * For example, if a spring daylight savings cutover is from 01:59 to 03:00     * then subtracting one hour from 03:30 will result in 01:30. This is a     * duration of one hour earlier, even though the hour field value changed     * from 3 to 1.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusHours(6);     * DateTime subtracted = dt.minus(Period.hours(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to subtract, may be negative     * @return the new datetime minus the increased hours     * @since 1.1     */
/**     * Returns a copy of this datetime minus the specified number of minutes.     * <p>     * The calculation will subtract a duration equivalent to the number of     * minutes expressed in milliseconds.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusMinutes(6);     * DateTime subtracted = dt.minus(Period.minutes(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to subtract, may be negative     * @return the new datetime minus the increased minutes     * @since 1.1     */
/**     * Returns a copy of this datetime minus the specified number of seconds.     * <p>     * The calculation will subtract a duration equivalent to the number of     * seconds expressed in milliseconds.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusSeconds(6);     * DateTime subtracted = dt.minus(Period.seconds(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to subtract, may be negative     * @return the new datetime minus the increased seconds     * @since 1.1     */
/**     * Returns a copy of this datetime minus the specified number of millis.     * <p>     * The calculation will subtract a duration equivalent to the number of     * milliseconds.     * <p>     * The following three lines are identical in effect:     * <pre>     * DateTime subtracted = dt.minusMillis(6);     * DateTime subtracted = dt.minus(Period.millis(6));     * DateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);     * </pre>     * <p>     * This datetime instance is immutable and unaffected by this method call.     *     * @param millis  the amount of millis to subtract, may be negative     * @return the new datetime minus the increased millis     * @since 1.1     */
/**     * Converts this object to a <code>LocalDateTime</code> with     * the same datetime and chronology.     *     * @return a LocalDateTime with the same datetime and chronology     * @since 1.3     */
/**     * Converts this object to a <code>LocalTime</code> with the     * same time and chronology.     *     * @return a LocalTime with the same time and chronology     * @since 1.3     */
/**     * Returns a copy of this datetime with the era field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * era changed.     *     * @param era  the era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the century of era field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * century of era changed.     *     * @param centuryOfEra  the centurey of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the year of era field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of era changed.     *     * @param yearOfEra  the year of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the year of century field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of century changed.     *     * @param yearOfCentury  the year of century to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the year field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year changed.     *     * @param year  the year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the weekyear field updated.     * <p>     * The weekyear is the year that matches with the weekOfWeekyear field.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * The weekyear allows you to query the effective year for that day.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * weekyear changed.     *     * @param weekyear  the weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the month of year field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * month of year changed.     *     * @param monthOfYear  the month of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the week of weekyear field updated.     * <p>     * This field is associated with the "weekyear" via {@link #withWeekyear(int)}.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * week of weekyear changed.     *     * @param weekOfWeekyear  the week of weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the day of year field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of year changed.     *     * @param dayOfYear  the day of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the day of month field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of month changed.     *     * @param dayOfMonth  the day of month to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the day of week field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of week changed.     *     * @param dayOfWeek  the day of week to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the hour of day field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * hour of day changed.     *     * @param hour  the hour of day to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the minute of hour updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * minute of hour changed.     *     * @param minute  the minute of hour to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the second of minute field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * second of minute changed.     *     * @param second  the second of minute to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the millis of second field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * millis of second changed.     *     * @param millis  the millis of second to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this datetime with the millis of day field updated.     * <p>     * DateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * millis of day changed.     *     * @param millis  the millis of day to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Get the hour of day field property which provides access to advanced functionality.     *      * @return the hour of day property     */
/**     * Get the minute of day property which provides access to advanced functionality.     *      * @return the minute of day property     */
/**     * Get the minute of hour field property which provides access to advanced functionality.     *      * @return the minute of hour property     */
/**     * Get the second of day property which provides access to advanced functionality.     *      * @return the second of day property     */
/**     * Get the second of minute field property which provides access to advanced functionality.     *      * @return the second of minute property     */
/**     * Get the millis of day property which provides access to advanced functionality.     *      * @return the millis of day property     */
/**     * Get the millis of second property which provides access to advanced functionality.     *      * @return the millis of second property     */
/**         * Reads the property from a safe serialization format.         */
/**         * Gets the datetime being used.         *          * @return the datetime         */
/**         * Adds to this field in a copy of this DateTime.         * <p>         * The DateTime attached to this property is unchanged by this call.         * This operation is faster than converting a DateTime to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param value  the value to add to the field in the copy         * @return a copy of the DateTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to this field, possibly wrapped, in a copy of this DateTime.         * A wrapped operation only changes this field.         * Thus 31st January addWrapField one day goes to the 1st January.         * <p>         * The DateTime attached to this property is unchanged by this call.         * This operation is faster than converting a DateTime to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param value  the value to add to the field in the copy         * @return a copy of the DateTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the DateTime to a parsed text value.         * <p>         * The DateTime attached to this property is unchanged by this call.         * This operation is faster than converting a DateTime to a MutableDateTime         * and back again when setting one field. When setting multiple fields,         * it is generally quicker to make the conversion to MutableDateTime.         *          * @param text  the text value to set         * @return a copy of the DateTime with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new DateTime with this field set to the maximum value         * for this field.         * <p>         * This operation is useful for obtaining a DateTime on the last day         * of the month, as month lengths vary.         * <pre>         * DateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();         * </pre>         * <p>         * Where possible, the offset from UTC will be retained, thus applications         * may need to call {@link DateTime#withLaterOffsetAtOverlap()} on the result         * to force the later time during a DST overlap if desired.         * <p>         * From v2.2, this method handles a daylight svaings time gap, setting the         * time to the last instant before the gap.         * <p>         * The DateTime attached to this property is unchanged by this call.         *         * @return a copy of the DateTime with this field set to its maximum         * @since 1.2         */
/**         * Returns a new DateTime with this field set to the minimum value         * for this field.         * <p>         * Where possible, the offset from UTC will be retained, thus applications         * may need to call {@link DateTime#withEarlierOffsetAtOverlap()} on the result         * to force the earlier time during a DST overlap if desired.         * <p>         * From v2.2, this method handles a daylight svaings time gap, setting the         * time to the first instant after the gap.         * <p>         * The DateTime attached to this property is unchanged by this call.         *         * @return a copy of the DateTime with this field set to its minimum         * @since 1.2         */
/**         * Rounds to the lowest whole unit of this field on a copy of this DateTime.         *         * @return a copy of the DateTime with the field value changed         */
/**         * Rounds to the highest whole unit of this field on a copy of this DateTime.         *         * @return a copy of the DateTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this DateTime,         * favoring the floor if halfway.         *         * @return a copy of the DateTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this DateTime,         * favoring the ceiling if halfway.         *         * @return a copy of the DateTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * DateTime.  If halfway, the ceiling is favored over the floor only if         * it makes this field's value even.         *         * @return a copy of the DateTime with the field value changed         */
/**     * Returns a DateTimeComparator with a lower and upper limit. Fields of a     * magnitude less than the lower limit are excluded from comparisons.     * Fields of a magnitude greater than or equal to the upper limit are also     * excluded from comparisons. Either limit may be specified as null, which     * indicates an unbounded limit.     *     * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit     * @param upperLimit  exclusive upper limit for fields to be compared, null means no limit     * @return a comparator over all fields between the limits     */
/**     * Returns a comparator that only considers date fields.     * Time of day is ignored.     *      * @return a comparator over all date fields     */
/**     * Returns a comparator that only considers time fields.     * Date is ignored.     *      * @return a comparator over all time fields     */
/**     * Gets the field type that represents the lower limit of comparison.     *      * @return the field type, null if no upper limit     */
/**     * Gets the field type that represents the upper limit of comparison.     *      * @return the field type, null if no upper limit     */
/**     * Compare two objects against only the range of date time fields as     * specified in the constructor.     *      * @param lhsObj  the first object,     *      logically on the left of a &lt; comparison, null means now     * @param rhsObj  the second object,     *      logically on the right of a &lt; comparison, null means now     * @return zero if order does not matter,     *      negative value if lhsObj &lt; rhsObj, positive value otherwise.     * @throws IllegalArgumentException if either argument is not supported     */
/**     * Support serialization singletons.     *      * @return the resolved singleton instance     */
/**     * Compares this comparator to another.     *      * @param object  the object to compare to     * @return true if equal     */
/**     * Gets a suitable hashcode.     *      * @return the hashcode     */
/**     * Gets a debugging string.     *      * @return a debugging string     */
/**     * Get the millis of second field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the millis of day field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the second of minute field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the second of day field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the minute of hour field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the minute of day field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the hour of day (0-23) field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the hour of day (offset to 1-24) field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the hour of am/pm (0-11) field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the hour of am/pm (offset to 1-12) field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the AM(0) PM(1) field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the day of week field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the day of month field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the day of year field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the week of a week based year field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the year of a week based year field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the year of a week based year within a century field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the month of year field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the year field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the year of era field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the year of century field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the century of era field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the era field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the name of the field.     * <p>     * By convention, names follow a pattern of "dddOfRrr", where "ddd" represents     * the (singular) duration unit field name and "Rrr" represents the (singular)     * duration range field name. If the range field is not applicable, then     * the name of the field is simply the (singular) duration field name.     *      * @return field name     */
/** @inheritdoc */
/** @inheritdoc */
/** @inheritdoc */
/**     * Checks whether this field supported in the given Chronology.     *     * @param chronology  the chronology to use, null means ISOChronology in default zone     * @return true if supported     */
/**     * Get a suitable debug string.     *      * @return debug string     */
/**         * Ensure a singleton is returned.         *          * @return the singleton type         */
/**     * Gets the current time in milliseconds.     * <p>     * By default this returns <code>System.currentTimeMillis()</code>.     * This may be changed using other methods in this class.     *      * @return the current time in milliseconds from 1970-01-01T00:00:00Z     */
/**     * Resets the current time to return the system time.     * <p>     * This method changes the behaviour of {@link #currentTimeMillis()}.     * Whenever the current time is queried, {@link System#currentTimeMillis()} is used.     *      * @throws SecurityException if the application does not have sufficient security rights     */
/**     * Sets the current time to return a fixed millisecond time.     * <p>     * This method changes the behaviour of {@link #currentTimeMillis()}.     * Whenever the current time is queried, the same millisecond time will be returned.     *      * @param fixedMillis  the fixed millisecond time to use     * @throws SecurityException if the application does not have sufficient security rights     */
/**     * Sets the current time to return the system time plus an offset.     * <p>     * This method changes the behaviour of {@link #currentTimeMillis()}.     * Whenever the current time is queried, {@link System#currentTimeMillis()} is used     * and then offset by adding the millisecond value specified here.     *      * @param offsetMillis  the fixed millisecond time to use     * @throws SecurityException if the application does not have sufficient security rights     */
/**     * Sets the provider of the current time to class specified.     * <p>     * This method changes the behaviour of {@link #currentTimeMillis()}.     * Whenever the current time is queried, the specified class will be called.     *      * @param millisProvider  the provider of the current time to use, not null     * @throws SecurityException if the application does not have sufficient security rights     * @since 2.0     */
/**     * Checks whether the provider may be changed using permission 'CurrentTime.setProvider'.     *      * @throws SecurityException if the provider may not be changed     */
/**     * Gets the millisecond instant from the specified instant object handling null.     * <p>     * If the instant object is <code>null</code>, the {@link #currentTimeMillis()}     * will be returned. Otherwise, the millis from the object are returned.     *      * @param instant  the instant to examine, null means now     * @return the time in milliseconds from 1970-01-01T00:00:00Z     */
/**     * Gets the chronology from the specified instant object handling null.     * <p>     * If the instant object is <code>null</code>, or the instant's chronology is     * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.     * Otherwise, the chronology from the object is returned.     *      * @param instant  the instant to examine, null means ISO in the default zone     * @return the chronology, never null     */
/**     * Gets the chronology from the specified interval object handling null.     * <p>     * If the interval object is <code>null</code>, or the interval's chronology is     * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.     * Otherwise, the chronology from the object is returned.     *      * @param interval  the interval to examine, null means ISO in the default zone     * @return the chronology, never null     */
/**     * Gets the interval handling null.     * <p>     * If the interval is <code>null</code>, an interval representing now     * to now in the {@link ISOChronology#getInstance() ISOChronology}     * will be returned. Otherwise, the interval specified is returned.     *      * @param interval  the interval to use, null means now to now     * @return the interval, never null     * @since 1.1     */
/**     * Gets the chronology handling null.     * <p>     * If the chronology is <code>null</code>, {@link ISOChronology#getInstance()}     * will be returned. Otherwise, the chronology is returned.     *      * @param chrono  the chronology to use, null means ISO in the default zone     * @return the chronology, never null     */
/**     * Gets the zone handling null.     * <p>     * If the zone is <code>null</code>, {@link DateTimeZone#getDefault()}     * will be returned. Otherwise, the zone specified is returned.     *      * @param zone  the time zone to use, null means the default zone     * @return the time zone, never null     */
/**     * Gets the period type handling null.     * <p>     * If the zone is <code>null</code>, {@link PeriodType#standard()}     * will be returned. Otherwise, the type specified is returned.     *      * @param type  the time zone to use, null means the standard type     * @return the type to use, never null     */
/**     * Gets the millisecond duration from the specified duration object handling null.     * <p>     * If the duration object is <code>null</code>, zero will be returned.     * Otherwise, the millis from the object are returned.     *      * @param duration  the duration to examine, null means zero     * @return the duration in milliseconds     */
/**     * Checks whether the partial is contiguous.     * <p>     * A partial is contiguous if one field starts where another ends.     * <p>     * For example <code>LocalDate</code> is contiguous because DayOfMonth has     * the same range (Month) as the unit of the next field (MonthOfYear), and     * MonthOfYear has the same range (Year) as the unit of the next field (Year).     * <p>     * Similarly, <code>LocalTime</code> is contiguous, as it consists of     * MillisOfSecond, SecondOfMinute, MinuteOfHour and HourOfDay (note how     * the names of each field 'join up').     * <p>     * However, a Year/HourOfDay partial is not contiguous because the range     * field Day is not equal to the next field Year.     * Similarly, a DayOfWeek/DayOfMonth partial is not contiguous because     * the range Month is not equal to the next field Day.     *      * @param partial  the partial to check     * @return true if the partial is contiguous     * @throws IllegalArgumentException if the partial is null     * @since 1.1     */
/**     * Gets the {@link DateFormatSymbols} based on the given locale.     * <p>     * If JDK 6 or newer is being used, DateFormatSymbols.getInstance(locale) will     * be used in order to allow the use of locales defined as extensions.     * Otherwise, new DateFormatSymbols(locale) will be used.     * See JDK 6 {@link DateFormatSymbols} for further information.     *      * @param locale  the {@link Locale} used to get the correct {@link DateFormatSymbols}     * @return the symbols     * @since 2.0     */
/**     * Gets the default map of time zone names.     * <p>     * This can be changed by {@link #setDefaultTimeZoneNames}.     * <p>     * The default set of short time zone names is as follows:     * <ul>     * <li>UT - UTC     * <li>UTC - UTC     * <li>GMT - UTC     * <li>EST - America/New_York     * <li>EDT - America/New_York     * <li>CST - America/Chicago     * <li>CDT - America/Chicago     * <li>MST - America/Denver     * <li>MDT - America/Denver     * <li>PST - America/Los_Angeles     * <li>PDT - America/Los_Angeles     * </ul>     *      * @return the unmodifiable map of abbreviations to zones, not null     * @since 2.2     */
/**     * Sets the default map of time zone names.     * <p>     * The map is copied before storage.     *      * @param names  the map of abbreviations to zones, not null     * @since 2.2     */
/**     * Calculates the astronomical Julian Day for an instant.     * <p>     * The <a href="http://en.wikipedia.org/wiki/Julian_day">Julian day</a> is a well-known     * system of time measurement for scientific use by the astronomy community.     * It expresses the interval of time in days and fractions of a day since     * January 1, 4713 BC (Julian) Greenwich noon.     * <p>     * Each day starts at midday (not midnight) and time is expressed as a fraction.     * Thus the fraction 0.25 is 18:00. equal to one quarter of the day from midday to midday.     * <p>     * Note that this method has nothing to do with the day-of-year.     *      * @param epochMillis  the epoch millis from 1970-01-01Z     * @return the astronomical Julian Day represented by the specified instant     * @since 2.2     */
/**     * Calculates the astronomical Julian Day Number for an instant.     * <p>     * The {@link #toJulianDay(long)} method calculates the astronomical Julian Day     * with a fraction based on days starting at midday.     * This method calculates the variant where days start at midnight.     * JDN 0 is used for the date equivalent to Monday January 1, 4713 BC (Julian).     * Thus these days start 12 hours before those of the fractional Julian Day.     * <p>     * Note that this method has nothing to do with the day-of-year.     *      * @param epochMillis  the epoch millis from 1970-01-01Z     * @return the astronomical Julian Day represented by the specified instant     * @since 2.2     */
/**     * Creates a date-time from a Julian Day.     * <p>     * Returns the {@code DateTime} object equal to the specified Julian Day.     *      * @param julianDay  the Julian Day     * @return the epoch millis from 1970-01-01Z     * @since 2.2     */
/**         * Gets the current time.         * @return the current time in millis         */
/**     * Gets the default time zone.     * <p>     * The default time zone is derived from the system property {@code user.timezone}.     * If that is {@code null} or is not a valid identifier, then the value of the     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.     * <p>     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this     * method, then the change will not be picked up here.     *      * @return the default datetime zone object     */
/**     * Sets the default time zone.     * <p>     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.     *      * @param zone  the default datetime zone object, must not be null     * @throws IllegalArgumentException if the zone is null     * @throws SecurityException if the application has insufficient security rights     */
/**     * Gets a time zone instance for the specified offset to UTC in hours.     * This method assumes standard length hours.     * <p>     * This factory is a convenient way of constructing zones with a fixed offset.     *      * @param hoursOffset  the offset in hours from UTC, from -23 to +23     * @return the DateTimeZone object for the offset     * @throws IllegalArgumentException if the offset is too large or too small     */
/**     * Gets a time zone instance for the specified offset to UTC in hours and minutes.     * This method assumes 60 minutes in an hour, and standard length minutes.     * <p>     * This factory is a convenient way of constructing zones with a fixed offset.     * The hours value must be in the range -23 to +23.     * The minutes value must be in the range -59 to +59.     * The following combinations of sign for the hour and minute are possible:     * <pre>     *  Hour    Minute    Example    Result     *      *  +ve     +ve       (2, 15)    +02:15     *  +ve     zero      (2, 0)     +02:00     *  +ve     -ve       (2, -15)   IllegalArgumentException     *      *  zero    +ve       (0, 15)    +00:15     *  zero    zero      (0, 0)     +00:00     *  zero    -ve       (0, -15)   -00:15     *      *  -ve     +ve       (-2, 15)   -02:15     *  -ve     zero      (-2, 0)    -02:00     *  -ve     -ve       (-2, -15)  -02:15     * </pre>     * Note that in versions before 2.3, the minutes had to be zero or positive.     *      * @param hoursOffset  the offset in hours from UTC, from -23 to +23     * @param minutesOffset  the offset in minutes from UTC, from -59 to +59     * @return the DateTimeZone object for the offset     * @throws IllegalArgumentException if any value is out of range, the minutes are negative     *  when the hours are positive, or the resulting offset exceeds +/- 23:59:59.000     */
/**     * Gets a time zone instance for the specified offset to UTC in milliseconds.     *     * @param millisOffset  the offset in millis from UTC, from -23:59:59.999 to +23:59:59.999     * @return the DateTimeZone object for the offset     */
/**     * Gets a time zone instance for a JDK TimeZone.     * <p>     * DateTimeZone only accepts a subset of the IDs from TimeZone. The     * excluded IDs are the short three letter form (except UTC). This      * method will attempt to convert between time zones created using the     * short IDs and the full version.     * <p>     * This method is not designed to parse time zones with rules created by     * applications using <code>SimpleTimeZone</code> directly.     *      * @param zone  the zone to convert, null means default     * @return the DateTimeZone object for the zone     * @throws IllegalArgumentException if the zone is not recognised     */
/**     * Gets the zone using a fixed offset amount.     *      * @param id  the zone id     * @param offset  the offset in millis     * @return the zone     */
/**     * Gets all the available IDs supported.     *      * @return an unmodifiable Set of String IDs     */
/**     * Gets the zone provider factory.     * <p>     * The zone provider is a pluggable instance factory that supplies the     * actual instances of DateTimeZone.     *      * @return the provider     */
/**     * Sets the zone provider factory.     * <p>     * The zone provider is a pluggable instance factory that supplies the     * actual instances of DateTimeZone.     *      * @param provider  provider to use, or null for default     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider     * @throws IllegalArgumentException if the provider is invalid     */
/**     * Sets the zone provider factory without performing the security check.     *      * @param provider  provider to use, or null for default     * @throws IllegalArgumentException if the provider is invalid     */
/**     * Gets the default zone provider.     * <p>     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.     * Then uses <code>UTCProvider</code>.     *      * @return the default name provider     */
/**     * Gets the name provider factory.     * <p>     * The name provider is a pluggable instance factory that supplies the     * names of each DateTimeZone.     *      * @return the provider     */
/**     * Sets the name provider factory.     * <p>     * The name provider is a pluggable instance factory that supplies the     * names of each DateTimeZone.     *      * @param nameProvider  provider to use, or null for default     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider     * @throws IllegalArgumentException if the provider is invalid     */
/**     * Sets the name provider factory without performing the security check.     *      * @param nameProvider  provider to use, or null for default     * @throws IllegalArgumentException if the provider is invalid     */
/**     * Gets the default name provider.     * <p>     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.     * Then uses <code>DefaultNameProvider</code>.     *      * @return the default name provider     */
/**     * Converts an old style id to a new style id.     *      * @param id  the old style id     * @return the new style id, null if not found     */
/**     * Formats a timezone offset string.     * <p>     * This method is kept separate from the formatting classes to speed and     * simplify startup and classloading.     *      * @param offset  the offset in milliseconds     * @return the time zone string     */
/**     * Gets a printer/parser for managing the offset id formatting.     *      * @return the formatter     */
/**     * Gets the short name of this datetime zone suitable for display using     * the specified locale.     * <p>     * If the name is not available for the locale, then this method returns a     * string in the format <code>[+-]hh:mm</code>.     *      * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for     * @param locale  the locale to get the name for     * @return the human-readable short name in the specified locale     */
/**     * Gets the long name of this datetime zone suitable for display using     * the specified locale.     * <p>     * If the name is not available for the locale, then this method returns a     * string in the format <code>[+-]hh:mm</code>.     *      * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for     * @param locale  the locale to get the name for     * @return the human-readable long name in the specified locale     */
/**     * Gets the millisecond offset to add to UTC to get local time.     *      * @param instant  instant to get the offset for, null means now     * @return the millisecond offset to add to UTC to get local time     */
/**     * Checks whether, at a particular instant, the offset is standard or not.     * <p>     * This method can be used to determine whether Summer Time (DST) applies.     * As a general rule, if the offset at the specified instant is standard,     * then either Winter time applies, or there is no Summer Time. If the     * instant is not standard, then Summer Time applies.     * <p>     * The implementation of the method is simply whether {@link #getOffset(long)}     * equals {@link #getStandardOffset(long)} at the specified instant.     *      * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for     * @return true if the offset at the given instant is the standard offset     * @since 1.5     */
/**     * Gets the millisecond offset to subtract from local time to get UTC time.     * This offset can be used to undo adding the offset obtained by getOffset.     *     * <pre>     * millisLocal == millisUTC   + getOffset(millisUTC)     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)     * </pre>     *     * NOTE: After calculating millisLocal, some error may be introduced. At     * offset transitions (due to DST or other historical changes), ranges of     * local times may map to different UTC times.     * <p>     * This method will return an offset suitable for calculating an instant     * after any DST gap. For example, consider a zone with a cutover     * from 01:00 to 01:59:<br />     * Input: 00:00  Output: 00:00<br />     * Input: 00:30  Output: 00:30<br />     * Input: 01:00  Output: 02:00<br />     * Input: 01:30  Output: 02:30<br />     * Input: 02:00  Output: 02:00<br />     * Input: 02:30  Output: 02:30<br />     * <p>     * During a DST overlap (where the local time is ambiguous) this method will return     * the earlier instant. The combination of these two rules is to always favour     * daylight (summer) time over standard (winter) time.     * <p>     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.     * Prior to v1.5, the DST gap behaviour was also not defined.     *     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for     * @return the millisecond offset to subtract from local time to get UTC time     */
/**     * Converts a standard UTC instant to a local instant with the same     * local time. This conversion is used before performing a calculation     * so that the calculation can be done using a simple local zone.     *     * @param instantUTC  the UTC instant to convert to local     * @return the local instant with the same local time     * @throws ArithmeticException if the result overflows a long     * @since 1.5     */
/**     * Converts a local instant to a standard UTC instant with the same     * local time. This conversion is used after performing a calculation     * where the calculation was done using a simple local zone.     *     * @param instantLocal  the local instant to convert to UTC     * @param strict  whether the conversion should reject non-existent local times     * @return the UTC instant with the same local time,      * @throws ArithmeticException if the result overflows a long     * @throws IllegalInstantException if the zone has no equivalent local time     * @since 1.5     */
/**     * Gets the millisecond instant in another zone keeping the same local time.     * <p>     * The conversion is performed by converting the specified UTC millis to local     * millis in this zone, then converting back to UTC millis in the new zone.     *     * @param newZone  the new zone, null means default     * @param oldInstant  the UTC millisecond instant to convert     * @return the UTC millisecond instant with the same local time in the new zone     */
/**     * Checks if the given {@link LocalDateTime} is within a gap.     * <p>     * When switching from standard time to Daylight Savings Time there is     * typically a gap where a clock hour is missing. This method identifies     * whether the local datetime refers to such a gap.     *      * @param localDateTime  the time to check, not null     * @return true if the given datetime refers to a gap     * @since 1.6     */
/**     * Adjusts the offset to be the earlier or later one during an overlap.     *      * @param instant  the instant to adjust     * @param earlierOrLater  false for earlier, true for later     * @return the adjusted instant millis     */
/**     * Get the datetime zone as a {@link java.util.TimeZone}.     *      * @return the closest matching TimeZone object     */
/**     * Gets a hash code compatable with equals.     *      * @return suitable hashcode     */
/**     * By default, when DateTimeZones are serialized, only a "stub" object     * referring to the id is written out. When the stub is read in, it     * replaces itself with a DateTimeZone object.     * @return a stub object to go in the stream     */
/**     * Returns a new instance with the specified number of days added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to add, may be negative     * @return the new period plus the specified number of days     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of days added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to add, may be negative, null means zero     * @return the new period plus the specified number of days     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of days taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to take away, may be negative     * @return the new period minus the specified number of days     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of days taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to take away, may be negative, null means zero     * @return the new period minus the specified number of days     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the days multiplied by the specified scalar.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param scalar  the amount to multiply by, may be negative     * @return the new period multiplied by the specified scalar     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the days divided by the specified divisor.     * The calculation uses integer division, thus 3 divided by 2 is 1.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param divisor  the amount to divide by, may be negative     * @return the new period divided by the specified divisor     * @throws ArithmeticException if the divisor is zero     */
/**     * Returns a new instance with the days value negated.     *     * @return the new period with a negated value     * @throws ArithmeticException if the result overflows an int     */
/**     * Obtains an instance of <code>Days</code> that may be cached.     * <code>Days</code> is immutable, so instances can be cached and shared.     * This factory method provides access to shared instances.     *     * @param days  the number of days to obtain an instance for     * @return the instance of Days     */
/**     * Creates a <code>Days</code> representing the number of whole days     * between the two specified partial datetimes.     * <p>     * The two partials must contain the same fields, for example you can specify     * two <code>LocalDate</code> objects.     *     * @param start  the start partial date, must not be null     * @param end  the end partial date, must not be null     * @return the period in days     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Creates a <code>Days</code> representing the number of whole days     * in the specified interval. This method corectly handles any daylight     * savings time changes that may occur during the interval.     *     * @param interval  the interval to extract days from, null returns zero     * @return the period in days     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Creates a new <code>Days</code> representing the number of complete     * standard length days in the specified period.     * <p>     * This factory method converts all fields from the period to hours using standardised     * durations for each field. Only those fields which have a precise duration in     * the ISO UTC chronology can be converted.     * <ul>     * <li>One week consists of 7 days.     * <li>One day consists of 24 hours.     * <li>One hour consists of 60 minutes.     * <li>One minute consists of 60 seconds.     * <li>One second consists of 1000 milliseconds.     * </ul>     * Months and Years are imprecise and periods containing these values cannot be converted.     *     * @param period  the period to get the number of hours from, null returns zero     * @return the period in days     * @throws IllegalArgumentException if the period contains imprecise duration values     */
/**     * Resolves singletons.     *      * @return the singleton instance     */
/**     * Gets the duration field type, which is <code>days</code>.     *     * @return the period type     */
/**     * Gets the period type, which is <code>days</code>.     *     * @return the period type     */
/**     * Converts this period in days to a period in weeks assuming a     * 7 day week.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all weeks are     * 7 days long.     * This may not be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of weeks for this number of days     */
/**     * Converts this period in days to a period in hours assuming a     * 24 hour day.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all days are 24 hours long.     * This is not true when daylight savings is considered and may also not     * be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of hours for this number of days     * @throws ArithmeticException if the number of hours is too large to be represented     */
/**     * Converts this period in days to a period in minutes assuming a     * 24 hour day and 60 minute hour.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all days are 24 hours     * long and all hours are 60 minutes long.     * This is not true when daylight savings is considered and may also not     * be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of minutes for this number of days     * @throws ArithmeticException if the number of minutes is too large to be represented     */
/**     * Converts this period in days to a period in seconds assuming a     * 24 hour day, 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all days are 24 hours     * long, all hours are 60 minutes long and all minutes are 60 seconds long.     * This is not true when daylight savings is considered and may also not     * be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of seconds for this number of days     * @throws ArithmeticException if the number of seconds is too large to be represented     */
/**     * Converts this period in days to a duration in milliseconds assuming a     * 24 hour day, 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert from a period to a duration.     * However to achieve this it makes the assumption that all days are 24 hours     * long, all hours are 60 minutes and all minutes are 60 seconds.     * This is not true when daylight savings time is considered, and may also     * not be true for some unusual chronologies. However, it is included as it     * is a useful operation for many applications and business rules.     *      * @return a duration equivalent to this number of days     */
/**     * Gets the number of days that this period represents.     *     * @return the number of days in the period     */
/**     * Returns a new instance with the specified number of days added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to add, may be negative, null means zero     * @return the new period plus the specified number of days     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of days taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to take away, may be negative, null means zero     * @return the new period minus the specified number of days     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the days multiplied by the specified scalar.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param scalar  the amount to multiply by, may be negative     * @return the new period multiplied by the specified scalar     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the days divided by the specified divisor.     * The calculation uses integer division, thus 3 divided by 2 is 1.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param divisor  the amount to divide by, may be negative     * @return the new period divided by the specified divisor     * @throws ArithmeticException if the divisor is zero     */
/**     * Returns a new instance with the days value negated.     *     * @return the new period with a negated value     * @throws ArithmeticException if the result overflows an int     */
/**     * Is this days instance greater than the specified number of days.     *     * @param other  the other period, null means zero     * @return true if this days instance is greater than the specified one     */
/**     * Is this days instance less than the specified number of days.     *     * @param other  the other period, null means zero     * @return true if this days instance is less than the specified one     */
/**     * Creates a duration from the given millisecond duration.     *     * @param duration  the duration, in milliseconds     */
/**     * Creates a duration from the given interval endpoints.     *     * @param startInstant  interval start, in milliseconds     * @param endInstant  interval end, in milliseconds     * @throws ArithmeticException if the duration exceeds a 64 bit long     */
/**     * Creates a duration from the given interval endpoints.     *     * @param start  interval start, null means now     * @param end  interval end, null means now     * @throws ArithmeticException if the duration exceeds a 64 bit long     */
/**     * Creates a duration from the specified object using the     * {@link org.joda.time.convert.ConverterManager ConverterManager}.     *     * @param duration  duration to convert     * @throws IllegalArgumentException if duration is invalid     */
/**     * Get this duration as an immutable <code>Duration</code> object     * by returning <code>this</code>.     *      * @return <code>this</code>     */
/**     * Creates a new Duration instance with a different milisecond length.     *      * @param duration  the new length of the duration     * @return the new duration instance     */
/**     * Returns a new duration with this length plus that specified multiplied by the scalar.     * This instance is immutable and is not altered.     * <p>     * If the addition is zero, this instance is returned.     *      * @param durationToAdd  the duration to add to this one     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return the new duration instance     */
/**     * Returns a new duration with this length plus that specified multiplied by the scalar.     * This instance is immutable and is not altered.     * <p>     * If the addition is zero, this instance is returned.     *      * @param durationToAdd  the duration to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return the new duration instance     */
/**     * Returns a new duration with this length plus that specified.     * This instance is immutable and is not altered.     * <p>     * If the addition is zero, this instance is returned.     *      * @param amount  the duration to add to this one     * @return the new duration instance     */
/**     * Returns a new duration with this length plus that specified.     * This instance is immutable and is not altered.     * <p>     * If the amount is zero, this instance is returned.     *      * @param amount  the duration to add to this one, null means zero     * @return the new duration instance     */
/**     * Returns a new duration with this length minus that specified.     * This instance is immutable and is not altered.     * <p>     * If the addition is zero, this instance is returned.     *      * @param amount  the duration to take away from this one     * @return the new duration instance     */
/**     * Returns a new duration with this length minus that specified.     * This instance is immutable and is not altered.     * <p>     * If the amount is zero, this instance is returned.     *      * @param amount  the duration to take away from this one, null means zero     * @return the new duration instance     */
/**     * Create a duration with the specified number of days assuming that     * there are the standard number of milliseconds in a day.     * <p>     * This method assumes that there are 24 hours in a day,     * 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in     * a second. This will be true for most days, however days with Daylight     * Savings changes will not have 24 hours, so use this method with care.     * <p>     * A Duration is a representation of an amount of time. If you want to express     * the concepts of 'days' you should consider using the {@link Days} class.     *     * @param days  the number of standard days in this duration     * @return the duration, never null     * @throws ArithmeticException if the days value is too large     * @since 1.6     */
/**     * Create a duration with the specified number of hours assuming that     * there are the standard number of milliseconds in an hour.     * <p>     * This method assumes that there are 60 minutes in an hour,     * 60 seconds in a minute and 1000 milliseconds in a second.     * All currently supplied chronologies use this definition.     * <p>     * A Duration is a representation of an amount of time. If you want to express     * the concepts of 'hours' you should consider using the {@link Hours} class.     *     * @param hours  the number of standard hours in this duration     * @return the duration, never null     * @throws ArithmeticException if the hours value is too large     * @since 1.6     */
/**     * Create a duration with the specified number of minutes assuming that     * there are the standard number of milliseconds in a minute.     * <p>     * This method assumes that there are 60 seconds in a minute and     * 1000 milliseconds in a second.     * All currently supplied chronologies use this definition.     * <p>     * A Duration is a representation of an amount of time. If you want to express     * the concepts of 'minutes' you should consider using the {@link Minutes} class.     *     * @param minutes  the number of standard minutes in this duration     * @return the duration, never null     * @throws ArithmeticException if the minutes value is too large     * @since 1.6     */
/**     * Create a duration with the specified number of seconds assuming that     * there are the standard number of milliseconds in a second.     * <p>     * This method assumes that there are 1000 milliseconds in a second.     * All currently supplied chronologies use this definition.     * <p>     * A Duration is a representation of an amount of time. If you want to express     * the concepts of 'seconds' you should consider using the {@link Seconds} class.     *     * @param seconds  the number of standard seconds in this duration     * @return the duration, never null     * @throws ArithmeticException if the seconds value is too large     * @since 1.6     */
/**     * Create a duration with the specified number of milliseconds.     *     * @param millis  the number of standard milliseconds in this duration     * @return the duration, never null     * @since 2.0     */
/**     * Gets the length of this duration in days assuming that there are the     * standard number of milliseconds in a day.     * <p>     * This method assumes that there are 24 hours in a day,     * 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in     * a second. This will be true for most days, however days with Daylight     * Savings changes will not have 24 hours, so use this method with care.     * <p>     * This returns <code>getMillis() / MILLIS_PER_DAY</code>.     * The result is an integer division, thus excess milliseconds are truncated.     *     * @return the length of the duration in standard seconds     * @since 2.0     */
/**     * Gets the length of this duration in hours assuming that there are the     * standard number of milliseconds in an hour.     * <p>     * This method assumes that there are 60 minutes in an hour,     * 60 seconds in a minute and 1000 milliseconds in a second.     * All currently supplied chronologies use this definition.     * <p>     * This returns <code>getMillis() / MILLIS_PER_HOUR</code>.     * The result is an integer division, thus excess milliseconds are truncated.     *     * @return the length of the duration in standard seconds     * @since 2.0     */
/**     * Gets the length of this duration in minutes assuming that there are the     * standard number of milliseconds in a minute.     * <p>     * This method assumes that there are 60 seconds in a minute and     * 1000 milliseconds in a second.     * All currently supplied chronologies use this definition.     * <p>     * This returns <code>getMillis() / 60000</code>.     * The result is an integer division, thus excess milliseconds are truncated.     *     * @return the length of the duration in standard seconds     * @since 2.0     */
/**     * Gets the length of this duration in seconds assuming that there are the     * standard number of milliseconds in a second.     * <p>     * This method assumes that there are 1000 milliseconds in a second.     * All currently supplied chronologies use this definition.     * <p>     * This returns <code>getMillis() / 1000</code>.     * The result is an integer division, so 2999 millis returns 2 seconds.     *     * @return the length of the duration in standard seconds     * @since 1.6     */
/**     * Get this duration as an immutable <code>Duration</code> object     * by returning <code>this</code>.     *      * @return <code>this</code>     */
/**     * Converts this duration to a period in days assuming that there are the     * standard number of milliseconds in a day.     * <p>     * This method assumes that there are 24 hours in a day,     * 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in     * a second. This will be true for most days, however days with Daylight     * Savings changes will not have 24 hours, so use this method with care.     *      * @return a period representing the number of standard days in this period, never null     * @throws ArithmeticException if the number of days is too large to be represented     * @since 2.0     */
/**     * Converts this duration to a period in hours assuming that there are the     * standard number of milliseconds in an hour.     * <p>     * This method assumes that there are 60 minutes in an hour,     * 60 seconds in a minute and 1000 milliseconds in a second.     * All currently supplied chronologies use this definition.     *      * @return a period representing the number of standard hours in this period, never null     * @throws ArithmeticException if the number of hours is too large to be represented     * @since 2.0     */
/**     * Converts this duration to a period in minutes assuming that there are the     * standard number of milliseconds in a minute.     * <p>     * This method assumes that there are 60 seconds in a minute and     * 1000 milliseconds in a second.     * All currently supplied chronologies use this definition.     *      * @return a period representing the number of standard minutes in this period, never null     * @throws ArithmeticException if the number of minutes is too large to be represented     * @since 2.0     */
/**     * Converts this duration to a period in seconds assuming that there are the     * standard number of milliseconds in a second.     * <p>     * This method assumes that there are 1000 milliseconds in a second.     * All currently supplied chronologies use this definition.     *      * @return a period representing the number of standard seconds in this period, never null     * @throws ArithmeticException if the number of seconds is too large to be represented     * @since 1.6     */
/**     * Creates a new Duration instance with a different milisecond length.     *      * @param duration  the new length of the duration     * @return the new duration instance     */
/**     * Returns a new duration with this length plus that specified multiplied by the scalar.     * This instance is immutable and is not altered.     * <p>     * If the addition is zero, this instance is returned.     *      * @param durationToAdd  the duration to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return the new duration instance     */
/**     * Returns a new duration with this length plus that specified.     * This instance is immutable and is not altered.     * <p>     * If the amount is zero, this instance is returned.     *      * @param amount  the duration to add to this one, null means zero     * @return the new duration instance     */
/**     * Returns a new duration with this length minus that specified.     * This instance is immutable and is not altered.     * <p>     * If the amount is zero, this instance is returned.     *      * @param amount  the duration to take away from this one, null means zero     * @return the new duration instance     */
/**     * Subtracts a duration value (which may be negative) from the instant.     *      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to subtract from     * @param value  the value to subtract, in the units of the field     * @return the updated milliseconds     * @since 1.1     */
/**     * Get the millis field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the seconds field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the minutes field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the hours field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the halfdays field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the days field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the weeks field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the weekyears field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the months field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the years field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the centuries field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the eras field type.     *      * @return the DateTimeFieldType constant     */
/**     * Get the name of the field.     * By convention, names are plural.     *      * @return field name     */
/**         * Ensure a singleton is returned.         *          * @return the singleton type         */
/**     * Returns a new instance with the specified number of hours added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to add, may be negative     * @return the new period plus the specified number of hours     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of hours added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to add, may be negative, null means zero     * @return the new period plus the specified number of hours     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of hours taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to take away, may be negative     * @return the new period minus the specified number of hours     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of hours taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to take away, may be negative, null means zero     * @return the new period minus the specified number of hours     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the hours multiplied by the specified scalar.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param scalar  the amount to multiply by, may be negative     * @return the new period multiplied by the specified scalar     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the hours divided by the specified divisor.     * The calculation uses integer division, thus 3 divided by 2 is 1.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param divisor  the amount to divide by, may be negative     * @return the new period divided by the specified divisor     * @throws ArithmeticException if the divisor is zero     */
/**     * Returns a new instance with the hours value negated.     *     * @return the new period with a negated value     * @throws ArithmeticException if the result overflows an int     */
/**     * Obtains an instance of <code>Hours</code> that may be cached.     * <code>Hours</code> is immutable, so instances can be cached and shared.     * This factory method provides access to shared instances.     *     * @param hours  the number of hours to obtain an instance for     * @return the instance of Hours     */
/**     * Creates a <code>Hours</code> representing the number of whole hours     * between the two specified partial datetimes.     * <p>     * The two partials must contain the same fields, for example you can specify     * two <code>LocalTime</code> objects.     *     * @param start  the start partial date, must not be null     * @param end  the end partial date, must not be null     * @return the period in hours     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Creates a <code>Hours</code> representing the number of whole hours     * in the specified interval.     *     * @param interval  the interval to extract hours from, null returns zero     * @return the period in hours     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Creates a new <code>Hours</code> representing the number of complete     * standard length hours in the specified period.     * <p>     * This factory method converts all fields from the period to hours using standardised     * durations for each field. Only those fields which have a precise duration in     * the ISO UTC chronology can be converted.     * <ul>     * <li>One week consists of 7 days.     * <li>One day consists of 24 hours.     * <li>One hour consists of 60 minutes.     * <li>One minute consists of 60 seconds.     * <li>One second consists of 1000 milliseconds.     * </ul>     * Months and Years are imprecise and periods containing these values cannot be converted.     *     * @param period  the period to get the number of hours from, null returns zero     * @return the period in hours     * @throws IllegalArgumentException if the period contains imprecise duration values     */
/**     * Resolves singletons.     *      * @return the singleton instance     */
/**     * Gets the duration field type, which is <code>hours</code>.     *     * @return the period type     */
/**     * Gets the period type, which is <code>hours</code>.     *     * @return the period type     */
/**     * Converts this period in hours to a period in weeks assuming a     * 7 day week and 24 hour day.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all weeks are 7 days     * long and all days are 24 hours long.     * This is not true when daylight savings time is considered, and may also     * not be true for some unusual chronologies. However, it is included as it     * is a useful operation for many applications and business rules.     *      * @return a period representing the number of whole weeks for this number of hours     */
/**     * Converts this period in hours to a period in days assuming a     * 24 hour day.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all days are 24 hours long.     * This is not true when daylight savings time is considered, and may also     * not be true for some unusual chronologies. However, it is included as it     * is a useful operation for many applications and business rules.     *      * @return a period representing the number of whole days for this number of hours     */
/**     * Converts this period in hours to a period in minutes assuming a     * 60 minute hour.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all hours are 60 minutes long.     * This may not be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of minutes for this number of hours     * @throws ArithmeticException if the number of minutes is too large to be represented     */
/**     * Converts this period in hours to a period in seconds assuming a     * 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all hours are     * 60 minutes long and all minutes are 60 seconds long.     * This may not be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of seconds for this number of hours     * @throws ArithmeticException if the number of seconds is too large to be represented     */
/**     * Converts this period in hours to a duration in milliseconds assuming a     * 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert from a period to a duration.     * However to achieve this it makes the assumption that all hours are     * 60 minutes and all minutes are 60 seconds. This might not be true for an     * unusual chronology, for example one that takes leap seconds into account.     * However, the method is included as it is a useful operation for many     * applications and business rules.     *     * @return a duration equivalent to this number of hours     */
/**     * Gets the number of hours that this period represents.     *     * @return the number of hours in the period     */
/**     * Returns a new instance with the specified number of hours added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to add, may be negative, null means zero     * @return the new period plus the specified number of hours     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of hours taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to take away, may be negative, null means zero     * @return the new period minus the specified number of hours     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the hours multiplied by the specified scalar.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param scalar  the amount to multiply by, may be negative     * @return the new period multiplied by the specified scalar     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the hours divided by the specified divisor.     * The calculation uses integer division, thus 3 divided by 2 is 1.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param divisor  the amount to divide by, may be negative     * @return the new period divided by the specified divisor     * @throws ArithmeticException if the divisor is zero     */
/**     * Returns a new instance with the hours value negated.     *     * @return the new period with a negated value     * @throws ArithmeticException if the result overflows an int     */
/**     * Is this hours instance greater than the specified number of hours.     *     * @param other  the other period, null means zero     * @return true if this hours instance is greater than the specified one     */
/**     * Is this hours instance less than the specified number of hours.     *     * @param other  the other period, null means zero     * @return true if this hours instance is less than the specified one     */
/**     * Constructor.     *      * @param fieldType  type of field being set     * @param value  illegal value being set     * @param lowerBound  lower legal field value, or null if not applicable     * @param upperBound  upper legal field value, or null if not applicable     */
/**     * Constructor.     *      * @param fieldType  type of field being set     * @param value  illegal value being set     * @param lowerBound  lower legal field value, or null if not applicable     * @param upperBound  upper legal field value, or null if not applicable     */
/**     * Constructor.     *      * @param fieldName  name of field being set     * @param value  illegal value being set     * @param lowerBound  lower legal field value, or null if not applicable     * @param upperBound  upper legal field value, or null if not applicable     */
/**     * Constructor.     *      * @param fieldType  type of field being set     * @param value  illegal value being set     */
/**     * Constructor.     *      * @param fieldType  type of field being set     * @param value  illegal value being set     */
/**     * Constructor.     *      * @param fieldName  name of field being set     * @param value  illegal value being set     */
/**     * Creates a message for the exception.     *     * @param fieldName  the field name     * @param value  the value rejected     * @return the message     */
/**     * Returns the DateTimeFieldType whose value was invalid, or null if not applicable.     *      * @return the datetime field type     */
/**     * Returns the DurationFieldType whose value was invalid, or null if not applicable.     *      * @return the duration field type     */
/**     * Returns the name of the field whose value was invalid.     *      * @return the field name     */
/**     * Returns the illegal integer value assigned to the field, or null if not applicable.     *      * @return the value     */
/**     * Returns the illegal string value assigned to the field, or null if not applicable.     *      * @return the value     */
/**     * Returns the illegal value assigned to the field as a non-null string.     *      * @return the value     */
/**     * Returns the lower bound of the legal value range, or null if not applicable.     *      * @return the lower bound     */
/**     * Returns the upper bound of the legal value range, or null if not applicable.     *      * @return the upper bound     */
/**     * Provide additional detail by prepending a message to the existing message.     * A colon is separator is automatically inserted between the messages.     * @since 1.3     */
/**     * Constructor.     *      * @param message  the message     */
/**     * Constructor.     *      * @param instantLocal  the local instant     * @param zoneId  the time-zone ID, may be null     */
/**     * Checks if the exception is, or has a cause, of {@code IllegalInstantException}.     *      * @param ex  the exception to check     * @return true if an {@code IllegalInstantException}     */
/**     * Constructs an instance set to the current system millisecond time.     *      * @see #now()     */
/**     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z.     *      * @param instant  the milliseconds from 1970-01-01T00:00:00Z     */
/**     * Constructs an instance from an Object that represents a datetime.     * <p>     * The recognised object types are defined in {@link ConverterManager} and     * include String, Calendar and Date.     *     * @param instant  the datetime object, null means now     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Get this object as an Instant by returning <code>this</code>.     *      * @return <code>this</code>     */
/**     * Gets a copy of this instant with different millis.     * <p>     * The returned object will be either be a new Instant or <code>this</code>.     *     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z     * @return a copy of this instant with different millis     */
/**     * Gets a copy of this instant with the specified duration added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     *      * @param durationToAdd  the duration to add to this one     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this instant with the duration added     * @throws ArithmeticException if the new instant exceeds the capacity of a long     */
/**     * Gets a copy of this instant with the specified duration added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     *      * @param durationToAdd  the duration to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this instant with the duration added     * @throws ArithmeticException if the new instant exceeds the capacity of a long     */
/**     * Gets a copy of this instant with the specified duration added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *      * @param duration  the duration to add to this one     * @return a copy of this instant with the duration added     * @throws ArithmeticException if the new instant exceeds the capacity of a long     */
/**     * Gets a copy of this instant with the specified duration added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *      * @param duration  the duration to add to this one, null means zero     * @return a copy of this instant with the duration added     * @throws ArithmeticException if the new instant exceeds the capacity of a long     */
/**     * Gets a copy of this instant with the specified duration taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *      * @param duration  the duration to reduce this instant by     * @return a copy of this instant with the duration taken away     * @throws ArithmeticException if the new instant exceeds the capacity of a long     */
/**     * Gets a copy of this instant with the specified duration taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *      * @param duration  the duration to reduce this instant by     * @return a copy of this instant with the duration taken away     * @throws ArithmeticException if the new instant exceeds the capacity of a long     */
/**     * Obtains an {@code Instant} set to the current system millisecond time.     *      * @return the current instant, not null     * @since 2.0     */
/**     * Parses a {@code Instant} from the specified string using a formatter.     *      * @param str  the string to parse, not null     * @param formatter  the formatter to use, not null     * @since 2.0     */
/**     * Get this object as an Instant by returning <code>this</code>.     *      * @return <code>this</code>     */
/**     * Gets a copy of this instant with different millis.     * <p>     * The returned object will be either be a new Instant or <code>this</code>.     *     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z     * @return a copy of this instant with different millis     */
/**     * Gets a copy of this instant with the specified duration added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     *      * @param durationToAdd  the duration to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this instant with the duration added     * @throws ArithmeticException if the new instant exceeds the capacity of a long     */
/**     * Gets a copy of this instant with the specified duration added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *      * @param duration  the duration to add to this one, null means zero     * @return a copy of this instant with the duration added     * @throws ArithmeticException if the new instant exceeds the capacity of a long     */
/**     * Gets a copy of this instant with the specified duration taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *      * @param duration  the duration to reduce this instant by     * @return a copy of this instant with the duration taken away     * @throws ArithmeticException if the new instant exceeds the capacity of a long     */
/**     * Gets the milliseconds of the instant.     *      * @return the number of milliseconds since 1970-01-01T00:00:00Z     */
/**     * Gets the chronology of the instant, which is ISO in the UTC zone.     * <p>     * This method returns {@link ISOChronology#getInstanceUTC()} which     * corresponds to the definition of the Java epoch 1970-01-01T00:00:00Z.     *      * @return ISO in the UTC zone     */
/**     * Get this object as a DateTime using ISOChronology in the default zone.     * <p>     * This method returns a DateTime object in the default zone.     * This differs from the similarly named method on DateTime, DateMidnight     * or MutableDateTime which retains the time zone. The difference is     * because Instant really represents a time <i>without</i> a zone,     * thus calling this method we really have no zone to 'retain' and     * hence expect to switch to the default zone.     * <p>     * This method definition preserves compatibility with earlier versions     * of Joda-Time.     *     * @return a DateTime using the same millis     */
/**     * Get this object as a MutableDateTime using ISOChronology in the default zone.     * <p>     * This method returns a MutableDateTime object in the default zone.     * This differs from the similarly named method on DateTime, DateMidnight     * or MutableDateTime which retains the time zone. The difference is     * because Instant really represents a time <i>without</i> a zone,     * thus calling this method we really have no zone to 'retain' and     * hence expect to switch to the default zone.     * <p>     * This method definition preserves compatibility with earlier versions     * of Joda-Time.     *     * @return a MutableDateTime using the same millis     */
/**     * Constructs an interval from a start and end instant with the ISO     * default chronology in the default time zone.     *      * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.     * @throws IllegalArgumentException if the end is before the start     */
/**     * Constructs an interval from a start and end instant with the ISO     * default chronology in the specified time zone.     *      * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.     * @param zone  the time zone to use, null means default zone     * @throws IllegalArgumentException if the end is before the start     * @since 1.5     */
/**     * Constructs an interval from a start and end instant with the     * specified chronology.     *      * @param chronology  the chronology to use, null is ISO default     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.     * @throws IllegalArgumentException if the end is before the start     */
/**     * Constructs an interval from a start and end instant.     * <p>     * The chronology used is that of the start instant.     *      * @param start  start of this interval, null means now     * @param end  end of this interval, null means now     * @throws IllegalArgumentException if the end is before the start     */
/**     * Constructs an interval from a start instant and a duration.     *      * @param start  start of this interval, null means now     * @param duration  the duration of this interval, null means zero length     * @throws IllegalArgumentException if the end is before the start     * @throws ArithmeticException if the end instant exceeds the capacity of a long     */
/**     * Constructs an interval from a millisecond duration and an end instant.     *      * @param duration  the duration of this interval, null means zero length     * @param end  end of this interval, null means now     * @throws IllegalArgumentException if the end is before the start     * @throws ArithmeticException if the start instant exceeds the capacity of a long     */
/**     * Constructs an interval from a start instant and a time period.     * <p>     * When forming the interval, the chronology from the instant is used     * if present, otherwise the chronology of the period is used.     *      * @param start  start of this interval, null means now     * @param period  the period of this interval, null means zero length     * @throws IllegalArgumentException if the end is before the start     * @throws ArithmeticException if the end instant exceeds the capacity of a long     */
/**     * Constructs an interval from a time period and an end instant.     * <p>     * When forming the interval, the chronology from the instant is used     * if present, otherwise the chronology of the period is used.     *      * @param period  the period of this interval, null means zero length     * @param end  end of this interval, null means now     * @throws IllegalArgumentException if the end is before the start     * @throws ArithmeticException if the start instant exceeds the capacity of a long     */
/**     * Constructs a time interval by converting or copying from another object.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInterval and String.     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',     * 'datetime/period' or 'period/datetime'.     *      * @param interval  the time interval to copy     * @throws IllegalArgumentException if the interval is invalid     */
/**     * Constructs a time interval by converting or copying from another object,     * overriding the chronology.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInterval and String.     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',     * 'datetime/period' or 'period/datetime'.     *      * @param interval  the time interval to copy     * @param chronology  the chronology to use, null means ISO default     * @throws IllegalArgumentException if the interval is invalid     */
/**     * Get this interval as an immutable <code>Interval</code> object     * by returning <code>this</code>.     *     * @return <code>this</code>     */
/**     * Gets the overlap between this interval and another interval.     * <p>     * Intervals are inclusive of the start instant and exclusive of the end.     * An interval overlaps another if it shares some common part of the     * datetime continuum. This method returns the amount of the overlap,     * only if the intervals actually do overlap.     * If the intervals do not overlap, then null is returned.     * <p>     * When two intervals are compared the result is one of three states:     * (a) they abut, (b) there is a gap between them, (c) they overlap.     * The abuts state takes precedence over the other two, thus a zero duration     * interval at the start of a larger interval abuts and does not overlap.     * <p>     * The chronology of the returned interval is the same as that of     * this interval (the chronology of the interval parameter is not used).     * Note that the use of the chronology was only correctly implemented     * in version 1.3.     *     * @param interval  the interval to examine, null means now     * @return the overlap interval, null if no overlap     * @since 1.1     */
/**     * Gets the gap between this interval and another interval.     * The other interval can be either before or after this interval.     * <p>     * Intervals are inclusive of the start instant and exclusive of the end.     * An interval has a gap to another interval if there is a non-zero     * duration between them. This method returns the amount of the gap only     * if the intervals do actually have a gap between them.     * If the intervals overlap or abut, then null is returned.     * <p>     * When two intervals are compared the result is one of three states:     * (a) they abut, (b) there is a gap between them, (c) they overlap.     * The abuts state takes precedence over the other two, thus a zero duration     * interval at the start of a larger interval abuts and does not overlap.     * <p>     * The chronology of the returned interval is the same as that of     * this interval (the chronology of the interval parameter is not used).     * Note that the use of the chronology was only correctly implemented     * in version 1.3.     *     * @param interval  the interval to examine, null means now     * @return the gap interval, null if no gap     * @since 1.1     */
/**     * Creates a new interval with the same start and end, but a different chronology.     *     * @param chronology  the chronology to use, null means ISO default     * @return an interval with a different chronology     */
/**     * Creates a new interval with the specified start millisecond instant.     *     * @param startInstant  the start instant for the new interval     * @return an interval with the end from this interval and the specified start     * @throws IllegalArgumentException if the resulting interval has end before start     */
/**     * Creates a new interval with the specified start instant.     *     * @param start  the start instant for the new interval, null means now     * @return an interval with the end from this interval and the specified start     * @throws IllegalArgumentException if the resulting interval has end before start     */
/**     * Creates a new interval with the specified start millisecond instant.     *     * @param endInstant  the end instant for the new interval     * @return an interval with the start from this interval and the specified end     * @throws IllegalArgumentException if the resulting interval has end before start     */
/**     * Creates a new interval with the specified end instant.     *     * @param end  the end instant for the new interval, null means now     * @return an interval with the start from this interval and the specified end     * @throws IllegalArgumentException if the resulting interval has end before start     */
/**     * Creates a new interval with the specified duration after the start instant.     *     * @param duration  the duration to add to the start to get the new end instant, null means zero     * @return an interval with the start from this interval and a calculated end     * @throws IllegalArgumentException if the duration is negative     */
/**     * Creates a new interval with the specified duration before the end instant.     *     * @param duration  the duration to add to the start to get the new end instant, null means zero     * @return an interval with the start from this interval and a calculated end     * @throws IllegalArgumentException if the duration is negative     */
/**     * Creates a new interval with the specified period after the start instant.     *     * @param period  the period to add to the start to get the new end instant, null means zero     * @return an interval with the start from this interval and a calculated end     * @throws IllegalArgumentException if the period is negative     */
/**     * Creates a new interval with the specified period before the end instant.     *     * @param period  the period to add to the start to get the new end instant, null means zero     * @return an interval with the start from this interval and a calculated end     * @throws IllegalArgumentException if the period is negative     */
/**     * Parses a {@code Interval} from the specified string.     * <p>     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',     * 'datetime/period' or 'period/datetime'.     *      * @param str  the string to parse, not null     * @since 2.0     */
/**     * Get this interval as an immutable <code>Interval</code> object     * by returning <code>this</code>.     *     * @return <code>this</code>     */
/**     * Gets the overlap between this interval and another interval.     * <p>     * Intervals are inclusive of the start instant and exclusive of the end.     * An interval overlaps another if it shares some common part of the     * datetime continuum. This method returns the amount of the overlap,     * only if the intervals actually do overlap.     * If the intervals do not overlap, then null is returned.     * <p>     * When two intervals are compared the result is one of three states:     * (a) they abut, (b) there is a gap between them, (c) they overlap.     * The abuts state takes precedence over the other two, thus a zero duration     * interval at the start of a larger interval abuts and does not overlap.     * <p>     * The chronology of the returned interval is the same as that of     * this interval (the chronology of the interval parameter is not used).     * Note that the use of the chronology was only correctly implemented     * in version 1.3.     *     * @param interval  the interval to examine, null means now     * @return the overlap interval, null if no overlap     * @since 1.1     */
/**     * Gets the gap between this interval and another interval.     * The other interval can be either before or after this interval.     * <p>     * Intervals are inclusive of the start instant and exclusive of the end.     * An interval has a gap to another interval if there is a non-zero     * duration between them. This method returns the amount of the gap only     * if the intervals do actually have a gap between them.     * If the intervals overlap or abut, then null is returned.     * <p>     * When two intervals are compared the result is one of three states:     * (a) they abut, (b) there is a gap between them, (c) they overlap.     * The abuts state takes precedence over the other two, thus a zero duration     * interval at the start of a larger interval abuts and does not overlap.     * <p>     * The chronology of the returned interval is the same as that of     * this interval (the chronology of the interval parameter is not used).     * Note that the use of the chronology was only correctly implemented     * in version 1.3.     *     * @param interval  the interval to examine, null means now     * @return the gap interval, null if no gap     * @since 1.1     */
/**     * Does this interval abut with the interval specified.     * <p>     * Intervals are inclusive of the start instant and exclusive of the end.     * An interval abuts if it starts immediately after, or ends immediately     * before this interval without overlap.     * A zero duration interval abuts with itself.     * <p>     * When two intervals are compared the result is one of three states:     * (a) they abut, (b) there is a gap between them, (c) they overlap.     * The abuts state takes precedence over the other two, thus a zero duration     * interval at the start of a larger interval abuts and does not overlap.     * <p>     * For example:     * <pre>     * [09:00 to 10:00) abuts [08:00 to 08:30)  = false (completely before)     * [09:00 to 10:00) abuts [08:00 to 09:00)  = true     * [09:00 to 10:00) abuts [08:00 to 09:01)  = false (overlaps)     *      * [09:00 to 10:00) abuts [09:00 to 09:00)  = true     * [09:00 to 10:00) abuts [09:00 to 09:01)  = false (overlaps)     *      * [09:00 to 10:00) abuts [10:00 to 10:00)  = true     * [09:00 to 10:00) abuts [10:00 to 10:30)  = true     *      * [09:00 to 10:00) abuts [10:30 to 11:00)  = false (completely after)     *      * [14:00 to 14:00) abuts [14:00 to 14:00)  = true     * [14:00 to 14:00) abuts [14:00 to 15:00)  = true     * [14:00 to 14:00) abuts [13:00 to 14:00)  = true     * </pre>     *     * @param interval  the interval to examine, null means now     * @return true if the interval abuts     * @since 1.1     */
/**     * Creates a new interval with the same start and end, but a different chronology.     *     * @param chronology  the chronology to use, null means ISO default     * @return an interval with a different chronology     */
/**     * Creates a new interval with the specified start millisecond instant.     *     * @param startInstant  the start instant for the new interval     * @return an interval with the end from this interval and the specified start     * @throws IllegalArgumentException if the resulting interval has end before start     */
/**     * Creates a new interval with the specified start instant.     *     * @param start  the start instant for the new interval, null means now     * @return an interval with the end from this interval and the specified start     * @throws IllegalArgumentException if the resulting interval has end before start     */
/**     * Creates a new interval with the specified start millisecond instant.     *     * @param endInstant  the end instant for the new interval     * @return an interval with the start from this interval and the specified end     * @throws IllegalArgumentException if the resulting interval has end before start     */
/**     * Creates a new interval with the specified end instant.     *     * @param end  the end instant for the new interval, null means now     * @return an interval with the start from this interval and the specified end     * @throws IllegalArgumentException if the resulting interval has end before start     */
/**     * Creates a new interval with the specified duration after the start instant.     *     * @param duration  the duration to add to the start to get the new end instant, null means zero     * @return an interval with the start from this interval and a calculated end     * @throws IllegalArgumentException if the duration is negative     */
/**     * Creates a new interval with the specified duration before the end instant.     *     * @param duration  the duration to add to the start to get the new end instant, null means zero     * @return an interval with the start from this interval and a calculated end     * @throws IllegalArgumentException if the duration is negative     */
/**     * Creates a new interval with the specified period after the start instant.     *     * @param period  the period to add to the start to get the new end instant, null means zero     * @return an interval with the start from this interval and a calculated end     * @throws IllegalArgumentException if the period is negative     */
/**     * Creates a new interval with the specified period before the end instant.     *     * @param period  the period to add to the start to get the new end instant, null means zero     * @return an interval with the start from this interval and a calculated end     * @throws IllegalArgumentException if the period is negative     */
/**     * Constructs a new permission object.     *      * @param name  the permission name     */
/**     * Constructs an instance set to the current local time evaluated using     * ISO chronology in the default zone.     * <p>     * Once the constructor is completed, the zone is no longer used.     *      * @see #now()     */
/**     * Constructs an instance set to the current local time evaluated using     * ISO chronology in the specified zone.     * <p>     * If the specified time zone is null, the default zone is used.     * Once the constructor is completed, the zone is no longer used.     *     * @param zone  the time zone, null means default zone     * @see #now(DateTimeZone)     */
/**     * Constructs an instance set to the current local time evaluated using     * specified chronology.     * <p>     * If the chronology is null, ISO chronology in the default time zone is used.     * Once the constructor is completed, the zone is no longer used.     *     * @param chronology  the chronology, null means ISOChronology in default zone     * @see #now(Chronology)     */
/**     * Constructs an instance set to the local time defined by the specified     * instant evaluated using ISO chronology in the default zone.     * <p>     * Once the constructor is completed, the zone is no longer used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     */
/**     * Constructs an instance set to the local time defined by the specified     * instant evaluated using ISO chronology in the specified zone.     * <p>     * If the specified time zone is null, the default zone is used.     * Once the constructor is completed, the zone is no longer used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param zone  the time zone, null means default zone     */
/**     * Constructs an instance set to the local time defined by the specified     * instant evaluated using the specified chronology.     * <p>     * If the chronology is null, ISO chronology in the default zone is used.     * Once the constructor is completed, the zone is no longer used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param chronology  the chronology, null means ISOChronology in default zone     */
/**     * Constructs an instance from an Object that represents a datetime.     * The time zone will be retrieved from the object if possible,     * otherwise the default time zone will be used.     * <p>     * If the object contains no chronology, <code>ISOChronology</code> is used.     * Once the constructor is completed, the zone is no longer used.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePartial, ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.     * The default String converter ignores the zone and only parses the field values.     *     * @param instant  the datetime object     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs an instance from an Object that represents a datetime,     * forcing the time zone to that specified.     * <p>     * If the object contains no chronology, <code>ISOChronology</code> is used.     * If the specified time zone is null, the default zone is used.     * Once the constructor is completed, the zone is no longer used.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePartial, ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.     * The default String converter ignores the zone and only parses the field values.     *     * @param instant  the datetime object     * @param zone  the time zone     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs an instance from an Object that represents a datetime,     * using the specified chronology.     * <p>     * If the chronology is null, ISO in the default time zone is used.     * Once the constructor is completed, the zone is no longer used.     * If the instant contains a chronology, it will be ignored.     * For example, passing a {@code LocalDate} and a different chronology     * will return a date with the year/month/day from the date applied     * unaltered to the specified chronology.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePartial, ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.     * The default String converter ignores the zone and only parses the field values.     *     * @param instant  the datetime object     * @param chronology  the chronology     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Converts this object to a LocalDateTime using a LocalTime to fill in     * the missing fields.     * <p>     * The resulting chronology is determined by the chronology of this     * LocalDate. The chronology of the time must also match.     * If the time is null an exception is thrown.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param time  the time of day to use, must not be null     * @return the LocalDateTime instance     * @throws IllegalArgumentException if the time is null     * @throws IllegalArgumentException if the chronology of the time does not match     * @since 1.5     */
/**     * Returns a copy of this date with the partial set of fields replacing     * those from this instance.     * <p>     * For example, if the partial contains a year and a month then those two     * fields will be changed in the returned instance.     * Unsupported fields are ignored.     * If the partial is null, then <code>this</code> is returned.     *     * @param partial  the partial set of fields to apply to this date, null ignored     * @return a copy of this date with a different set of fields     * @throws IllegalArgumentException if any value is invalid     */
/**     * Returns a copy of this date with the specified field set to a new value.     * <p>     * For example, if the field type is <code>monthOfYear</code> then the     * month of year field will be changed in the returned instance.     * If the field type is null, then <code>this</code> is returned.     * <p>     * These two lines are equivalent:     * <pre>     * LocalDate updated = dt.withDayOfMonth(6);     * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this date with the field set     * @throws IllegalArgumentException if the field is null or unsupported     */
/**     * Returns a copy of this date with the value of the specified field increased.     * <p>     * If the addition is zero or the field is null, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);     * LocalDate added = dt.plusYears(6);     * LocalDate added = dt.plus(Period.years(6));     * </pre>     *     * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this date with the field updated     * @throws IllegalArgumentException if the field is null or unsupported     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this date with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusYears(int)}.     * <p>     * Unsupported time fields are ignored, thus adding a period of 24 hours     * will not have any effect.     *     * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this date with the period added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this date with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusYears(int)}.     * <p>     * Unsupported time fields are ignored, thus adding a period of 24 hours     * will not have any effect.     *     * @param period  the period to add to this one, null means zero     * @return a copy of this date with the period added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this date plus the specified number of years.     * <p>     * This adds the specified number of years to the date.     * If adding years makes the day-of-month invalid, it is adjusted to the last valid day in the month.     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate added = dt.plusYears(6);     * LocalDate added = dt.plus(Period.years(6));     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);     * </pre>     *     * @param years  the amount of years to add, may be negative     * @return the new LocalDate plus the increased years     */
/**     * Returns a copy of this date plus the specified number of months.     * <p>     * This adds the specified number of months to the date.     * The addition may change the year, but the day-of-month is normally unchanged.     * If adding months makes the day-of-month invalid, it is adjusted to the last valid day in the month.     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate added = dt.plusMonths(6);     * LocalDate added = dt.plus(Period.months(6));     * LocalDate added = dt.withFieldAdded(DurationFieldType.months(), 6);     * </pre>     *     * @param months  the amount of months to add, may be negative     * @return the new LocalDate plus the increased months     */
/**     * Returns a copy of this date plus the specified number of weeks.     * <p>     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate added = dt.plusWeeks(6);     * LocalDate added = dt.plus(Period.weeks(6));     * LocalDate added = dt.withFieldAdded(DurationFieldType.weeks(), 6);     * </pre>     *     * @param weeks  the amount of weeks to add, may be negative     * @return the new LocalDate plus the increased weeks     */
/**     * Returns a copy of this date plus the specified number of days.     * <p>     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate added = dt.plusDays(6);     * LocalDate added = dt.plus(Period.days(6));     * LocalDate added = dt.withFieldAdded(DurationFieldType.days(), 6);     * </pre>     *     * @param days  the amount of days to add, may be negative     * @return the new LocalDate plus the increased days     */
/**     * Returns a copy of this date with the specified period taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusYears(int)}.     * <p>     * Unsupported time fields are ignored, thus subtracting a period of 24 hours     * will not have any effect.     *     * @param period  the period to reduce this instant by     * @return a copy of this LocalDate with the period taken away     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this date minus the specified number of years.     * <p>     * This subtracts the specified number of years from the date.     * If subtracting years makes the day-of-month invalid, it is adjusted to the last valid day in the month.     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate subtracted = dt.minusYears(6);     * LocalDate subtracted = dt.minus(Period.years(6));     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);     * </pre>     *     * @param years  the amount of years to subtract, may be negative     * @return the new LocalDate minus the increased years     */
/**     * Returns a copy of this date minus the specified number of months.     * <p>     * This subtracts the specified number of months from the date.     * The subtraction may change the year, but the day-of-month is normally unchanged.     * If subtracting months makes the day-of-month invalid, it is adjusted to the last valid day in the month.     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate subtracted = dt.minusMonths(6);     * LocalDate subtracted = dt.minus(Period.months(6));     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);     * </pre>     *     * @param months  the amount of months to subtract, may be negative     * @return the new LocalDate minus the increased months     */
/**     * Returns a copy of this date minus the specified number of weeks.     * <p>     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate subtracted = dt.minusWeeks(6);     * LocalDate subtracted = dt.minus(Period.weeks(6));     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);     * </pre>     *     * @param weeks  the amount of weeks to subtract, may be negative     * @return the new LocalDate minus the increased weeks     */
/**     * Returns a copy of this date minus the specified number of days.     * <p>     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate subtracted = dt.minusDays(6);     * LocalDate subtracted = dt.minus(Period.days(6));     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);     * </pre>     *     * @param days  the amount of days to subtract, may be negative     * @return the new LocalDate minus the increased days     */
/**     * Returns a copy of this date with the era field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * era changed.     *     * @param era  the era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the century of era field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * century of era changed.     *     * @param centuryOfEra  the centurey of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the year of era field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of era changed.     *     * @param yearOfEra  the year of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the year of century field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of century changed.     *     * @param yearOfCentury  the year of century to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the year field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year changed.     *     * @param year  the year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the weekyear field updated.     * <p>     * The weekyear is the year that matches with the weekOfWeekyear field.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * The weekyear allows you to query the effective year for that day.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * weekyear changed.     *     * @param weekyear  the weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the month of year field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * month of year changed.     *     * @param monthOfYear  the month of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the week of weekyear field updated.     * <p>     * This field is associated with the "weekyear" via {@link #withWeekyear(int)}.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * week of weekyear changed.     *     * @param weekOfWeekyear  the week of weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the day of year field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of year changed.     *     * @param dayOfYear  the day of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the day of month field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of month changed.     *     * @param dayOfMonth  the day of month to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the day of week field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of week changed.     *     * @param dayOfWeek  the day of week to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**         * Gets the LocalDate object linked to this property.         *          * @return the linked LocalDate         */
/**         * Adds to this field in a copy of this LocalDate.         * <p>         * The LocalDate attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalDate with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to this field, possibly wrapped, in a copy of this LocalDate.         * A field wrapped operation only changes this field.         * Thus 31st January addWrapField one day goes to the 1st January.         * <p>         * The LocalDate attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalDate with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the LocalDate.         * <p>         * The LocalDate attached to this property is unchanged by this call.         *         * @param value  the value to set the field in the copy to         * @return a copy of the LocalDate with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the LocalDate to a parsed text value.         * <p>         * The LocalDate attached to this property is unchanged by this call.         *         * @param text  the text value to set         * @param locale  optional locale to use for selecting a text symbol         * @return a copy of the LocalDate with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Sets this field in a copy of the LocalDate to a parsed text value.         * <p>         * The LocalDate attached to this property is unchanged by this call.         *         * @param text  the text value to set         * @return a copy of the LocalDate with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new LocalDate with this field set to the maximum value         * for this field.         * <p>         * This operation is useful for obtaining a LocalDate on the last day         * of the month, as month lengths vary.         * <pre>         * LocalDate lastDayOfMonth = dt.dayOfMonth().withMaximumValue();         * </pre>         * <p>         * The LocalDate attached to this property is unchanged by this call.         *         * @return a copy of the LocalDate with this field set to its maximum         */
/**         * Returns a new LocalDate with this field set to the minimum value         * for this field.         * <p>         * The LocalDate attached to this property is unchanged by this call.         *         * @return a copy of the LocalDate with this field set to its minimum         */
/**         * Rounds to the lowest whole unit of this field on a copy of this         * LocalDate.         * <p>         * For example, rounding floor on the hourOfDay field of a LocalDate         * where the time is 10:30 would result in new LocalDate with the         * time of 10:00.         *         * @return a copy of the LocalDate with the field value changed         */
/**         * Rounds to the highest whole unit of this field on a copy of this         * LocalDate.         * <p>         * For example, rounding floor on the hourOfDay field of a LocalDate         * where the time is 10:30 would result in new LocalDate with the         * time of 11:00.         *         * @return a copy of the LocalDate with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalDate, favoring the floor if halfway.         *         * @return a copy of the LocalDate with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalDate, favoring the ceiling if halfway.         *         * @return a copy of the LocalDate with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalDate.  If halfway, the ceiling is favored over the floor         * only if it makes this field's value even.         *         * @return a copy of the LocalDate with the field value changed         */
/**     * Obtains a {@code LocalDate} set to the current system millisecond time     * using the specified chronology.     *     * @param chronology  the chronology, not null     * @return the current date-time, not null     * @since 2.0     */
/**     * Parses a {@code LocalDate} from the specified string using a formatter.     *      * @param str  the string to parse, not null     * @param formatter  the formatter to use, not null     * @since 2.0     */
/**     * Constructs a LocalDate from a <code>java.util.Calendar</code>     * using exactly the same field values.     * <p>     * Each field is queried from the Calendar and assigned to the LocalDate.     * This is useful if you have been using the Calendar as a local date,     * ignoring the zone.     * <p>     * One advantage of this method is that this method is unaffected if the     * version of the time zone data differs between the JDK and Joda-Time.     * That is because the local field values are transferred, calculated using     * the JDK time zone data and without using the Joda-Time time zone data.     * <p>     * This factory method ignores the type of the calendar and always     * creates a LocalDate with ISO chronology. It is expected that you     * will only pass in instances of <code>GregorianCalendar</code> however     * this is not validated.     *     * @param calendar  the Calendar to extract fields from, not null     * @return the created local date, not null     * @throws IllegalArgumentException if the calendar is null     * @throws IllegalArgumentException if the date is invalid for the ISO chronology     */
/**     * Handle broken serialization from other tools.     * @return the resolved object, not null     */
/**     * Gets the number of fields in this partial, which is three.     * The supported fields are Year, MonthOfYear and DayOfMonth.     * Note that all fields from day and above may in fact be queried via     * other methods.     *     * @return the field count, three     */
/**     * Gets the value of the field at the specifed index.     * <p>     * This method is required to support the <code>ReadablePartial</code>     * interface. The supported fields are Year, MonthOfYear and DayOfMonth.     * Note that all fields from day and above may in fact be queried via     * other methods.     *     * @param index  the index, zero to two     * @return the value     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Get the value of one of the fields of a datetime.     * <p>     * This method gets the value of the specified field.     * For example:     * <pre>     * LocalDate dt = LocalDate.nowDefaultZone();     * int year = dt.get(DateTimeFieldType.year());     * </pre>     *     * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null     * @return the value of that field     * @throws IllegalArgumentException if the field type is null or unsupported     */
/**     * Checks if the duration type specified is supported by this     * local date and chronology.     *     * @param type  a duration type, usually obtained from DurationFieldType     * @return true if the field type is supported     */
/**     * Gets the local milliseconds from the Java epoch     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).     *      * @return the number of milliseconds since 1970-01-01T00:00:00     * @since 1.5 (previously private)     */
/**     * Compares this ReadablePartial with another returning true if the chronology,     * field types and values are equal.     *     * @param partial  an object to check against     * @return true if fields and values are equal     */
/**     * Gets a hash code for the instant as defined in <code>ReadablePartial</code>.     *     * @return a suitable hash code     */
/**     * Compares this partial with another returning an integer     * indicating the order.     * <p>     * The fields are compared in order, from largest to smallest.     * The first field that is non-equal is used to determine the result.     * <p>     * The specified object must be a partial instance whose field types     * match those of this partial.     *     * @param partial  an object to check against     * @return negative if this is less, zero if equal, positive if greater     * @throws ClassCastException if the partial is the wrong class     *  or if it has field types that don't match     * @throws NullPointerException if the partial is null     */
/**     * Converts this LocalDate to a full datetime at the earliest valid time     * for the date using the specified time zone.     * <p>     * The time will normally be midnight, as that is the earliest time on     * any given day. However, in some time zones when Daylight Savings Time     * starts, there is no midnight because time jumps from 11:59 to 01:00.     * This method handles that situation by returning 01:00 on that date.     * <p>     * This method uses the chronology from this instance plus the time zone     * specified.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param zone  the zone to use, null means default zone     * @return this date as a datetime at the start of the day     * @since 1.5     */
/**     * Converts this LocalDate to a full datetime using the specified time zone     * setting the date fields from this instance and the time fields from     * the current time.     * <p>     * This method uses the chronology from this instance plus the time zone     * specified.     * <p>     * This method will throw an exception if the datetime that would be     * created does not exist when the time zone is taken into account.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param zone  the zone to use, null means default zone     * @return this date as a datetime with the time as the current time     */
/**     * Converts this object to a LocalDateTime using a LocalTime to fill in     * the missing fields.     * <p>     * The resulting chronology is determined by the chronology of this     * LocalDate. The chronology of the time must also match.     * If the time is null an exception is thrown.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param time  the time of day to use, must not be null     * @return the LocalDateTime instance     * @throws IllegalArgumentException if the time is null     * @throws IllegalArgumentException if the chronology of the time does not match     * @since 1.5     */
/**     * Converts this object to a DateTime using a LocalTime to fill in the     * missing fields.     * <p>     * The resulting chronology is determined by the chronology of this     * LocalDate plus the time zone. The chronology of the time must match.     * If the time is null, the current time in the date's chronology is used.     * <p>     * This method will throw an exception if the datetime that would be     * created does not exist when the time zone is taken into account.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param time  the time of day to use, null means current time     * @param zone  the zone to get the DateTime in, null means default     * @return the DateTime instance     * @throws IllegalArgumentException if the chronology of the time does not match     */
/**     * Converts this object to an Interval representing the whole day.     * <p>     * The interval may have more or less than 24 hours if this is a daylight     * savings cutover date.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param zone  the zone to get the Interval in, null means default     * @return a interval over the day     */
/**     * Returns a copy of this date with different local millis.     * <p>     * The returned object will be a new instance of the same type.     * Only the millis will change, the chronology is kept.     * The returned object will be either be a new instance or <code>this</code>.     *     * @param newMillis  the new millis, from 1970-01-01T00:00:00     * @return a copy of this date with different millis     */
/**     * Returns a copy of this date with the partial set of fields replacing     * those from this instance.     * <p>     * For example, if the partial contains a year and a month then those two     * fields will be changed in the returned instance.     * Unsupported fields are ignored.     * If the partial is null, then <code>this</code> is returned.     *     * @param partial  the partial set of fields to apply to this date, null ignored     * @return a copy of this date with a different set of fields     * @throws IllegalArgumentException if any value is invalid     */
/**     * Returns a copy of this date with the specified field set to a new value.     * <p>     * For example, if the field type is <code>monthOfYear</code> then the     * month of year field will be changed in the returned instance.     * If the field type is null, then <code>this</code> is returned.     * <p>     * These two lines are equivalent:     * <pre>     * LocalDate updated = dt.withDayOfMonth(6);     * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this date with the field set     * @throws IllegalArgumentException if the field is null or unsupported     */
/**     * Returns a copy of this date with the value of the specified field increased.     * <p>     * If the addition is zero or the field is null, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);     * LocalDate added = dt.plusYears(6);     * LocalDate added = dt.plus(Period.years(6));     * </pre>     *     * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this date with the field updated     * @throws IllegalArgumentException if the field is null or unsupported     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this date with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusYears(int)}.     * <p>     * Unsupported time fields are ignored, thus adding a period of 24 hours     * will not have any effect.     *     * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this date with the period added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this date with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusYears(int)}.     * <p>     * Unsupported time fields are ignored, thus adding a period of 24 hours     * will not have any effect.     *     * @param period  the period to add to this one, null means zero     * @return a copy of this date with the period added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this date plus the specified number of years.     * <p>     * This adds the specified number of years to the date.     * If adding years makes the day-of-month invalid, it is adjusted to the last valid day in the month.     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate added = dt.plusYears(6);     * LocalDate added = dt.plus(Period.years(6));     * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);     * </pre>     *     * @param years  the amount of years to add, may be negative     * @return the new LocalDate plus the increased years     */
/**     * Returns a copy of this date plus the specified number of months.     * <p>     * This adds the specified number of months to the date.     * The addition may change the year, but the day-of-month is normally unchanged.     * If adding months makes the day-of-month invalid, it is adjusted to the last valid day in the month.     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate added = dt.plusMonths(6);     * LocalDate added = dt.plus(Period.months(6));     * LocalDate added = dt.withFieldAdded(DurationFieldType.months(), 6);     * </pre>     *     * @param months  the amount of months to add, may be negative     * @return the new LocalDate plus the increased months     */
/**     * Returns a copy of this date plus the specified number of weeks.     * <p>     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate added = dt.plusWeeks(6);     * LocalDate added = dt.plus(Period.weeks(6));     * LocalDate added = dt.withFieldAdded(DurationFieldType.weeks(), 6);     * </pre>     *     * @param weeks  the amount of weeks to add, may be negative     * @return the new LocalDate plus the increased weeks     */
/**     * Returns a copy of this date plus the specified number of days.     * <p>     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate added = dt.plusDays(6);     * LocalDate added = dt.plus(Period.days(6));     * LocalDate added = dt.withFieldAdded(DurationFieldType.days(), 6);     * </pre>     *     * @param days  the amount of days to add, may be negative     * @return the new LocalDate plus the increased days     */
/**     * Returns a copy of this date with the specified period taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusYears(int)}.     * <p>     * Unsupported time fields are ignored, thus subtracting a period of 24 hours     * will not have any effect.     *     * @param period  the period to reduce this instant by     * @return a copy of this LocalDate with the period taken away     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this date minus the specified number of years.     * <p>     * This subtracts the specified number of years from the date.     * If subtracting years makes the day-of-month invalid, it is adjusted to the last valid day in the month.     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate subtracted = dt.minusYears(6);     * LocalDate subtracted = dt.minus(Period.years(6));     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);     * </pre>     *     * @param years  the amount of years to subtract, may be negative     * @return the new LocalDate minus the increased years     */
/**     * Returns a copy of this date minus the specified number of months.     * <p>     * This subtracts the specified number of months from the date.     * The subtraction may change the year, but the day-of-month is normally unchanged.     * If subtracting months makes the day-of-month invalid, it is adjusted to the last valid day in the month.     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate subtracted = dt.minusMonths(6);     * LocalDate subtracted = dt.minus(Period.months(6));     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);     * </pre>     *     * @param months  the amount of months to subtract, may be negative     * @return the new LocalDate minus the increased months     */
/**     * Returns a copy of this date minus the specified number of weeks.     * <p>     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate subtracted = dt.minusWeeks(6);     * LocalDate subtracted = dt.minus(Period.weeks(6));     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);     * </pre>     *     * @param weeks  the amount of weeks to subtract, may be negative     * @return the new LocalDate minus the increased weeks     */
/**     * Returns a copy of this date minus the specified number of days.     * <p>     * This LocalDate instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDate subtracted = dt.minusDays(6);     * LocalDate subtracted = dt.minus(Period.days(6));     * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);     * </pre>     *     * @param days  the amount of days to subtract, may be negative     * @return the new LocalDate minus the increased days     */
/**     * Gets the property object for the specified type, which contains many     * useful methods.     *     * @param fieldType  the field type to get the chronology for     * @return the property object     * @throws IllegalArgumentException if the field is null or unsupported     */
/**     * Get the era field value.     *     * @return the era     */
/**     * Get the year of era field value.     *     * @return the year of era     */
/**     * Get the year of era field value.     *     * @return the year of era     */
/**     * Get the year of century field value.     *     * @return the year of century     */
/**     * Get the year field value.     *     * @return the year     */
/**     * Get the weekyear field value.     * <p>     * The weekyear is the year that matches with the weekOfWeekyear field.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * The weekyear allows you to query the effective year for that day.     *     * @return the weekyear     */
/**     * Get the month of year field value.     *     * @return the month of year     */
/**     * Get the week of weekyear field value.     * <p>     * This field is associated with the "weekyear" via {@link #getWeekyear()}.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     *     * @return the week of a week based year     */
/**     * Get the day of year field value.     *     * @return the day of year     */
/**     * Get the day of month field value.     * <p>     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.     *     * @return the day of month     */
/**     * Get the day of week field value.     * <p>     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.     *     * @return the day of week     */
/**     * Returns a copy of this date with the era field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * era changed.     *     * @param era  the era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the century of era field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * century of era changed.     *     * @param centuryOfEra  the centurey of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the year of era field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of era changed.     *     * @param yearOfEra  the year of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the year of century field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of century changed.     *     * @param yearOfCentury  the year of century to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the year field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year changed.     *     * @param year  the year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the weekyear field updated.     * <p>     * The weekyear is the year that matches with the weekOfWeekyear field.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * The weekyear allows you to query the effective year for that day.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * weekyear changed.     *     * @param weekyear  the weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the month of year field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * month of year changed.     *     * @param monthOfYear  the month of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the week of weekyear field updated.     * <p>     * This field is associated with the "weekyear" via {@link #withWeekyear(int)}.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * week of weekyear changed.     *     * @param weekOfWeekyear  the week of weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the day of year field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of year changed.     *     * @param dayOfYear  the day of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the day of month field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of month changed.     *     * @param dayOfMonth  the day of month to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this date with the day of week field updated.     * <p>     * LocalDate is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of week changed.     *     * @param dayOfWeek  the day of week to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Get the era property which provides access to advanced functionality.     *     * @return the era property     */
/**     * Get the century of era property which provides access to advanced functionality.     *     * @return the year of era property     */
/**     * Get the year of century property which provides access to advanced functionality.     *     * @return the year of era property     */
/**     * Get the year of era property which provides access to advanced functionality.     *     * @return the year of era property     */
/**     * Get the year property which provides access to advanced functionality.     *     * @return the year property     */
/**     * Get the weekyear property which provides access to advanced functionality.     *     * @return the weekyear property     */
/**     * Get the month of year property which provides access to advanced functionality.     *     * @return the month of year property     */
/**     * Get the week of a week based year property which provides access to advanced functionality.     *     * @return the week of a week based year property     */
/**     * Get the day of year property which provides access to advanced functionality.     *     * @return the day of year property     */
/**     * Get the day of month property which provides access to advanced functionality.     *     * @return the day of month property     */
/**     * Get the day of week property which provides access to advanced functionality.     *     * @return the day of week property     */
/**     * Output the date using the specified format pattern.     *     * @param pattern  the pattern specification, null means use <code>toString</code>     * @param locale  Locale to use, null means default     * @see org.joda.time.format.DateTimeFormat     */
/**         * Reads the property from a safe serialization format.         */
/**         * Gets the milliseconds of the date that this property is linked to.         *          * @return the milliseconds         */
/**         * Gets the LocalDate object linked to this property.         *          * @return the linked LocalDate         */
/**         * Adds to this field in a copy of this LocalDate.         * <p>         * The LocalDate attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalDate with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to this field, possibly wrapped, in a copy of this LocalDate.         * A field wrapped operation only changes this field.         * Thus 31st January addWrapField one day goes to the 1st January.         * <p>         * The LocalDate attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalDate with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the LocalDate to a parsed text value.         * <p>         * The LocalDate attached to this property is unchanged by this call.         *         * @param text  the text value to set         * @return a copy of the LocalDate with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new LocalDate with this field set to the maximum value         * for this field.         * <p>         * This operation is useful for obtaining a LocalDate on the last day         * of the month, as month lengths vary.         * <pre>         * LocalDate lastDayOfMonth = dt.dayOfMonth().withMaximumValue();         * </pre>         * <p>         * The LocalDate attached to this property is unchanged by this call.         *         * @return a copy of the LocalDate with this field set to its maximum         */
/**         * Returns a new LocalDate with this field set to the minimum value         * for this field.         * <p>         * The LocalDate attached to this property is unchanged by this call.         *         * @return a copy of the LocalDate with this field set to its minimum         */
/**         * Rounds to the lowest whole unit of this field on a copy of this         * LocalDate.         * <p>         * For example, rounding floor on the hourOfDay field of a LocalDate         * where the time is 10:30 would result in new LocalDate with the         * time of 10:00.         *         * @return a copy of the LocalDate with the field value changed         */
/**         * Rounds to the highest whole unit of this field on a copy of this         * LocalDate.         * <p>         * For example, rounding floor on the hourOfDay field of a LocalDate         * where the time is 10:30 would result in new LocalDate with the         * time of 11:00.         *         * @return a copy of the LocalDate with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalDate, favoring the floor if halfway.         *         * @return a copy of the LocalDate with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalDate, favoring the ceiling if halfway.         *         * @return a copy of the LocalDate with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalDate.  If halfway, the ceiling is favored over the floor         * only if it makes this field's value even.         *         * @return a copy of the LocalDate with the field value changed         */
/**     * Constructs an instance set to the current local time evaluated using     * ISO chronology in the default zone.     * <p>     * Once the constructor is completed, the zone is no longer used.     *      * @see #now()     */
/**     * Constructs an instance set to the current local time evaluated using     * ISO chronology in the specified zone.     * <p>     * If the specified time zone is null, the default zone is used.     * Once the constructor is completed, the zone is no longer used.     *     * @param zone  the time zone, null means default zone     * @see #now(DateTimeZone)     */
/**     * Constructs an instance set to the current local time evaluated using     * specified chronology.     * <p>     * If the chronology is null, ISO chronology in the default time zone is used.     * Once the constructor is completed, the zone is no longer used.     *     * @param chronology  the chronology, null means ISOChronology in default zone     * @see #now(Chronology)     */
/**     * Constructs an instance set to the local time defined by the specified     * instant evaluated using ISO chronology in the default zone.     * <p>     * Once the constructor is completed, the zone is no longer used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     */
/**     * Constructs an instance set to the local time defined by the specified     * instant evaluated using ISO chronology in the specified zone.     * <p>     * If the specified time zone is null, the default zone is used.     * Once the constructor is completed, the zone is no longer used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param zone  the time zone, null means default zone     */
/**     * Constructs an instance set to the local time defined by the specified     * instant evaluated using the specified chronology.     * <p>     * If the chronology is null, ISO chronology in the default zone is used.     * Once the constructor is completed, the zone is no longer used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param chronology  the chronology, null means ISOChronology in default zone     */
/**     * Constructs an instance from an Object that represents a datetime.     * <p>     * If the object contains no chronology, <code>ISOChronology</code> is used.     * If the object contains no time zone, the default zone is used.     * Once the constructor is completed, the zone is no longer used.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePartial, ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.     * The default String converter ignores the zone and only parses the field values.     *     * @param instant  the datetime object     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs an instance from an Object that represents a datetime,     * forcing the time zone to that specified.     * <p>     * If the object contains no chronology, <code>ISOChronology</code> is used.     * If the specified time zone is null, the default zone is used.     * Once the constructor is completed, the zone is no longer used.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePartial, ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.     * The default String converter ignores the zone and only parses the field values.     *     * @param instant  the datetime object     * @param zone  the time zone     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs an instance from an Object that represents a datetime,     * using the specified chronology.     * <p>     * If the chronology is null, ISO in the default time zone is used.     * Once the constructor is completed, the zone is no longer used.     * If the instant contains a chronology, it will be ignored.     * For example, passing a {@code LocalDate} and a different chronology     * will return a date with the year/month/day from the date applied     * unaltered to the specified chronology.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePartial, ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#localDateOptionalTimeParser()}.     * The default String converter ignores the zone and only parses the field values.     *     * @param instant  the datetime object     * @param chronology  the chronology     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Returns a copy of this datetime with the specified date,     * retaining the time fields.     * <p>     * If the date is already the date passed in, then <code>this</code> is returned.     * <p>     * To set a single field use the properties, for example:     * <pre>     * DateTime set = dt.monthOfYear().setCopy(6);     * </pre>     *     * @param year  the new year value     * @param monthOfYear  the new monthOfYear value     * @param dayOfMonth  the new dayOfMonth value     * @return a copy of this datetime with a different date     * @throws IllegalArgumentException if any value if invalid     */
/**     * Returns a copy of this datetime with the specified time,     * retaining the date fields.     * <p>     * If the time is already the time passed in, then <code>this</code> is returned.     * <p>     * To set a single field use the properties, for example:     * <pre>     * LocalDateTime set = dt.hourOfDay().setCopy(6);     * </pre>     *     * @param hourOfDay  the hour of the day     * @param minuteOfHour  the minute of the hour     * @param secondOfMinute  the second of the minute     * @param millisOfSecond  the millisecond of the second     * @return a copy of this datetime with a different time     * @throws IllegalArgumentException if any value if invalid     */
/**     * Returns a copy of this datetime with the partial set of fields     * replacing those from this instance.     * <p>     * For example, if the partial is a <code>TimeOfDay</code> then the time fields     * would be changed in the returned instance.     * If the partial is null, then <code>this</code> is returned.     *     * @param partial  the partial set of fields to apply to this datetime, null ignored     * @return a copy of this datetime with a different set of fields     * @throws IllegalArgumentException if any value is invalid     */
/**     * Returns a copy of this datetime with the specified field set to a new value.     * <p>     * For example, if the field type is <code>hourOfDay</code> then the hour of day     * field would be changed in the returned instance.     * If the field type is null, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * LocalDateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);     * LocalDateTime updated = dt.dayOfMonth().setCopy(6);     * LocalDateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this datetime with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this datetime with the value of the specified     * field increased.     * <p>     * If the addition is zero or the field is null, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);     * LocalDateTime added = dt.plusYears(6);     * LocalDateTime added = dt.plus(Period.years(6));     * </pre>     *     * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this datetime with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this datetime with the specified duration added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     *     * @param durationToAdd  the duration to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this datetime with the duration added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this datetime with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusYears(int)}.     *     * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this datetime with the period added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this datetime with the specified duration added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *     * @param duration  the duration to add to this one, null means zero     * @return a copy of this datetime with the duration added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this datetime with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusYears(int)}.     *     * @param period  the period to add to this one, null means zero     * @return a copy of this datetime with the period added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this datetime plus the specified number of years.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusYears(6);     * LocalDateTime added = dt.plus(Period.years(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);     * </pre>     *     * @param years  the amount of years to add, may be negative     * @return the new LocalDateTime plus the increased years     */
/**     * Returns a copy of this datetime plus the specified number of months.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusMonths(6);     * LocalDateTime added = dt.plus(Period.months(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);     * </pre>     *     * @param months  the amount of months to add, may be negative     * @return the new LocalDateTime plus the increased months     */
/**     * Returns a copy of this datetime plus the specified number of weeks.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusWeeks(6);     * LocalDateTime added = dt.plus(Period.weeks(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);     * </pre>     *     * @param weeks  the amount of weeks to add, may be negative     * @return the new LocalDateTime plus the increased weeks     */
/**     * Returns a copy of this datetime plus the specified number of days.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusDays(6);     * LocalDateTime added = dt.plus(Period.days(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);     * </pre>     *     * @param days  the amount of days to add, may be negative     * @return the new LocalDateTime plus the increased days     */
/**     * Returns a copy of this datetime plus the specified number of hours.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusHours(6);     * LocalDateTime added = dt.plus(Period.hours(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);     * </pre>     *     * @param hours  the amount of hours to add, may be negative     * @return the new LocalDateTime plus the increased hours     */
/**     * Returns a copy of this datetime plus the specified number of minutes.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusMinutes(6);     * LocalDateTime added = dt.plus(Period.minutes(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);     * </pre>     *     * @param minutes  the amount of minutes to add, may be negative     * @return the new LocalDateTime plus the increased minutes     */
/**     * Returns a copy of this datetime plus the specified number of seconds.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusSeconds(6);     * LocalDateTime added = dt.plus(Period.seconds(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);     * </pre>     *     * @param seconds  the amount of seconds to add, may be negative     * @return the new LocalDateTime plus the increased seconds     */
/**     * Returns a copy of this datetime plus the specified number of millis.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusMillis(6);     * LocalDateTime added = dt.plus(Period.millis(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);     * </pre>     *     * @param millis  the amount of millis to add, may be negative     * @return the new LocalDateTime plus the increased millis     */
/**     * Returns a copy of this datetime with the specified duration taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *     * @param duration  the duration to reduce this instant by     * @return a copy of this datetime with the duration taken away     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this datetime with the specified period taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusYears(int)}.     *     * @param period  the period to reduce this instant by     * @return a copy of this datetime with the period taken away     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this datetime minus the specified number of years.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusYears(6);     * LocalDateTime subtracted = dt.minus(Period.years(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);     * </pre>     *     * @param years  the amount of years to subtract, may be negative     * @return the new LocalDateTime minus the increased years     */
/**     * Returns a copy of this datetime minus the specified number of months.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusMonths(6);     * LocalDateTime subtracted = dt.minus(Period.months(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);     * </pre>     *     * @param months  the amount of months to subtract, may be negative     * @return the new LocalDateTime minus the increased months     */
/**     * Returns a copy of this datetime minus the specified number of weeks.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusWeeks(6);     * LocalDateTime subtracted = dt.minus(Period.weeks(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);     * </pre>     *     * @param weeks  the amount of weeks to subtract, may be negative     * @return the new LocalDateTime minus the increased weeks     */
/**     * Returns a copy of this datetime minus the specified number of days.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusDays(6);     * LocalDateTime subtracted = dt.minus(Period.days(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);     * </pre>     *     * @param days  the amount of days to subtract, may be negative     * @return the new LocalDateTime minus the increased days     */
/**     * Returns a copy of this datetime minus the specified number of hours.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusHours(6);     * LocalDateTime subtracted = dt.minus(Period.hours(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);     * </pre>     *     * @param hours  the amount of hours to subtract, may be negative     * @return the new LocalDateTime minus the increased hours     */
/**     * Returns a copy of this datetime minus the specified number of minutes.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusMinutes(6);     * LocalDateTime subtracted = dt.minus(Period.minutes(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);     * </pre>     *     * @param minutes  the amount of minutes to subtract, may be negative     * @return the new LocalDateTime minus the increased minutes     */
/**     * Returns a copy of this datetime minus the specified number of seconds.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusSeconds(6);     * LocalDateTime subtracted = dt.minus(Period.seconds(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);     * </pre>     *     * @param seconds  the amount of seconds to subtract, may be negative     * @return the new LocalDateTime minus the increased seconds     */
/**     * Returns a copy of this datetime minus the specified number of millis.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusMillis(6);     * LocalDateTime subtracted = dt.minus(Period.millis(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);     * </pre>     *     * @param millis  the amount of millis to subtract, may be negative     * @return the new LocalDateTime minus the increased millis     */
/**     * Returns a copy of this datetime with the era field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * era changed.     *     * @param era  the era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the century of era field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * century of era changed.     *     * @param centuryOfEra  the centurey of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the year of era field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of era changed.     *     * @param yearOfEra  the year of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the year of century field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of century changed.     *     * @param yearOfCentury  the year of century to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the year field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year changed.     *     * @param year  the year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the weekyear field updated.     * <p>     * The weekyear is the year that matches with the weekOfWeekyear field.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * The weekyear allows you to query the effective year for that day.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * weekyear changed.     *     * @param weekyear  the weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the month of year field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * month of year changed.     *     * @param monthOfYear  the month of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the week of weekyear field updated.     * <p>     * This field is associated with the "weekyear" via {@link #withWeekyear(int)}.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * week of weekyear changed.     *     * @param weekOfWeekyear  the week of weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the day of year field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of year changed.     *     * @param dayOfYear  the day of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the day of month field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of month changed.     *     * @param dayOfMonth  the day of month to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the day of week field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of week changed.     *     * @param dayOfWeek  the day of week to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the hour of day field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * hour of day changed.     *     * @param hour  the hour of day to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the minute of hour field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * minute of hour changed.     *     * @param minute  the minute of hour to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the second of minute field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * second of minute changed.     *     * @param second  the second of minute to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the millis of second field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * millis of second changed.     *     * @param millis  the millis of second to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the millis of day field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * millis of day changed.     *     * @param millis  the millis of day to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**         * Gets the LocalDateTime object linked to this property.         *          * @return the linked LocalDateTime         */
/**         * Adds to this field in a copy of this LocalDateTime.         * <p>         * The LocalDateTime attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalDateTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to this field in a copy of this LocalDateTime.         * <p>         * The LocalDateTime attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalDateTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to this field, possibly wrapped, in a copy of this LocalDateTime.         * A field wrapped operation only changes this field.         * Thus 31st January addWrapField one day goes to the 1st January.         * <p>         * The LocalDateTime attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalDateTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the LocalDateTime.         * <p>         * The LocalDateTime attached to this property is unchanged by this call.         *         * @param value  the value to set the field in the copy to         * @return a copy of the LocalDateTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the LocalDateTime to a parsed text value.         * <p>         * The LocalDateTime attached to this property is unchanged by this call.         *         * @param text  the text value to set         * @param locale  optional locale to use for selecting a text symbol         * @return a copy of the LocalDateTime with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Sets this field in a copy of the LocalDateTime to a parsed text value.         * <p>         * The LocalDateTime attached to this property is unchanged by this call.         *         * @param text  the text value to set         * @return a copy of the LocalDateTime with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new LocalDateTime with this field set to the maximum value         * for this field.         * <p>         * This operation is useful for obtaining a LocalDateTime on the last day         * of the month, as month lengths vary.         * <pre>         * LocalDateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();         * </pre>         * <p>         * The LocalDateTime attached to this property is unchanged by this call.         *         * @return a copy of the LocalDateTime with this field set to its maximum         */
/**         * Returns a new LocalDateTime with this field set to the minimum value         * for this field.         * <p>         * The LocalDateTime attached to this property is unchanged by this call.         *         * @return a copy of the LocalDateTime with this field set to its minimum         */
/**         * Rounds to the lowest whole unit of this field on a copy of this         * LocalDateTime.         * <p>         * For example, rounding floor on the hourOfDay field of a LocalDateTime         * where the time is 10:30 would result in new LocalDateTime with the         * time of 10:00.         *         * @return a copy of the LocalDateTime with the field value changed         */
/**         * Rounds to the highest whole unit of this field on a copy of this         * LocalDateTime.         * <p>         * For example, rounding floor on the hourOfDay field of a LocalDateTime         * where the time is 10:30 would result in new LocalDateTime with the         * time of 11:00.         *         * @return a copy of the LocalDateTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalDateTime, favoring the floor if halfway.         *         * @return a copy of the LocalDateTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalDateTime, favoring the ceiling if halfway.         *         * @return a copy of the LocalDateTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalDateTime.  If halfway, the ceiling is favored over the floor         * only if it makes this field's value even.         *         * @return a copy of the LocalDateTime with the field value changed         */
/**     * Obtains a {@code LocalDateTime} set to the current system millisecond time     * using the specified chronology.     * The resulting object does not use the zone.     *     * @param chronology  the chronology, not null     * @return the current date, not null     * @since 2.0     */
/**     * Parses a {@code LocalDateTime} from the specified string using a formatter.     *      * @param str  the string to parse, not null     * @param formatter  the formatter to use, not null     * @since 2.0     */
/**     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>     * using exactly the same field values.     * <p>     * Each field is queried from the Calendar and assigned to the LocalDateTime.     * This is useful if you have been using the Calendar as a local date,     * ignoring the zone.     * <p>     * One advantage of this method is that this method is unaffected if the     * version of the time zone data differs between the JDK and Joda-Time.     * That is because the local field values are transferred, calculated using     * the JDK time zone data and without using the Joda-Time time zone data.     * <p>     * This factory method ignores the type of the calendar and always     * creates a LocalDateTime with ISO chronology. It is expected that you     * will only pass in instances of <code>GregorianCalendar</code> however     * this is not validated.     *     * @param calendar  the Calendar to extract fields from, not null     * @return the created local date-time, not null     * @throws IllegalArgumentException if the calendar is null     * @throws IllegalArgumentException if the date is invalid for the ISO chronology     */
/**     * Handle broken serialization from other tools.     * @return the resolved object, not null     */
/**     * Gets the number of fields in this partial, which is four.     * The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.     *     * @return the field count, four     */
/**     * Gets the value of the field at the specifed index.     * <p>     * This method is required to support the <code>ReadablePartial</code>     * interface. The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.     *     * @param index  the index, zero to two     * @return the value     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Get the value of one of the fields of a datetime.     * <p>     * This method gets the value of the specified field.     * For example:     * <pre>     * DateTime dt = new DateTime();     * int year = dt.get(DateTimeFieldType.year());     * </pre>     *     * @param type  a field type, usually obtained from DateTimeFieldType, not null     * @return the value of that field     * @throws IllegalArgumentException if the field type is null     */
/**     * Checks if the duration type specified is supported by this     * local datetime and chronology.     *     * @param type  a duration type, usually obtained from DurationFieldType     * @return true if the field type is supported     */
/**     * Gets the milliseconds of the datetime instant from the Java epoch     * of 1970-01-01T00:00:00 (not fixed to any specific time zone).     *     * @return the number of milliseconds since 1970-01-01T00:00:00     * @since 1.5 (previously private)     */
/**     * Compares this ReadablePartial with another returning true if the chronology,     * field types and values are equal.     *     * @param partial  an object to check against     * @return true if fields and values are equal     */
/**     * Compares this partial with another returning an integer     * indicating the order.     * <p>     * The fields are compared in order, from largest to smallest.     * The first field that is non-equal is used to determine the result.     * <p>     * The specified object must be a partial instance whose field types     * match those of this partial.     *     * @param partial  an object to check against     * @return negative if this is less, zero if equal, positive if greater     * @throws ClassCastException if the partial is the wrong class     *  or if it has field types that don't match     * @throws NullPointerException if the partial is null     */
/**     * Converts this object to a DateTime using the specified zone.     * <p>     * This method will throw an exception if the datetime that would be     * created does not exist when the time zone is taken into account.     *      * @param zone time zone to apply, or default if null     * @return a DateTime using the same millis     */
/**     * Converts this object to a LocalDate with the same date and chronology.     *     * @return a LocalDate with the same date and chronology     */
/**     * Converts this object to a LocalTime with the same time and chronology.     *     * @return a LocalTime with the same time and chronology     */
/**     * Get the date time as a <code>java.util.Date</code> using the specified time zone.     * <p>     * The <code>Date</code> object created has exactly the same fields as this     * date-time, except when the time would be invalid due to a daylight savings     * gap. In that case, the time will be set to the earliest valid time after the gap.     * <p>     * In the case of a daylight savings overlap, the earlier instant is selected.     * <p>     * Converting to a JDK Date is full of complications as the JDK Date constructor     * doesn't behave as you might expect around DST transitions. This method works     * by taking a first guess and then adjusting. This also handles the situation     * where the JDK time zone data differs from the Joda-Time time zone data.     * <p>     * Unlike {@link #toDate()}, this implementation does not rely on Java's synchronized     * time zone initialization logic, and should demonstrate better concurrent performance     * characteristics.     *     * @return a Date initialised with this date-time, never null     * @since 2.3     */
/**     * Correct <code>date</code> in case of DST overlap.     * <p>     * The <code>Date</code> object created has exactly the same fields as this     * date-time, except when the time would be invalid due to a daylight savings     * gap. In that case, the time will be set to the earliest valid time after the gap.     * <p>     * In the case of a daylight savings overlap, the earlier instant is selected.     * <p>     * Converting to a JDK Date is full of complications as the JDK Date constructor     * doesn't behave as you might expect around DST transitions. This method works     * by taking a first guess and then adjusting. This also handles the situation     * where the JDK time zone data differs from the Joda-Time time zone data.     * @see #toDate()     */
/**     * Returns a copy of this datetime with different local millis.     * <p>     * The returned object will be a new instance of the same type.     * Only the millis will change, the chronology is kept.     * The returned object will be either be a new instance or <code>this</code>.     *     * @param newMillis  the new millis, from 1970-01-01T00:00:00     * @return a copy of this datetime with different millis     */
/**     * Returns a copy of this datetime with the specified date,     * retaining the time fields.     * <p>     * If the date is already the date passed in, then <code>this</code> is returned.     * <p>     * To set a single field use the properties, for example:     * <pre>     * DateTime set = dt.monthOfYear().setCopy(6);     * </pre>     *     * @param year  the new year value     * @param monthOfYear  the new monthOfYear value     * @param dayOfMonth  the new dayOfMonth value     * @return a copy of this datetime with a different date     * @throws IllegalArgumentException if any value if invalid     */
/**     * Returns a copy of this datetime with the specified time,     * retaining the date fields.     * <p>     * If the time is already the time passed in, then <code>this</code> is returned.     * <p>     * To set a single field use the properties, for example:     * <pre>     * LocalDateTime set = dt.hourOfDay().setCopy(6);     * </pre>     *     * @param hourOfDay  the hour of the day     * @param minuteOfHour  the minute of the hour     * @param secondOfMinute  the second of the minute     * @param millisOfSecond  the millisecond of the second     * @return a copy of this datetime with a different time     * @throws IllegalArgumentException if any value if invalid     */
/**     * Returns a copy of this datetime with the partial set of fields     * replacing those from this instance.     * <p>     * For example, if the partial is a <code>TimeOfDay</code> then the time fields     * would be changed in the returned instance.     * If the partial is null, then <code>this</code> is returned.     *     * @param partial  the partial set of fields to apply to this datetime, null ignored     * @return a copy of this datetime with a different set of fields     * @throws IllegalArgumentException if any value is invalid     */
/**     * Returns a copy of this datetime with the specified field set to a new value.     * <p>     * For example, if the field type is <code>hourOfDay</code> then the hour of day     * field would be changed in the returned instance.     * If the field type is null, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * LocalDateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);     * LocalDateTime updated = dt.dayOfMonth().setCopy(6);     * LocalDateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this datetime with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this datetime with the value of the specified     * field increased.     * <p>     * If the addition is zero or the field is null, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);     * LocalDateTime added = dt.plusYears(6);     * LocalDateTime added = dt.plus(Period.years(6));     * </pre>     *     * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this datetime with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this datetime with the specified duration added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     *     * @param durationToAdd  the duration to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this datetime with the duration added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this datetime with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusYears(int)}.     *     * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this datetime with the period added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this datetime with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusYears(int)}.     *     * @param period  the period to add to this one, null means zero     * @return a copy of this datetime with the period added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this datetime plus the specified number of years.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusYears(6);     * LocalDateTime added = dt.plus(Period.years(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);     * </pre>     *     * @param years  the amount of years to add, may be negative     * @return the new LocalDateTime plus the increased years     */
/**     * Returns a copy of this datetime plus the specified number of months.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusMonths(6);     * LocalDateTime added = dt.plus(Period.months(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);     * </pre>     *     * @param months  the amount of months to add, may be negative     * @return the new LocalDateTime plus the increased months     */
/**     * Returns a copy of this datetime plus the specified number of weeks.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusWeeks(6);     * LocalDateTime added = dt.plus(Period.weeks(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);     * </pre>     *     * @param weeks  the amount of weeks to add, may be negative     * @return the new LocalDateTime plus the increased weeks     */
/**     * Returns a copy of this datetime plus the specified number of days.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusDays(6);     * LocalDateTime added = dt.plus(Period.days(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);     * </pre>     *     * @param days  the amount of days to add, may be negative     * @return the new LocalDateTime plus the increased days     */
/**     * Returns a copy of this datetime plus the specified number of hours.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusHours(6);     * LocalDateTime added = dt.plus(Period.hours(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);     * </pre>     *     * @param hours  the amount of hours to add, may be negative     * @return the new LocalDateTime plus the increased hours     */
/**     * Returns a copy of this datetime plus the specified number of minutes.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusMinutes(6);     * LocalDateTime added = dt.plus(Period.minutes(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);     * </pre>     *     * @param minutes  the amount of minutes to add, may be negative     * @return the new LocalDateTime plus the increased minutes     */
/**     * Returns a copy of this datetime plus the specified number of seconds.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusSeconds(6);     * LocalDateTime added = dt.plus(Period.seconds(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);     * </pre>     *     * @param seconds  the amount of seconds to add, may be negative     * @return the new LocalDateTime plus the increased seconds     */
/**     * Returns a copy of this datetime plus the specified number of millis.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime added = dt.plusMillis(6);     * LocalDateTime added = dt.plus(Period.millis(6));     * LocalDateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);     * </pre>     *     * @param millis  the amount of millis to add, may be negative     * @return the new LocalDateTime plus the increased millis     */
/**     * Returns a copy of this datetime with the specified period taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusYears(int)}.     *     * @param period  the period to reduce this instant by     * @return a copy of this datetime with the period taken away     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this datetime minus the specified number of years.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusYears(6);     * LocalDateTime subtracted = dt.minus(Period.years(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);     * </pre>     *     * @param years  the amount of years to subtract, may be negative     * @return the new LocalDateTime minus the increased years     */
/**     * Returns a copy of this datetime minus the specified number of months.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusMonths(6);     * LocalDateTime subtracted = dt.minus(Period.months(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);     * </pre>     *     * @param months  the amount of months to subtract, may be negative     * @return the new LocalDateTime minus the increased months     */
/**     * Returns a copy of this datetime minus the specified number of weeks.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusWeeks(6);     * LocalDateTime subtracted = dt.minus(Period.weeks(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);     * </pre>     *     * @param weeks  the amount of weeks to subtract, may be negative     * @return the new LocalDateTime minus the increased weeks     */
/**     * Returns a copy of this datetime minus the specified number of days.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusDays(6);     * LocalDateTime subtracted = dt.minus(Period.days(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);     * </pre>     *     * @param days  the amount of days to subtract, may be negative     * @return the new LocalDateTime minus the increased days     */
/**     * Returns a copy of this datetime minus the specified number of hours.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusHours(6);     * LocalDateTime subtracted = dt.minus(Period.hours(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);     * </pre>     *     * @param hours  the amount of hours to subtract, may be negative     * @return the new LocalDateTime minus the increased hours     */
/**     * Returns a copy of this datetime minus the specified number of minutes.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusMinutes(6);     * LocalDateTime subtracted = dt.minus(Period.minutes(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);     * </pre>     *     * @param minutes  the amount of minutes to subtract, may be negative     * @return the new LocalDateTime minus the increased minutes     */
/**     * Returns a copy of this datetime minus the specified number of seconds.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusSeconds(6);     * LocalDateTime subtracted = dt.minus(Period.seconds(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);     * </pre>     *     * @param seconds  the amount of seconds to subtract, may be negative     * @return the new LocalDateTime minus the increased seconds     */
/**     * Returns a copy of this datetime minus the specified number of millis.     * <p>     * This LocalDateTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalDateTime subtracted = dt.minusMillis(6);     * LocalDateTime subtracted = dt.minus(Period.millis(6));     * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);     * </pre>     *     * @param millis  the amount of millis to subtract, may be negative     * @return the new LocalDateTime minus the increased millis     */
/**     * Get the hour of day field value.     *     * @return the hour of day     */
/**     * Get the minute of hour field value.     *     * @return the minute of hour     */
/**     * Get the second of minute field value.     *     * @return the second of minute     */
/**     * Get the millis of second field value.     *     * @return the millis of second     */
/**     * Get the millis of day field value.     *     * @return the millis of day     */
/**     * Returns a copy of this datetime with the era field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * era changed.     *     * @param era  the era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the century of era field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * century of era changed.     *     * @param centuryOfEra  the centurey of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the year of era field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of era changed.     *     * @param yearOfEra  the year of era to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the year of century field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year of century changed.     *     * @param yearOfCentury  the year of century to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the year field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year changed.     *     * @param year  the year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the weekyear field updated.     * <p>     * The weekyear is the year that matches with the weekOfWeekyear field.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * The weekyear allows you to query the effective year for that day.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * weekyear changed.     *     * @param weekyear  the weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the month of year field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * month of year changed.     *     * @param monthOfYear  the month of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the week of weekyear field updated.     * <p>     * This field is associated with the "weekyear" via {@link #withWeekyear(int)}.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * week of weekyear changed.     *     * @param weekOfWeekyear  the week of weekyear to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the day of year field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of year changed.     *     * @param dayOfYear  the day of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the day of month field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of month changed.     *     * @param dayOfMonth  the day of month to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the day of week field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of week changed.     *     * @param dayOfWeek  the day of week to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the hour of day field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * hour of day changed.     *     * @param hour  the hour of day to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the minute of hour field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * minute of hour changed.     *     * @param minute  the minute of hour to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the second of minute field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * second of minute changed.     *     * @param second  the second of minute to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the millis of second field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * millis of second changed.     *     * @param millis  the millis of second to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this datetime with the millis of day field updated.     * <p>     * LocalDateTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * millis of day changed.     *     * @param millis  the millis of day to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**         * Reads the property from a safe serialization format.         */
/**         * Gets the milliseconds of the datetime that this property is linked to.         *          * @return the milliseconds         */
/**         * Gets the LocalDateTime object linked to this property.         *          * @return the linked LocalDateTime         */
/**         * Adds to this field in a copy of this LocalDateTime.         * <p>         * The LocalDateTime attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalDateTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to this field, possibly wrapped, in a copy of this LocalDateTime.         * A field wrapped operation only changes this field.         * Thus 31st January addWrapField one day goes to the 1st January.         * <p>         * The LocalDateTime attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalDateTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the LocalDateTime to a parsed text value.         * <p>         * The LocalDateTime attached to this property is unchanged by this call.         *         * @param text  the text value to set         * @return a copy of the LocalDateTime with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new LocalDateTime with this field set to the maximum value         * for this field.         * <p>         * This operation is useful for obtaining a LocalDateTime on the last day         * of the month, as month lengths vary.         * <pre>         * LocalDateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();         * </pre>         * <p>         * The LocalDateTime attached to this property is unchanged by this call.         *         * @return a copy of the LocalDateTime with this field set to its maximum         */
/**         * Returns a new LocalDateTime with this field set to the minimum value         * for this field.         * <p>         * The LocalDateTime attached to this property is unchanged by this call.         *         * @return a copy of the LocalDateTime with this field set to its minimum         */
/**         * Rounds to the lowest whole unit of this field on a copy of this         * LocalDateTime.         * <p>         * For example, rounding floor on the hourOfDay field of a LocalDateTime         * where the time is 10:30 would result in new LocalDateTime with the         * time of 10:00.         *         * @return a copy of the LocalDateTime with the field value changed         */
/**         * Rounds to the highest whole unit of this field on a copy of this         * LocalDateTime.         * <p>         * For example, rounding floor on the hourOfDay field of a LocalDateTime         * where the time is 10:30 would result in new LocalDateTime with the         * time of 11:00.         *         * @return a copy of the LocalDateTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalDateTime, favoring the floor if halfway.         *         * @return a copy of the LocalDateTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalDateTime, favoring the ceiling if halfway.         *         * @return a copy of the LocalDateTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalDateTime.  If halfway, the ceiling is favored over the floor         * only if it makes this field's value even.         *         * @return a copy of the LocalDateTime with the field value changed         */
/**     * Constructs an instance set to the current local time evaluated using     * ISO chronology in the default zone.     * <p>     * Once the constructor is completed, the zone is no longer used.     *      * @see #now()     */
/**     * Constructs an instance set to the current local time evaluated using     * ISO chronology in the specified zone.     * <p>     * If the specified time zone is null, the default zone is used.     * Once the constructor is completed, the zone is no longer used.     *     * @param zone  the time zone, null means default zone     * @see #now(DateTimeZone)     */
/**     * Constructs an instance set to the current local time evaluated using     * specified chronology and zone.     * <p>     * If the chronology is null, ISO chronology in the default time zone is used.     * Once the constructor is completed, the zone is no longer used.     *     * @param chronology  the chronology, null means ISOChronology in default zone     * @see #now(Chronology)     */
/**     * Constructs an instance set to the local time defined by the specified     * instant evaluated using ISO chronology in the default zone.     * <p>     * Once the constructor is completed, the zone is no longer used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     */
/**     * Constructs an instance set to the local time defined by the specified     * instant evaluated using ISO chronology in the specified zone.     * <p>     * If the specified time zone is null, the default zone is used.     * Once the constructor is completed, the zone is no longer used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param zone  the time zone, null means default zone     */
/**     * Constructs an instance set to the local time defined by the specified     * instant evaluated using the specified chronology.     * <p>     * If the chronology is null, ISO chronology in the default zone is used.     * Once the constructor is completed, the zone is no longer used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param chronology  the chronology, null means ISOChronology in default zone     */
/**     * Constructs an instance from an Object that represents a datetime.     * <p>     * If the object contains no chronology, <code>ISOChronology</code> is used.     * If the object contains no time zone, the default zone is used.     * Once the constructor is completed, the zone is no longer used.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePartial, ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.     * The default String converter ignores the zone and only parses the field values.     *     * @param instant  the datetime object     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs an instance from an Object that represents a datetime,     * forcing the time zone to that specified.     * <p>     * If the object contains no chronology, <code>ISOChronology</code> is used.     * If the specified time zone is null, the default zone is used.     * Once the constructor is completed, the zone is no longer used.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePartial, ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.     * The default String converter ignores the zone and only parses the field values.     *     * @param instant  the datetime object     * @param zone  the time zone     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs an instance from an Object that represents a datetime,     * using the specified chronology.     * <p>     * If the chronology is null, ISO in the default time zone is used.     * Once the constructor is completed, the zone is no longer used.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePartial, ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#localTimeParser()}.     * The default String converter ignores the zone and only parses the field values.     *     * @param instant  the datetime object     * @param chronology  the chronology     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Returns a copy of this time with the partial set of fields replacing     * those from this instance.     * <p>     * For example, if the partial contains an hour and minute then those two     * fields will be changed in the returned instance.     * Unsupported fields are ignored.     * If the partial is null, then <code>this</code> is returned.     *     * @param partial  the partial set of fields to apply to this time, null ignored     * @return a copy of this time with a different set of fields     * @throws IllegalArgumentException if any value is invalid     */
/**     * Returns a copy of this time with the specified field set     * to a new value.     * <p>     * For example, if the field type is <code>hourOfDay</code> then the hour of day     * field would be changed in the returned instance.     * If the field type is null, then <code>this</code> is returned.     * <p>     * These lines are equivalent:     * <pre>     * LocalTime updated = dt.withHourOfDay(6);     * LocalTime updated = dt.withField(DateTimeFieldType.hourOfDay(), 6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this time with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this time with the value of the specified     * field increased.     * <p>     * If the addition is zero or the field is null, then <code>this</code>     * is returned.     * <p>     * If the addition causes the maximum value of the field to be exceeded,     * then the value will wrap. Thus 23:59 plus two minutes yields 00:01.     * <p>     * These lines are equivalent:     * <pre>     * LocalTime added = dt.plusHours(6);     * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);     * </pre>     *     * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this time with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this time with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusHours(int)}.     *     * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this time with the period added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this time with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusHours(int)}.     *      * @param period  the period to add to this one, null means zero     * @return a copy of this time with the period added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this time plus the specified number of hours.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime added = dt.plusHours(6);     * LocalTime added = dt.plus(Period.hours(6));     * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);     * </pre>     *     * @param hours  the amount of hours to add, may be negative     * @return the new LocalTime plus the increased hours     */
/**     * Returns a copy of this time plus the specified number of minutes.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime added = dt.plusMinutes(6);     * LocalTime added = dt.plus(Period.minutes(6));     * LocalTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);     * </pre>     *     * @param minutes  the amount of minutes to add, may be negative     * @return the new LocalTime plus the increased minutes     */
/**     * Returns a copy of this time plus the specified number of seconds.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime added = dt.plusSeconds(6);     * LocalTime added = dt.plus(Period.seconds(6));     * LocalTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);     * </pre>     *     * @param seconds  the amount of seconds to add, may be negative     * @return the new LocalTime plus the increased seconds     */
/**     * Returns a copy of this time plus the specified number of millis.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime added = dt.plusMillis(6);     * LocalTime added = dt.plus(Period.millis(6));     * LocalTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);     * </pre>     *     * @param millis  the amount of millis to add, may be negative     * @return the new LocalTime plus the increased millis     */
/**     * Returns a copy of this time with the specified period taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusHours(int)}.     *      * @param period  the period to reduce this instant by     * @return a copy of this time with the period taken away     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this time minus the specified number of hours.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime subtracted = dt.minusHours(6);     * LocalTime subtracted = dt.minus(Period.hours(6));     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);     * </pre>     *     * @param hours  the amount of hours to subtract, may be negative     * @return the new LocalTime minus the increased hours     */
/**     * Returns a copy of this time minus the specified number of minutes.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime subtracted = dt.minusMinutes(6);     * LocalTime subtracted = dt.minus(Period.minutes(6));     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);     * </pre>     *     * @param minutes  the amount of minutes to subtract, may be negative     * @return the new LocalTime minus the increased minutes     */
/**     * Returns a copy of this time minus the specified number of seconds.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime subtracted = dt.minusSeconds(6);     * LocalTime subtracted = dt.minus(Period.seconds(6));     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);     * </pre>     *     * @param seconds  the amount of seconds to subtract, may be negative     * @return the new LocalTime minus the increased seconds     */
/**     * Returns a copy of this time minus the specified number of millis.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime subtracted = dt.minusMillis(6);     * LocalTime subtracted = dt.minus(Period.millis(6));     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);     * </pre>     *     * @param millis  the amount of millis to subtract, may be negative     * @return the new LocalTime minus the increased millis     */
/**     * Returns a copy of this time with the hour of day field updated.     * <p>     * LocalTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * hour of day changed.     *     * @param hour  the hour of day to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this time with the minute of hour field updated.     * <p>     * LocalTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * minute of hour changed.     *     * @param minute  the minute of hour to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this time with the second of minute field updated.     * <p>     * LocalTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * second of minute changed.     *     * @param second  the second of minute to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this time with the millis of second field updated.     * <p>     * LocalTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * millis of second changed.     *     * @param millis  the millis of second to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this time with the millis of day field updated.     * <p>     * LocalTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * millis of day changed.     *     * @param millis  the millis of day to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**         * Gets the LocalTime object linked to this property.         *          * @return the linked LocalTime         */
/**         * Adds to this field in a copy of this LocalTime.         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalTime with the field value changed         */
/**         * Adds to this field in a copy of this LocalTime.         * If the addition exceeds the maximum value (eg. 23:59) it will         * wrap to the minimum value (eg. 00:00).         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalTime with the field value changed         */
/**         * Adds to this field in a copy of this LocalTime.         * If the addition exceeds the maximum value (eg. 23:59) then         * an exception will be thrown.         * Contrast this behaviour to {@link #addCopy(int)}.         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalTime with the field value changed         * @throws IllegalArgumentException if the result is invalid         */
/**         * Adds to this field, possibly wrapped, in a copy of this LocalTime.         * A field wrapped operation only changes this field.         * Thus 10:59 plusWrapField one minute goes to 10:00.         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the LocalTime.         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @param value  the value to set the field in the copy to         * @return a copy of the LocalTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the LocalTime to a parsed text value.         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @param text  the text value to set         * @param locale  optional locale to use for selecting a text symbol         * @return a copy of the LocalTime with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Sets this field in a copy of the LocalTime to a parsed text value.         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @param text  the text value to set         * @return a copy of the LocalTime with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new LocalTime with this field set to the maximum value         * for this field.         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @return a copy of the LocalTime with this field set to its maximum         */
/**         * Returns a new LocalTime with this field set to the minimum value         * for this field.         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @return a copy of the LocalTime with this field set to its minimum         */
/**         * Rounds to the lowest whole unit of this field on a copy of this         * LocalTime.         * <p>         * For example, rounding floor on the hourOfDay field of a LocalTime         * where the time is 10:30 would result in new LocalTime with the         * time of 10:00.         *         * @return a copy of the LocalTime with the field value changed         */
/**         * Rounds to the highest whole unit of this field on a copy of this         * LocalTime.         * <p>         * For example, rounding floor on the hourOfDay field of a LocalTime         * where the time is 10:30 would result in new LocalTime with the         * time of 11:00.         *         * @return a copy of the LocalTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalTime, favoring the floor if halfway.         *         * @return a copy of the LocalTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalTime, favoring the ceiling if halfway.         *         * @return a copy of the LocalTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalTime.  If halfway, the ceiling is favored over the floor         * only if it makes this field's value even.         *         * @return a copy of the LocalTime with the field value changed         */
/**     * Obtains a {@code LocalTime} set to the current system millisecond time     * using the specified chronology.     * The resulting object does not use the zone.     *     * @param chronology  the chronology, not null     * @return the current time, not null     * @since 2.0     */
/**     * Parses a {@code LocalTime} from the specified string using a formatter.     *      * @param str  the string to parse, not null     * @param formatter  the formatter to use, not null     * @since 2.0     */
/**     * Constructs a LocalTime from the specified millis of day using the     * specified chronology.     * <p>     * The millisOfDay value may exceed the number of millis in one day,     * but additional days will be ignored.     * This method uses the UTC time zone internally.     *     * @param millisOfDay  the number of milliseconds into a day to convert     * @param chrono  the chronology, null means ISO chronology     */
/**     * Constructs a LocalTime from a <code>java.util.Calendar</code>     * using exactly the same field values.     * <p>     * Each field is queried from the Calendar and assigned to the LocalTime.     * This is useful if you have been using the Calendar as a local time,     * ignoring the zone.     * <p>     * One advantage of this method is that this method is unaffected if the     * version of the time zone data differs between the JDK and Joda-Time.     * That is because the local field values are transferred, calculated using     * the JDK time zone data and without using the Joda-Time time zone data.     * <p>     * This factory method ignores the type of the calendar and always     * creates a LocalTime with ISO chronology. It is expected that you     * will only pass in instances of <code>GregorianCalendar</code> however     * this is not validated.     *     * @param calendar  the Calendar to extract fields from     * @return the created LocalTime     * @throws IllegalArgumentException if the calendar is null     * @throws IllegalArgumentException if the date is invalid for the ISO chronology     */
/**     * Handle broken serialization from other tools.     * @return the resolved object, not null     */
/**     * Gets the number of fields in this partial, which is four.     * The supported fields are HourOfDay, MinuteOfHour, SecondOfMinute     * and MillisOfSecond.     *     * @return the field count, four     */
/**     * Gets the value of the field at the specifed index.     * <p>     * This method is required to support the <code>ReadablePartial</code>     * interface. The supported fields are HourOfDay, MinuteOfHour,     * SecondOfMinute and MillisOfSecond.     *     * @param index  the index, zero to three     * @return the value     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Get the value of one of the fields of time.     * <p>     * This method gets the value of the specified field.     * For example:     * <pre>     * DateTime dt = new DateTime();     * int hourOfDay = dt.get(DateTimeFieldType.hourOfDay());     * </pre>     *     * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null     * @return the value of that field     * @throws IllegalArgumentException if the field type is null     */
/**     * Checks if the duration type specified is supported by this     * local time and chronology.     *     * @param type  a duration type, usually obtained from DurationFieldType     * @return true if the field type is supported     */
/**     * Compares this ReadablePartial with another returning true if the chronology,     * field types and values are equal.     *     * @param partial  an object to check against     * @return true if fields and values are equal     */
/**     * Compares this partial with another returning an integer     * indicating the order.     * <p>     * The fields are compared in order, from largest to smallest.     * The first field that is non-equal is used to determine the result.     * <p>     * The specified object must be a partial instance whose field types     * match those of this partial.     *     * @param partial  an object to check against     * @return negative if this is less, zero if equal, positive if greater     * @throws ClassCastException if the partial is the wrong class     *  or if it has field types that don't match     * @throws NullPointerException if the partial is null     */
/**     * Returns a copy of this time with different local millis.     * <p>     * The returned object will be a new instance of the same type.     * Only the millis will change, the chronology is kept.     * The returned object will be either be a new instance or <code>this</code>.     *     * @param newMillis  the new millis, from 1970-01-01T00:00:00     * @return a copy of this time with different millis     */
/**     * Returns a copy of this time with the partial set of fields replacing     * those from this instance.     * <p>     * For example, if the partial contains an hour and minute then those two     * fields will be changed in the returned instance.     * Unsupported fields are ignored.     * If the partial is null, then <code>this</code> is returned.     *     * @param partial  the partial set of fields to apply to this time, null ignored     * @return a copy of this time with a different set of fields     * @throws IllegalArgumentException if any value is invalid     */
/**     * Returns a copy of this time with the specified field set     * to a new value.     * <p>     * For example, if the field type is <code>hourOfDay</code> then the hour of day     * field would be changed in the returned instance.     * If the field type is null, then <code>this</code> is returned.     * <p>     * These lines are equivalent:     * <pre>     * LocalTime updated = dt.withHourOfDay(6);     * LocalTime updated = dt.withField(DateTimeFieldType.hourOfDay(), 6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this time with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this time with the value of the specified     * field increased.     * <p>     * If the addition is zero or the field is null, then <code>this</code>     * is returned.     * <p>     * If the addition causes the maximum value of the field to be exceeded,     * then the value will wrap. Thus 23:59 plus two minutes yields 00:01.     * <p>     * These lines are equivalent:     * <pre>     * LocalTime added = dt.plusHours(6);     * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);     * </pre>     *     * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this time with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this time with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusHours(int)}.     *     * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this time with the period added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this time with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusHours(int)}.     *      * @param period  the period to add to this one, null means zero     * @return a copy of this time with the period added     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this time plus the specified number of hours.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime added = dt.plusHours(6);     * LocalTime added = dt.plus(Period.hours(6));     * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);     * </pre>     *     * @param hours  the amount of hours to add, may be negative     * @return the new LocalTime plus the increased hours     */
/**     * Returns a copy of this time plus the specified number of minutes.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime added = dt.plusMinutes(6);     * LocalTime added = dt.plus(Period.minutes(6));     * LocalTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);     * </pre>     *     * @param minutes  the amount of minutes to add, may be negative     * @return the new LocalTime plus the increased minutes     */
/**     * Returns a copy of this time plus the specified number of seconds.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime added = dt.plusSeconds(6);     * LocalTime added = dt.plus(Period.seconds(6));     * LocalTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);     * </pre>     *     * @param seconds  the amount of seconds to add, may be negative     * @return the new LocalTime plus the increased seconds     */
/**     * Returns a copy of this time plus the specified number of millis.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime added = dt.plusMillis(6);     * LocalTime added = dt.plus(Period.millis(6));     * LocalTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);     * </pre>     *     * @param millis  the amount of millis to add, may be negative     * @return the new LocalTime plus the increased millis     */
/**     * Returns a copy of this time with the specified period taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusHours(int)}.     *      * @param period  the period to reduce this instant by     * @return a copy of this time with the period taken away     * @throws ArithmeticException if the result exceeds the internal capacity     */
/**     * Returns a copy of this time minus the specified number of hours.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime subtracted = dt.minusHours(6);     * LocalTime subtracted = dt.minus(Period.hours(6));     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);     * </pre>     *     * @param hours  the amount of hours to subtract, may be negative     * @return the new LocalTime minus the increased hours     */
/**     * Returns a copy of this time minus the specified number of minutes.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime subtracted = dt.minusMinutes(6);     * LocalTime subtracted = dt.minus(Period.minutes(6));     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);     * </pre>     *     * @param minutes  the amount of minutes to subtract, may be negative     * @return the new LocalTime minus the increased minutes     */
/**     * Returns a copy of this time minus the specified number of seconds.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime subtracted = dt.minusSeconds(6);     * LocalTime subtracted = dt.minus(Period.seconds(6));     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);     * </pre>     *     * @param seconds  the amount of seconds to subtract, may be negative     * @return the new LocalTime minus the increased seconds     */
/**     * Returns a copy of this time minus the specified number of millis.     * <p>     * This LocalTime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * LocalTime subtracted = dt.minusMillis(6);     * LocalTime subtracted = dt.minus(Period.millis(6));     * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);     * </pre>     *     * @param millis  the amount of millis to subtract, may be negative     * @return the new LocalTime minus the increased millis     */
/**     * Gets the property object for the specified type, which contains     * many useful methods.     *     * @param fieldType  the field type to get the chronology for     * @return the property object     * @throws IllegalArgumentException if the field is null or unsupported     */
/**     * Returns a copy of this time with the hour of day field updated.     * <p>     * LocalTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * hour of day changed.     *     * @param hour  the hour of day to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this time with the minute of hour field updated.     * <p>     * LocalTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * minute of hour changed.     *     * @param minute  the minute of hour to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this time with the second of minute field updated.     * <p>     * LocalTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * second of minute changed.     *     * @param second  the second of minute to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this time with the millis of second field updated.     * <p>     * LocalTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * millis of second changed.     *     * @param millis  the millis of second to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this time with the millis of day field updated.     * <p>     * LocalTime is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * millis of day changed.     *     * @param millis  the millis of day to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     */
/**     * Converts this LocalTime to a full datetime using the specified time zone     * setting the time fields from this instance and the date fields from     * the current time.     * <p>     * This method uses the chronology from this instance plus the time zone     * specified.     *     * @param zone  the zone to use, null means default     * @return this time as a datetime using todays date     */
/**     * Output the time using the specified format pattern.     *     * @param pattern  the pattern specification, null means use <code>toString</code>     * @param locale  Locale to use, null means default     * @see org.joda.time.format.DateTimeFormat     */
/**         * Reads the property from a safe serialization format.         */
/**         * Gets the milliseconds of the time that this property is linked to.         *          * @return the milliseconds         */
/**         * Gets the LocalTime object linked to this property.         *          * @return the linked LocalTime         */
/**         * Adds to this field in a copy of this LocalTime.         * If the addition exceeds the maximum value (eg. 23:59) it will         * wrap to the minimum value (eg. 00:00).         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalTime with the field value changed         */
/**         * Adds to this field in a copy of this LocalTime.         * If the addition exceeds the maximum value (eg. 23:59) then         * an exception will be thrown.         * Contrast this behaviour to {@link #addCopy(int)}.         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalTime with the field value changed         * @throws IllegalArgumentException if the result is invalid         */
/**         * Adds to this field, possibly wrapped, in a copy of this LocalTime.         * A field wrapped operation only changes this field.         * Thus 10:59 plusWrapField one minute goes to 10:00.         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @param value  the value to add to the field in the copy         * @return a copy of the LocalTime with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the LocalTime to a parsed text value.         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @param text  the text value to set         * @return a copy of the LocalTime with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new LocalTime with this field set to the maximum value         * for this field.         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @return a copy of the LocalTime with this field set to its maximum         */
/**         * Returns a new LocalTime with this field set to the minimum value         * for this field.         * <p>         * The LocalTime attached to this property is unchanged by this call.         *         * @return a copy of the LocalTime with this field set to its minimum         */
/**         * Rounds to the lowest whole unit of this field on a copy of this         * LocalTime.         * <p>         * For example, rounding floor on the hourOfDay field of a LocalTime         * where the time is 10:30 would result in new LocalTime with the         * time of 10:00.         *         * @return a copy of the LocalTime with the field value changed         */
/**         * Rounds to the highest whole unit of this field on a copy of this         * LocalTime.         * <p>         * For example, rounding floor on the hourOfDay field of a LocalTime         * where the time is 10:30 would result in new LocalTime with the         * time of 11:00.         *         * @return a copy of the LocalTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalTime, favoring the floor if halfway.         *         * @return a copy of the LocalTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalTime, favoring the ceiling if halfway.         *         * @return a copy of the LocalTime with the field value changed         */
/**         * Rounds to the nearest whole unit of this field on a copy of this         * LocalTime.  If halfway, the ceiling is favored over the floor         * only if it makes this field's value even.         *         * @return a copy of the LocalTime with the field value changed         */
/**     * Returns a new instance with the specified number of minutes added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to add, may be negative     * @return the new period plus the specified number of minutes     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of minutes added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to add, may be negative, null means zero     * @return the new period plus the specified number of minutes     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of minutes taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to take away, may be negative     * @return the new period minus the specified number of minutes     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of minutes taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to take away, may be negative, null means zero     * @return the new period minus the specified number of minutes     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the minutes multiplied by the specified scalar.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param scalar  the amount to multiply by, may be negative     * @return the new period multiplied by the specified scalar     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the minutes divided by the specified divisor.     * The calculation uses integer division, thus 3 divided by 2 is 1.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param divisor  the amount to divide by, may be negative     * @return the new period divided by the specified divisor     * @throws ArithmeticException if the divisor is zero     */
/**     * Returns a new instance with the minutes value negated.     *     * @return the new period with a negated value     * @throws ArithmeticException if the result overflows an int     */
/**     * Obtains an instance of <code>Minutes</code> that may be cached.     * <code>Minutes</code> is immutable, so instances can be cached and shared.     * This factory method provides access to shared instances.     *     * @param minutes  the number of minutes to obtain an instance for     * @return the instance of Minutes     */
/**     * Creates a <code>Minutes</code> representing the number of whole minutes     * between the two specified partial datetimes.     * <p>     * The two partials must contain the same fields, for example you can specify     * two <code>LocalTime</code> objects.     *     * @param start  the start partial date, must not be null     * @param end  the end partial date, must not be null     * @return the period in minutes     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Creates a <code>Minutes</code> representing the number of whole minutes     * in the specified interval.     *     * @param interval  the interval to extract minutes from, null returns zero     * @return the period in minutes     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Creates a new <code>Minutes</code> representing the number of complete     * standard length minutes in the specified period.     * <p>     * This factory method converts all fields from the period to minutes using standardised     * durations for each field. Only those fields which have a precise duration in     * the ISO UTC chronology can be converted.     * <ul>     * <li>One week consists of 7 days.     * <li>One day consists of 24 hours.     * <li>One hour consists of 60 minutes.     * <li>One minute consists of 60 seconds.     * <li>One second consists of 1000 milliseconds.     * </ul>     * Months and Years are imprecise and periods containing these values cannot be converted.     *     * @param period  the period to get the number of minutes from, null returns zero     * @return the period in minutes     * @throws IllegalArgumentException if the period contains imprecise duration values     */
/**     * Resolves singletons.     *      * @return the singleton instance     */
/**     * Gets the duration field type, which is <code>minutes</code>.     *     * @return the period type     */
/**     * Gets the period type, which is <code>minutes</code>.     *     * @return the period type     */
/**     * Converts this period in minutes to a period in weeks assuming a     * 7 days week, 24 hour day and 60 minute hour.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all weeks are     * 7 days long, all days are 24 hours long and all hours are 60 minutes long.     * This is not true when daylight savings is considered and may also not     * be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of whole weeks for this number of minutes     */
/**     * Converts this period in minutes to a period in days assuming a     * 24 hour day and 60 minute hour.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all days are     * 24 hours long and all hours are 60 minutes long.     * This is not true when daylight savings is considered and may also not     * be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of whole days for this number of minutes     */
/**     * Converts this period in minutes to a period in hours assuming a     * 60 minute hour.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all hours are     * 60 minutes long.     * This may not be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of hours for this number of minutes     */
/**     * Converts this period in minutes to a period in seconds assuming a     * 60 second minute.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all minutes are     * 60 seconds long.     * This may not be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of seconds for this number of minutes     * @throws ArithmeticException if the number of seconds is too large to be represented     */
/**     * Converts this period in minutes to a duration in milliseconds assuming a     * 60 second minute.     * <p>     * This method allows you to convert from a period to a duration.     * However to achieve this it makes the assumption that all minutes are     * 60 seconds long. This might not be true for an unusual chronology,     * for example one that takes leap seconds into account.     * However, the method is included as it is a useful operation for many     * applications and business rules.     *     * @return a duration equivalent to this number of minutes     */
/**     * Gets the number of minutes that this period represents.     *     * @return the number of minutes in the period     */
/**     * Returns a new instance with the specified number of minutes added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to add, may be negative, null means zero     * @return the new period plus the specified number of minutes     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of minutes taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to take away, may be negative, null means zero     * @return the new period minus the specified number of minutes     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the minutes multiplied by the specified scalar.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param scalar  the amount to multiply by, may be negative     * @return the new period multiplied by the specified scalar     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the minutes divided by the specified divisor.     * The calculation uses integer division, thus 3 divided by 2 is 1.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param divisor  the amount to divide by, may be negative     * @return the new period divided by the specified divisor     * @throws ArithmeticException if the divisor is zero     */
/**     * Returns a new instance with the minutes value negated.     *     * @return the new period with a negated value     * @throws ArithmeticException if the result overflows an int     */
/**     * Is this minutes instance greater than the specified number of minutes.     *     * @param other  the other period, null means zero     * @return true if this minutes instance is greater than the specified one     */
/**     * Is this minutes instance less than the specified number of minutes.     *     * @param other  the other period, null means zero     * @return true if this minutes instance is less than the specified one     */
/**     * Constructs a MonthDay with the current monthOfYear, using ISOChronology in     * the default zone to extract the fields.     * <p>     * The constructor uses the default time zone, resulting in the local time     * being initialised. Once the constructor is complete, all further calculations     * are performed without reference to a time-zone (by switching to UTC).     *      * @see #now()     */
/**     * Constructs a MonthDay with the current month-day, using ISOChronology in     * the specified zone to extract the fields.     * <p>     * The constructor uses the specified time zone to obtain the current month-day.     * Once the constructor is complete, all further calculations     * are performed without reference to a time-zone (by switching to UTC).     *      * @param zone  the zone to use, null means default zone     * @see #now(DateTimeZone)     */
/**     * Constructs a MonthDay with the current month-day, using the specified chronology     * and zone to extract the fields.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a time-zone (by switching to UTC).     *     * @param chronology  the chronology, null means ISOChronology in the default zone     * @see #now(Chronology)     */
/**     * Constructs a MonthDay extracting the partial fields from the specified     * milliseconds using the ISOChronology in the default zone.     * <p>     * The constructor uses the default time zone, resulting in the local time     * being initialised. Once the constructor is complete, all further calculations     * are performed without reference to a time-zone (by switching to UTC).     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     */
/**     * Constructs a MonthDay extracting the partial fields from the specified     * milliseconds using the chronology provided.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a time-zone (by switching to UTC).     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param chronology  the chronology, null means ISOChronology in the default zone     */
/**     * Constructs a MonthDay from an Object that represents some form of time.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.     * <p>     * The chronology used will be derived from the object, defaulting to ISO.     *     * @param instant  the date-time object, null means now     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs a MonthDay from an Object that represents some form of time,     * using the specified chronology.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a time-zone (by switching to UTC).     * The specified chronology overrides that of the object.     *     * @param instant  the date-time object, null means now     * @param chronology  the chronology, null means ISO default     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs a MonthDay with specified year and month     * using <code>ISOChronology</code>.     * <p>     * The constructor uses the no time zone initialising the fields as provided.     * Once the constructor is complete, all further calculations     * are performed without reference to a time-zone (by switching to UTC).     *     * @param monthOfYear  the month of the year     * @param dayOfMonth  the day of the month     */
/**     * Constructs an instance set to the specified monthOfYear and dayOfMonth     * using the specified chronology, whose zone is ignored.     * <p>     * If the chronology is null, <code>ISOChronology</code> is used.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a time-zone (by switching to UTC).     *     * @param monthOfYear  the month of the year     * @param dayOfMonth  the day of the month     * @param chronology  the chronology, null means ISOChronology in the default zone     */
/**     * Returns a copy of this month-day with the specified chronology.     * This instance is immutable and unaffected by this method call.     * <p>     * This method retains the values of the fields, thus the result will     * typically refer to a different instant.     * <p>     * The time zone of the specified chronology is ignored, as MonthDay     * operates without a time zone.     *     * @param newChronology  the new chronology, null means ISO     * @return a copy of this month-day with a different chronology, never null     * @throws IllegalArgumentException if the values are invalid for the new chronology     */
/**     * Returns a copy of this month-day with the specified field set to a new value.     * <p>     * For example, if the field type is <code>dayOfMonth</code> then the day     * would be changed in the returned instance.     * <p>     * These three lines are equivalent:     * <pre>     * MonthDay updated = md.withField(DateTimeFieldType.dayOfMonth(), 6);     * MonthDay updated = md.dayOfMonth().setCopy(6);     * MonthDay updated = md.property(DateTimeFieldType.dayOfMonth()).setCopy(6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this instance with the field set, never null     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this month-day with the value of the specified field increased.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);     * MonthDay added = md.plusDays(6);     * MonthDay added = md.dayOfMonth().addToCopy(6);     * </pre>     *      * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this instance with the field updated, never null     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new date-time exceeds the capacity     */
/**     * Returns a copy of this month-day with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * Fields in the period that aren't present in the partial are ignored.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusMonths(int)}.     *      * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this instance with the period added, never null     * @throws ArithmeticException if the new date-time exceeds the capacity     */
/**     * Returns a copy of this month-day with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusMonths(int)}.     *      * @param period  the duration to add to this one, null means zero     * @return a copy of this instance with the period added, never null     * @throws ArithmeticException if the new month-day exceeds the capacity     */
/**     * Returns a copy of this month-day plus the specified number of months.     * <p>     * This month-day instance is immutable and unaffected by this method call.     * The month will wrap at the end of the year from December to January.     * The day will be adjusted to the last valid value if necessary.     * <p>     * The following three lines are identical in effect:     * <pre>     * MonthDay added = md.plusMonths(6);     * MonthDay added = md.plus(Period.months(6));     * MonthDay added = md.withFieldAdded(DurationFieldType.months(), 6);     * </pre>     *     * @param months  the amount of months to add, may be negative     * @return the new month-day plus the increased months, never null     */
/**     * Returns a copy of this month-day plus the specified number of days.     * <p>     * This month-day instance is immutable and unaffected by this method call.     * The month will wrap at the end of the year from December to January.     * <p>     * The following three lines are identical in effect:     * <pre>     * MonthDay added = md.plusDays(6);     * MonthDay added = md.plus(Period.days(6));     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);     * </pre>     *     * @param days  the amount of days to add, may be negative     * @return the new month-day plus the increased days, never null     */
/**     * Returns a copy of this month-day with the specified period taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusMonths(int)}.     *      * @param period  the period to reduce this instant by     * @return a copy of this instance with the period taken away, never null     * @throws ArithmeticException if the new month-day exceeds the capacity     */
/**     * Returns a copy of this month-day minus the specified number of months.     * <p>     * This MonthDay instance is immutable and unaffected by this method call.     * The month will wrap at the end of the year from January to December.     * The day will be adjusted to the last valid value if necessary.     * <p>     * The following three lines are identical in effect:     * <pre>     * MonthDay subtracted = md.minusMonths(6);     * MonthDay subtracted = md.minus(Period.months(6));     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.months(), -6);     * </pre>     *     * @param months  the amount of months to subtract, may be negative     * @return the new month-day minus the increased months, never null     */
/**     * Returns a copy of this month-day minus the specified number of months.     * <p>     * This month-day instance is immutable and unaffected by this method call.     * The month will wrap at the end of the year from January to December.     * <p>     * The following three lines are identical in effect:     * <pre>     * MonthDay subtracted = md.minusDays(6);     * MonthDay subtracted = md.minus(Period.days(6));     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.days(), -6);     * </pre>     *     * @param days  the amount of days to subtract, may be negative     * @return the new month-day minus the increased days, never null     */
/**     * Returns a copy of this month-day with the month of year field updated.     * <p>     * MonthDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * month of year changed.     *     * @param monthOfYear  the month of year to set     * @return a copy of this object with the field set, never null     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this month-day with the day of month field updated.     * <p>     * MonthDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of month changed.     *     * @param dayOfMonth  the day of month to set     * @return a copy of this object with the field set, never null     * @throws IllegalArgumentException if the value is invalid     */
/**         * Gets the partial that this property belongs to.         *          * @return the partial         */
/**         * Adds to the value of this field in a copy of this MonthDay.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it will affect larger fields.         * Smaller fields are unaffected.         * <p>         * The MonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the MonthDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to the value of this field in a copy of this MonthDay wrapping         * within this field if the maximum value is reached.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it wraps within this field.         * Other fields are unaffected.         * <p>         * For example,         * <code>--12-30</code> addWrapField one month returns <code>--01-30</code>.         * <p>         * The MonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the MonthDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the MonthDay.         * <p>         * The MonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param value  the value to set the field in the copy to         * @return a copy of the MonthDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the MonthDay to a parsed text value.         * <p>         * The MonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @param locale  optional locale to use for selecting a text symbol         * @return a copy of the MonthDay with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Sets this field in a copy of the MonthDay to a parsed text value.         * <p>         * The MonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @return a copy of the MonthDay with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**     * Obtains a {@code MonthDay} set to the current system millisecond time     * using the specified chronology.     * The resulting object does not use the zone.     *     * @param chronology  the chronology, not null     * @return the current month-day, not null     * @since 2.0     */
/**     * Parses a {@code MonthDay} from the specified string using a formatter.     *      * @param str  the string to parse, not null     * @param formatter  the formatter to use, not null     * @since 2.0     */
/**     * Constructs a MonthDay from a <code>java.util.Calendar</code>     * using exactly the same field values avoiding any time zone effects.     * <p>     * Each field is queried from the Calendar and assigned to the MonthDay.     * <p>     * This factory method ignores the type of the calendar and always     * creates a MonthDay with ISO chronology. It is expected that you     * will only pass in instances of <code>GregorianCalendar</code> however     * this is not validated.     *     * @param calendar  the Calendar to extract fields from     * @return the created MonthDay, never null     * @throws IllegalArgumentException if the calendar is null     * @throws IllegalArgumentException if the monthOfYear or dayOfMonth is invalid for the ISO chronology     */
/**     * Handle broken serialization from other tools.     * @return the resolved object, not null     */
/**     * Gets the number of fields in this partial, which is two.     * The supported fields are MonthOfYear and DayOfMonth.     * Note that only these fields may be queried.     *     * @return the field count, two     */
/**         * Gets the field that this property uses.         *          * @return the field         */
/**     * Gets the field type at the specified index.     *     * @param index  the index to retrieve     * @return the field at the specified index, never null     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Gets an array of the field type of each of the fields that this partial supports.     * <p>     * The fields are returned largest to smallest, Month, Day.     *     * @return the array of field types (cloned), largest to smallest, never null     */
/**     * Returns a copy of this month-day with the specified chronology.     * This instance is immutable and unaffected by this method call.     * <p>     * This method retains the values of the fields, thus the result will     * typically refer to a different instant.     * <p>     * The time zone of the specified chronology is ignored, as MonthDay     * operates without a time zone.     *     * @param newChronology  the new chronology, null means ISO     * @return a copy of this month-day with a different chronology, never null     * @throws IllegalArgumentException if the values are invalid for the new chronology     */
/**     * Returns a copy of this month-day with the specified field set to a new value.     * <p>     * For example, if the field type is <code>dayOfMonth</code> then the day     * would be changed in the returned instance.     * <p>     * These three lines are equivalent:     * <pre>     * MonthDay updated = md.withField(DateTimeFieldType.dayOfMonth(), 6);     * MonthDay updated = md.dayOfMonth().setCopy(6);     * MonthDay updated = md.property(DateTimeFieldType.dayOfMonth()).setCopy(6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this instance with the field set, never null     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this month-day with the value of the specified field increased.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);     * MonthDay added = md.plusDays(6);     * MonthDay added = md.dayOfMonth().addToCopy(6);     * </pre>     *      * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this instance with the field updated, never null     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new date-time exceeds the capacity     */
/**     * Returns a copy of this month-day with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * Fields in the period that aren't present in the partial are ignored.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusMonths(int)}.     *      * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this instance with the period added, never null     * @throws ArithmeticException if the new date-time exceeds the capacity     */
/**     * Returns a copy of this month-day with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusMonths(int)}.     *      * @param period  the duration to add to this one, null means zero     * @return a copy of this instance with the period added, never null     * @throws ArithmeticException if the new month-day exceeds the capacity     */
/**     * Returns a copy of this month-day plus the specified number of months.     * <p>     * This month-day instance is immutable and unaffected by this method call.     * The month will wrap at the end of the year from December to January.     * The day will be adjusted to the last valid value if necessary.     * <p>     * The following three lines are identical in effect:     * <pre>     * MonthDay added = md.plusMonths(6);     * MonthDay added = md.plus(Period.months(6));     * MonthDay added = md.withFieldAdded(DurationFieldType.months(), 6);     * </pre>     *     * @param months  the amount of months to add, may be negative     * @return the new month-day plus the increased months, never null     */
/**     * Returns a copy of this month-day plus the specified number of days.     * <p>     * This month-day instance is immutable and unaffected by this method call.     * The month will wrap at the end of the year from December to January.     * <p>     * The following three lines are identical in effect:     * <pre>     * MonthDay added = md.plusDays(6);     * MonthDay added = md.plus(Period.days(6));     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);     * </pre>     *     * @param days  the amount of days to add, may be negative     * @return the new month-day plus the increased days, never null     */
/**     * Returns a copy of this month-day with the specified period taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusMonths(int)}.     *      * @param period  the period to reduce this instant by     * @return a copy of this instance with the period taken away, never null     * @throws ArithmeticException if the new month-day exceeds the capacity     */
/**     * Returns a copy of this month-day minus the specified number of months.     * <p>     * This MonthDay instance is immutable and unaffected by this method call.     * The month will wrap at the end of the year from January to December.     * The day will be adjusted to the last valid value if necessary.     * <p>     * The following three lines are identical in effect:     * <pre>     * MonthDay subtracted = md.minusMonths(6);     * MonthDay subtracted = md.minus(Period.months(6));     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.months(), -6);     * </pre>     *     * @param months  the amount of months to subtract, may be negative     * @return the new month-day minus the increased months, never null     */
/**     * Returns a copy of this month-day minus the specified number of months.     * <p>     * This month-day instance is immutable and unaffected by this method call.     * The month will wrap at the end of the year from January to December.     * <p>     * The following three lines are identical in effect:     * <pre>     * MonthDay subtracted = md.minusDays(6);     * MonthDay subtracted = md.minus(Period.days(6));     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.days(), -6);     * </pre>     *     * @param days  the amount of days to subtract, may be negative     * @return the new month-day minus the increased days, never null     */
/**     * Converts this object to a LocalDate with the same month-day and chronology.     *     * @param year  the year to use, valid for chronology     * @return a LocalDate with the same month-day and chronology, never null     */
/**     * Get the month of year field value.     *     * @return the month of year     */
/**     * Get the day of month field value.     *     * @return the day of month     */
/**     * Returns a copy of this month-day with the month of year field updated.     * <p>     * MonthDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * month of year changed.     *     * @param monthOfYear  the month of year to set     * @return a copy of this object with the field set, never null     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this month-day with the day of month field updated.     * <p>     * MonthDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of month changed.     *     * @param dayOfMonth  the day of month to set     * @return a copy of this object with the field set, never null     * @throws IllegalArgumentException if the value is invalid     */
/**     * Gets the property object for the specified type, which contains     * many useful methods.     *     * @param type  the field type to get the property for     * @return the property object     * @throws IllegalArgumentException if the field is null or unsupported     */
/**     * Get the month of year field property which provides access to advanced functionality.     *      * @return the month of year property     */
/**     * Get the day of month field property which provides access to advanced functionality.     *      * @return the day of month property     */
/**     * Output the month-day using the specified format pattern.     *     * @param pattern  the pattern specification, null means use <code>toString</code>     * @param locale  Locale to use, null means default     * @see org.joda.time.format.DateTimeFormat     */
/**         * Gets the partial that this property belongs to.         *          * @return the partial         */
/**         * Gets the partial that this property belongs to.         *          * @return the partial         */
/**         * Gets the value of this field.         *          * @return the field value         */
/**         * Adds to the value of this field in a copy of this MonthDay.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it will affect larger fields.         * Smaller fields are unaffected.         * <p>         * The MonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the MonthDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to the value of this field in a copy of this MonthDay wrapping         * within this field if the maximum value is reached.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it wraps within this field.         * Other fields are unaffected.         * <p>         * For example,         * <code>--12-30</code> addWrapField one month returns <code>--01-30</code>.         * <p>         * The MonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the MonthDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the MonthDay to a parsed text value.         * <p>         * The MonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @return a copy of the MonthDay with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**     * Returns a new instance with the specified number of months added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to add, may be negative     * @return the new period plus the specified number of months     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of months added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to add, may be negative, null means zero     * @return the new period plus the specified number of months     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of months taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to take away, may be negative     * @return the new period minus the specified number of months     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of months taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to take away, may be negative, null means zero     * @return the new period minus the specified number of months     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the months multiplied by the specified scalar.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param scalar  the amount to multiply by, may be negative     * @return the new period multiplied by the specified scalar     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the months divided by the specified divisor.     * The calculation uses integer division, thus 3 divided by 2 is 1.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param divisor  the amount to divide by, may be negative     * @return the new period divided by the specified divisor     * @throws ArithmeticException if the divisor is zero     */
/**     * Returns a new instance with the months value negated.     *     * @return the new period with a negated value     * @throws ArithmeticException if the result overflows an int     */
/**     * Obtains an instance of <code>Months</code> that may be cached.     * <code>Months</code> is immutable, so instances can be cached and shared.     * This factory method provides access to shared instances.     *     * @param months  the number of months to obtain an instance for     * @return the instance of Months     */
/**     * Creates a <code>Months</code> representing the number of whole months     * between the two specified partial datetimes.     * <p>     * The two partials must contain the same fields, for example you can specify     * two <code>LocalDate</code> objects.     *     * @param start  the start partial date, must not be null     * @param end  the end partial date, must not be null     * @return the period in months     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Creates a <code>Months</code> representing the number of whole months     * in the specified interval. This method corectly handles any daylight     * savings time changes that may occur during the interval.     *     * @param interval  the interval to extract months from, null returns zero     * @return the period in months     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Resolves singletons.     *      * @return the singleton instance     */
/**     * Gets the duration field type, which is <code>months</code>.     *     * @return the period type     */
/**     * Gets the period type, which is <code>months</code>.     *     * @return the period type     */
/**     * Gets the number of months that this period represents.     *     * @return the number of months in the period     */
/**     * Returns a new instance with the specified number of months added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to add, may be negative, null means zero     * @return the new period plus the specified number of months     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of months taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to take away, may be negative, null means zero     * @return the new period minus the specified number of months     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the months multiplied by the specified scalar.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param scalar  the amount to multiply by, may be negative     * @return the new period multiplied by the specified scalar     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the months divided by the specified divisor.     * The calculation uses integer division, thus 3 divided by 2 is 1.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param divisor  the amount to divide by, may be negative     * @return the new period divided by the specified divisor     * @throws ArithmeticException if the divisor is zero     */
/**     * Returns a new instance with the months value negated.     *     * @return the new period with a negated value     * @throws ArithmeticException if the result overflows an int     */
/**     * Is this months instance greater than the specified number of months.     *     * @param other  the other period, null means zero     * @return true if this months instance is greater than the specified one     */
/**     * Is this months instance less than the specified number of months.     *     * @param other  the other period, null means zero     * @return true if this months instance is less than the specified one     */
/**     * Constructs an instance set to the current system millisecond time     * using <code>ISOChronology</code> in the default time zone.     *      * @see #now()     */
/**     * Constructs an instance set to the current system millisecond time     * using <code>ISOChronology</code> in the specified time zone.     * <p>     * If the specified time zone is null, the default zone is used.     *     * @param zone  the time zone, null means default zone     * @see #now(DateTimeZone)     */
/**     * Constructs an instance set to the current system millisecond time     * using the specified chronology.     * <p>     * If the chronology is null, <code>ISOChronology</code>     * in the default time zone is used.     *     * @param chronology  the chronology, null means ISOChronology in default zone     * @see #now(Chronology)     */
/**     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z     * using <code>ISOChronology</code> in the default time zone.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     */
/**     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z     * using <code>ISOChronology</code> in the specified time zone.     * <p>     * If the specified time zone is null, the default zone is used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param zone  the time zone, null means default zone     */
/**     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z     * using the specified chronology.     * <p>     * If the chronology is null, <code>ISOChronology</code>     * in the default time zone is used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param chronology  the chronology, null means ISOChronology in default zone     */
/**     * Constructs an instance from an Object that represents a datetime.     * <p>     * If the object implies a chronology (such as GregorianCalendar does),     * then that chronology will be used. Otherwise, ISO default is used.     * Thus if a GregorianCalendar is passed in, the chronology used will     * be GJ, but if a Date is passed in the chronology will be ISO.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     *     * @param instant  the datetime object, null means now     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs an instance from an Object that represents a datetime,     * forcing the time zone to that specified.     * <p>     * If the object implies a chronology (such as GregorianCalendar does),     * then that chronology will be used, but with the time zone adjusted.     * Otherwise, ISO is used in the specified time zone.     * If the specified time zone is null, the default zone is used.     * Thus if a GregorianCalendar is passed in, the chronology used will     * be GJ, but if a Date is passed in the chronology will be ISO.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     *     * @param instant  the datetime object, null means now     * @param zone  the time zone, null means default time zone     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs an instance from an Object that represents a datetime,     * using the specified chronology.     * <p>     * If the chronology is null, ISO in the default time zone is used.     * Any chronology implied by the object (such as GregorianCalendar does)     * is ignored.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     *     * @param instant  the datetime object, null means now     * @param chronology  the chronology, null means ISOChronology in default zone     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Clone this object without having to cast the returned object.     *     * @return a clone of the this object.     */
/**         * Gets the mutable datetime being used.         *          * @return the mutable datetime         */
/**         * Adds a value to the millis value.         *          * @param value  the value to add         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#add(long,int)         */
/**         * Adds a value to the millis value.         *          * @param value  the value to add         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#add(long,long)         */
/**         * Adds a value, possibly wrapped, to the millis value.         *          * @param value  the value to add         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#addWrapField         */
/**         * Sets a value.         *          * @param value  the value to set.         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#set(long,int)         */
/**         * Sets a text value.         *          * @param text  the text value to set         * @param locale  optional locale to use for selecting a text symbol         * @return the mutable datetime being used, so calls can be chained         * @throws IllegalArgumentException if the text value isn't valid         * @see DateTimeField#set(long,java.lang.String,java.util.Locale)         */
/**         * Sets a text value.         *          * @param text  the text value to set         * @return the mutable datetime being used, so calls can be chained         * @throws IllegalArgumentException if the text value isn't valid         * @see DateTimeField#set(long,java.lang.String)         */
/**         * Round to the lowest whole unit of this field.         *         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#roundFloor         */
/**         * Round to the highest whole unit of this field.         *         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#roundCeiling         */
/**         * Round to the nearest whole unit of this field, favoring the floor if         * halfway.         *         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#roundHalfFloor         */
/**         * Round to the nearest whole unit of this field, favoring the ceiling if         * halfway.         *         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#roundHalfCeiling         */
/**         * Round to the nearest whole unit of this field. If halfway, the ceiling         * is favored over the floor only if it makes this field's value even.         *         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#roundHalfEven         */
/**     * Obtains a {@code MutableDateTime} set to the current system millisecond time     * using the specified chronology.     *     * @param chronology  the chronology, not null     * @return the current date-time, not null     * @since 2.0     */
/**     * Parses a {@code MutableDateTime} from the specified string using a formatter.     *      * @param str  the string to parse, not null     * @param formatter  the formatter to use, not null     * @since 2.0     */
/**     * Gets the field used for rounding this instant, returning null if rounding     * is not enabled.     *      * @return the rounding field     */
/**     * Gets the rounding mode for this instant, returning ROUND_NONE if rounding     * is not enabled.     *      * @return the rounding mode constant     */
/**     * Sets the status of rounding to use the specified field and mode.     * A null field or mode of ROUND_NONE will disable rounding.     * Once set, the instant is then rounded using the new field and mode.     * <p>     * Enabling rounding will cause all subsequent calls to {@link #setMillis(long)}     * to be rounded. This can be used to control the precision of the instant,     * for example by setting a rounding field of minuteOfDay, the seconds and     * milliseconds will always be zero.     *     * @param field  rounding field or null to disable     * @param mode  rounding mode or ROUND_NONE to disable     * @throws IllegalArgumentException if mode is unknown, no exception if field is null     */
/**     * Sets the millisecond instant of this instant from another.     * <p>     * This method does not change the chronology of this instant, just the     * millisecond instant.     *      * @param instant  the instant to use, null means now     */
/**         * Adds a value to the millis value.         *          * @param value  the value to add         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#add(long,long)         */
/**     * Set the chronology of the datetime.     * <p>     * All changes to the chronology occur via this method.     *      * @param chronology  the chronology to use, null means ISOChronology in default zone     */
/**     * Sets the time zone of the datetime, changing the chronology and field values.     * <p>     * Changing the zone using this method retains the millisecond instant.     * The millisecond instant is adjusted in the new zone to compensate.     *      * chronology. Setting the time zone does not affect the millisecond value     * of this instant.     * <p>     * If the chronology already has this time zone, no change occurs.     *     * @param newZone  the time zone to use, null means default zone     * @see #setZoneRetainFields     */
/**     * Sets the time zone of the datetime, changing the chronology and millisecond.     * <p>     * Changing the zone using this method retains the field values.     * The millisecond instant is adjusted in the new zone to compensate.     * <p>     * If the chronology already has this time zone, no change occurs.     *     * @param newZone  the time zone to use, null means default zone     * @see #setZone     */
/**         * Sets a text value.         *          * @param text  the text value to set         * @return the mutable datetime being used, so calls can be chained         * @throws IllegalArgumentException if the text value isn't valid         * @see DateTimeField#set(long,java.lang.String)         */
/**     * Set the year to the specified value.     *     * @param year  the year     * @throws IllegalArgumentException if the value is invalid     */
/**     * Add a number of years to the date.     *     * @param years  the years to add     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the weekyear to the specified value.     *     * @param weekyear  the weekyear     * @throws IllegalArgumentException if the value is invalid     */
/**     * Add a number of weekyears to the date.     *     * @param weekyears  the weekyears to add     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the month of the year to the specified value.     *     * @param monthOfYear  the month of the year     * @throws IllegalArgumentException if the value is invalid     */
/**     * Add a number of months to the date.     *     * @param months  the months to add     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the week of weekyear to the specified value.     *     * @param weekOfWeekyear the week of the weekyear     * @throws IllegalArgumentException if the value is invalid     */
/**     * Add a number of weeks to the date.     *     * @param weeks  the weeks to add     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the day of year to the specified value.     *     * @param dayOfYear the day of the year     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the day of the month to the specified value.     *     * @param dayOfMonth  the day of the month     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the day of week to the specified value.     *     * @param dayOfWeek  the day of the week     * @throws IllegalArgumentException if the value is invalid     */
/**     * Add a number of days to the date.     *     * @param days  the days to add     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the hour of the day to the specified value.     *     * @param hourOfDay  the hour of day     * @throws IllegalArgumentException if the value is invalid     */
/**     * Add a number of hours to the date.     *     * @param hours  the hours to add     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the minute of the day to the specified value.     *     * @param minuteOfDay  the minute of day     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the minute of the hour to the specified value.     *     * @param minuteOfHour  the minute of hour     * @throws IllegalArgumentException if the value is invalid     */
/**     * Add a number of minutes to the date.     *     * @param minutes  the minutes to add     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the second of the day to the specified value.     *     * @param secondOfDay  the second of day     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the second of the minute to the specified value.     *     * @param secondOfMinute  the second of minute     * @throws IllegalArgumentException if the value is invalid     */
/**     * Add a number of seconds to the date.     *     * @param seconds  the seconds to add     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the millis of the day to the specified value.     *     * @param millisOfDay  the millis of day     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the millis of the second to the specified value.     *     * @param millisOfSecond  the millis of second     * @throws IllegalArgumentException if the value is invalid     */
/**     * Add a number of milliseconds to the date. The implementation of this     * method differs from the {@link #add(long)} method in that a     * DateTimeField performs the addition.     *     * @param millis  the milliseconds to add     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the date from fields.     * The time part of this object will be unaffected.     *     * @param year  the year     * @param monthOfYear  the month of the year     * @param dayOfMonth  the day of the month     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the time from fields.     * The date part of this object will be unaffected.     *     * @param hour  the hour     * @param minuteOfHour  the minute of the hour     * @param secondOfMinute  the second of the minute     * @param millisOfSecond  the millisecond of the second     * @throws IllegalArgumentException if the value is invalid     */
/**     * Set the date and time from fields.     *     * @param year  the year     * @param monthOfYear  the month of the year     * @param dayOfMonth  the day of the month     * @param hourOfDay  the hour of the day     * @param minuteOfHour  the minute of the hour     * @param secondOfMinute  the second of the minute     * @param millisOfSecond  the millisecond of the second     * @throws IllegalArgumentException if the value is invalid     */
/**     * Gets the property object for the specified type, which contains many useful methods.     *     * @param type  the field type to get the chronology for     * @return the property object     * @throws IllegalArgumentException if the field is null or unsupported     * @since 1.2     */
/**     * Get the era property.     *      * @return the era property     */
/**     * Get the century of era property.     *      * @return the year of era property     */
/**     * Get the year of century property.     *      * @return the year of era property     */
/**     * Get the year of era property.     *      * @return the year of era property     */
/**     * Get the year property.     *      * @return the year property     */
/**     * Get the year of a week based year property.     *      * @return the year of a week based year property     */
/**     * Get the month of year property.     *      * @return the month of year property     */
/**     * Get the week of a week based year property.     *      * @return the week of a week based year property     */
/**     * Get the day of year property.     *      * @return the day of year property     */
/**     * Get the day of month property.     * <p>     * The values for day of month are defined in {@link DateTimeConstants}.     *      * @return the day of month property     */
/**     * Get the day of week property.     * <p>     * The values for day of week are defined in {@link DateTimeConstants}.     *      * @return the day of week property     */
/**     * Get the hour of day field property     *      * @return the hour of day property     */
/**     * Get the minute of day property     *      * @return the minute of day property     */
/**     * Get the minute of hour field property     *      * @return the minute of hour property     */
/**     * Get the second of day property     *      * @return the second of day property     */
/**     * Get the second of minute field property     *      * @return the second of minute property     */
/**     * Get the millis of day property     *      * @return the millis of day property     */
/**     * Get the millis of second property     *      * @return the millis of second property     */
/**     * Clone this object without having to cast the returned object.     *     * @return a clone of the this object.     */
/**     * Clone this object.     *     * @return a clone of this object.     */
/**         * Reads the property from a safe serialization format.         */
/**         * Gets the mutable datetime being used.         *          * @return the mutable datetime         */
/**         * Adds a value, possibly wrapped, to the millis value.         *          * @param value  the value to add         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#addWrapField         */
/**         * Round to the lowest whole unit of this field.         *         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#roundFloor         */
/**         * Round to the highest whole unit of this field.         *         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#roundCeiling         */
/**         * Round to the nearest whole unit of this field, favoring the floor if         * halfway.         *         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#roundHalfFloor         */
/**         * Round to the nearest whole unit of this field, favoring the ceiling if         * halfway.         *         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#roundHalfCeiling         */
/**         * Round to the nearest whole unit of this field. If halfway, the ceiling         * is favored over the floor only if it makes this field's value even.         *         * @return the mutable datetime being used, so calls can be chained         * @see DateTimeField#roundHalfEven         */
/**     * Constructs a zero length time interval from 1970-01-01 to 1970-01-01.     */
/**     * Constructs an interval from a start and end instant with the ISO default chronology.     *      * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.     * @throws IllegalArgumentException if the end is before the start     */
/**     * Constructs an interval from a start and end instant with a chronology.     *      * @param chronology  the chronology to use, null is ISO default     * @param startInstant  start of this interval, as milliseconds from 1970-01-01T00:00:00Z.     * @param endInstant  end of this interval, as milliseconds from 1970-01-01T00:00:00Z.     * @throws IllegalArgumentException if the end is before the start     */
/**     * Constructs an interval from a start and end instant.     * <p>     * The chronology used is that of the start instant.     *      * @param start  start of this interval, null means now     * @param end  end of this interval, null means now     * @throws IllegalArgumentException if the end is before the start     */
/**     * Constructs an interval from a start instant and a duration.     *      * @param start  start of this interval, null means now     * @param duration  the duration of this interval, null means zero length     * @throws IllegalArgumentException if the end is before the start     * @throws ArithmeticException if the end instant exceeds the capacity of a long     */
/**     * Constructs an interval from a millisecond duration and an end instant.     *      * @param duration  the duration of this interval, null means zero length     * @param end  end of this interval, null means now     * @throws IllegalArgumentException if the end is before the start     * @throws ArithmeticException if the start instant exceeds the capacity of a long     */
/**     * Constructs an interval from a start instant and a time period.     * <p>     * When forming the interval, the chronology from the instant is used     * if present, otherwise the chronology of the period is used.     *      * @param start  start of this interval, null means now     * @param period  the period of this interval, null means zero length     * @throws IllegalArgumentException if the end is before the start     * @throws ArithmeticException if the end instant exceeds the capacity of a long     */
/**     * Constructs an interval from a time period and an end instant.     * <p>     * When forming the interval, the chronology from the instant is used     * if present, otherwise the chronology of the period is used.     *      * @param period  the period of this interval, null means zero length     * @param end  end of this interval, null means now     * @throws IllegalArgumentException if the end is before the start     * @throws ArithmeticException if the start instant exceeds the capacity of a long     */
/**     * Constructs a time interval by converting or copying from another object.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInterval and String.     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',     * 'datetime/period' or 'period/datetime'.     *      * @param interval  the time interval to copy     * @throws IllegalArgumentException if the interval is invalid     */
/**     * Constructs a time interval by converting or copying from another object,     * overriding the chronology.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInterval and String.     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',     * 'datetime/period' or 'period/datetime'.     *      * @param interval  the time interval to copy     * @param chronology  the chronology to use, null means ISO default     * @throws IllegalArgumentException if the interval is invalid     */
/**     * Clone this object without having to cast the returned object.     *     * @return a clone of the this object.     */
/**     * Parses a {@code MutableInterval} from the specified string.     * <p>     * The String formats are described by {@link ISODateTimeFormat#dateTimeParser()}     * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',     * 'datetime/period' or 'period/datetime'.     *      * @param str  the string to parse, not null     * @since 2.0     */
/**     * Sets this interval from two instants, replacing the chronology with     * that from the start instant.     *     * @param start  the start of the time interval     * @param end  the start of the time interval     * @throws IllegalArgumentException if the end is before the start     */
/**     * Sets the chronology of this time interval.     *     * @param chrono  the chronology to use, null means ISO default     */
/**     * Sets the start of this time interval.     *     * @param startInstant  the start of the time interval,     *  millisecond instant from 1970-01-01T00:00:00Z     * @throws IllegalArgumentException if the end is before the start     */
/**     * Sets the start of this time interval as an Instant.     *     * @param start  the start of the time interval, null means now     * @throws IllegalArgumentException if the end is before the start     */
/**      * Sets the end of this time interval.     *     * @param endInstant  the end of the time interval,     *  millisecond instant from 1970-01-01T00:00:00Z     * @throws IllegalArgumentException if the end is before the start     */
/**      * Sets the end of this time interval as an Instant.     *     * @param end  the end of the time interval, null means now     * @throws IllegalArgumentException if the end is before the start     */
/**     * Sets the duration of this time interval, preserving the start instant.     *     * @param duration  new duration for interval, null means zero length     * @throws IllegalArgumentException if the end is before the start     * @throws ArithmeticException if the end instant exceeds the capacity of a long     */
/**     * Sets the duration of this time interval, preserving the end instant.     *     * @param duration  new duration for interval, null means zero length     * @throws IllegalArgumentException if the end is before the start     * @throws ArithmeticException if the start instant exceeds the capacity of a long     */
/**     * Sets the period of this time interval, preserving the start instant     * and using the ISOChronology in the default zone for calculations.     *     * @param period  new period for interval, null means zero length     * @throws IllegalArgumentException if the end is before the start     * @throws ArithmeticException if the end instant exceeds the capacity of a long     */
/**     * Sets the period of this time interval, preserving the end instant     * and using the ISOChronology in the default zone for calculations.     *     * @param period  new period for interval, null means zero length     * @throws IllegalArgumentException if the end is before the start     * @throws ArithmeticException if the start instant exceeds the capacity of a long     */
/**     * Clone this object without having to cast the returned object.     *     * @return a clone of the this object.     */
/**     * Creates a zero-length period using the standard period type.     */
/**     * Creates a zero-length period using the specified period type.     *     * @param type  which set of fields this period supports     */
/**     * Create a period from a set of field values using the standard set of fields.     *     * @param hours  amount of hours in this period     * @param minutes  amount of minutes in this period     * @param seconds  amount of seconds in this period     * @param millis  amount of milliseconds in this period     */
/**     * Create a period from a set of field values using the standard set of fields.     *     * @param years  amount of years in this period     * @param months  amount of months in this period     * @param weeks  amount of weeks in this period     * @param days  amount of days in this period     * @param hours  amount of hours in this period     * @param minutes  amount of minutes in this period     * @param seconds  amount of seconds in this period     * @param millis  amount of milliseconds in this period     */
/**     * Creates a period from the given millisecond duration using the standard     * set of fields.     * <p>     * Only precise fields in the period type will be used.     * For the standard period type this is the time fields only.     * Thus the year, month, week and day fields will not be populated.     * <p>     * If the duration is small, less than one day, then this method will perform     * as you might expect and split the fields evenly.     * <p>     * If the duration is larger than one day then all the remaining duration will     * be stored in the largest available precise field, hours in this case.     * <p>     * For example, a duration equal to (365 + 60 + 5) days will be converted to     * ((365 + 60 + 5) * 24) hours by this constructor.     * <p>     * For more control over the conversion process, you have two options:     * <ul>     * <li>convert the duration to an {@link Interval}, and from there obtain the period     * <li>specify a period type that contains precise definitions of the day and larger     * fields, such as the UTC or precise types.     * </ul>     *     * @param duration  the duration, in milliseconds     */
/**     * Creates a period from the given millisecond duration.     * <p>     * Only precise fields in the period type will be used.     * Imprecise fields will not be populated.     * <p>     * If the duration is small then this method will perform     * as you might expect and split the fields evenly.     * <p>     * If the duration is large then all the remaining duration will     * be stored in the largest available precise field.     * For details as to which fields are precise, review the period type javadoc.     *     * @param duration  the duration, in milliseconds     * @param type  which set of fields this period supports, null means standard     */
/**     * Creates a period from the given millisecond duration using the standard     * set of fields.     * <p>     * Only precise fields in the period type will be used.     * Imprecise fields will not be populated.     * <p>     * If the duration is small then this method will perform     * as you might expect and split the fields evenly.     * <p>     * If the duration is large then all the remaining duration will     * be stored in the largest available precise field.     * For details as to which fields are precise, review the period type javadoc.     *     * @param duration  the duration, in milliseconds     * @param chronology  the chronology to use to split the duration, null means ISO default     */
/**     * Creates a period from the given millisecond duration.     * <p>     * Only precise fields in the period type will be used.     * Imprecise fields will not be populated.     * <p>     * If the duration is small then this method will perform     * as you might expect and split the fields evenly.     * <p>     * If the duration is large then all the remaining duration will     * be stored in the largest available precise field.     * For details as to which fields are precise, review the period type javadoc.     *     * @param duration  the duration, in milliseconds     * @param type  which set of fields this period supports, null means standard     * @param chronology  the chronology to use to split the duration, null means ISO default     */
/**     * Creates a period from the given interval endpoints using the standard     * set of fields.     *     * @param startInstant  interval start, in milliseconds     * @param endInstant  interval end, in milliseconds     */
/**     * Creates a period from the given interval endpoints.     *     * @param startInstant  interval start, in milliseconds     * @param endInstant  interval end, in milliseconds     * @param type  which set of fields this period supports, null means standard     */
/**     * Creates a period from the given interval endpoints using the standard     * set of fields.     *     * @param startInstant  interval start, in milliseconds     * @param endInstant  interval end, in milliseconds     * @param chrono  the chronology to use, null means ISO in default zone     */
/**     * Creates a period from the given interval endpoints.     *     * @param startInstant  interval start, in milliseconds     * @param endInstant  interval end, in milliseconds     * @param type  which set of fields this period supports, null means standard     * @param chrono  the chronology to use, null means ISO in default zone     */
/**     * Creates a period from the given interval endpoints using the standard     * set of fields.     * <p>     * The chronology of the start instant is used, unless that is null when the     * chronology of the end instant is used instead.     *     * @param startInstant  interval start, null means now     * @param endInstant  interval end, null means now     */
/**     * Creates a period from the given interval endpoints.     * <p>     * The chronology of the start instant is used, unless that is null when the     * chronology of the end instant is used instead.     *     * @param startInstant  interval start, null means now     * @param endInstant  interval end, null means now     * @param type  which set of fields this period supports, null means AllType     */
/**     * Creates a period from the given start point and the duration.     *     * @param startInstant  the interval start, null means now     * @param duration  the duration of the interval, null means zero-length     */
/**     * Creates a period from the given start point and the duration.     *     * @param startInstant  the interval start, null means now     * @param duration  the duration of the interval, null means zero-length     * @param type  which set of fields this period supports, null means standard     */
/**     * Creates a period from the given duration and end point.     *     * @param duration  the duration of the interval, null means zero-length     * @param endInstant  the interval end, null means now     */
/**     * Creates a period from the given duration and end point.     *     * @param duration  the duration of the interval, null means zero-length     * @param endInstant  the interval end, null means now     * @param type  which set of fields this period supports, null means standard     */
/**     * Creates a period by converting or copying from another object.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePeriod, ReadableInterval and String.     * The String formats are described by {@link ISOPeriodFormat#standard()}.     *     * @param period  period to convert     * @throws IllegalArgumentException if period is invalid     * @throws UnsupportedOperationException if an unsupported field's value is non-zero     */
/**     * Creates a period by converting or copying from another object.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePeriod, ReadableInterval and String.     * The String formats are described by {@link ISOPeriodFormat#standard()}.     *     * @param period  period to convert     * @param type  which set of fields this period supports, null means use converter     * @throws IllegalArgumentException if period is invalid     * @throws UnsupportedOperationException if an unsupported field's value is non-zero     */
/**     * Creates a period by converting or copying from another object.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePeriod, ReadableInterval and String.     * The String formats are described by {@link ISOPeriodFormat#standard()}.     *     * @param period  period to convert     * @param chrono  the chronology to use, null means ISO in default zone     * @throws IllegalArgumentException if period is invalid     * @throws UnsupportedOperationException if an unsupported field's value is non-zero     */
/**     * Creates a period by converting or copying from another object.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePeriod, ReadableInterval and String.     * The String formats are described by {@link ISOPeriodFormat#standard()}.     *     * @param period  period to convert     * @param type  which set of fields this period supports, null means use converter     * @param chrono  the chronology to use, null means ISO in default zone     * @throws IllegalArgumentException if period is invalid     * @throws UnsupportedOperationException if an unsupported field's value is non-zero     */
/**     * Clone this object without having to cast the returned object.     *     * @return a clone of the this object.     */
/**     * Parses a {@code MutablePeriod} from the specified string using a formatter.     *      * @param str  the string to parse, not null     * @param formatter  the formatter to use, not null     * @since 2.0     */
/**     * Clears the period, setting all values back to zero.     */
/**     * Sets the value of one of the fields by index.     *     * @param index  the field index     * @param value  the new value for the field     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Sets the value of one of the fields.     * <p>     * The field type specified must be one of those that is supported by the period.     *     * @param field  a DurationFieldType instance that is supported by this period, not null     * @param value  the new value for the field     * @throws IllegalArgumentException if the field is null or not supported     */
/**     * Sets all the fields in one go from a millisecond duration.     * <p>     * When dividing the duration, only precise fields in the period type will be used.     * For large durations, all the remaining duration will be stored in the largest     * available precise field.     *      * @param duration  the duration, in milliseconds     * @param chrono  the chronology to use, null means ISO chronology     * @throws ArithmeticException if the set exceeds the capacity of the period     */
/**     * Adds a millisecond duration to this one by dividing the duration into     * fields and calling {@link #add(ReadablePeriod)}.     * <p>     * When dividing the duration, only precise fields in the period type will be used.     * For large durations, all the remaining duration will be stored in the largest     * available precise field.     *      * @param duration  the duration, in milliseconds     * @param chrono  the chronology to use, null means ISO default     * @throws ArithmeticException if the addition exceeds the capacity of the period     */
/**     * Merges all the fields from the specified period into this one.     * <p>     * Fields that are not present in the specified period are left unaltered.     *      * @param period  the period to set, null ignored     * @throws IllegalArgumentException if an unsupported field's value is non-zero     */
/**     * Gets the years field part of the period.     *      * @return the number of years in the period, zero if unsupported     */
/**     * Gets the months field part of the period.     *      * @return the number of months in the period, zero if unsupported     */
/**     * Gets the weeks field part of the period.     *      * @return the number of weeks in the period, zero if unsupported     */
/**     * Gets the days field part of the period.     *      * @return the number of days in the period, zero if unsupported     */
/**     * Gets the hours field part of the period.     *      * @return the number of hours in the period, zero if unsupported     */
/**     * Gets the minutes field part of the period.     *      * @return the number of minutes in the period, zero if unsupported     */
/**     * Gets the seconds field part of the period.     *      * @return the number of seconds in the period, zero if unsupported     */
/**     * Gets the millis field part of the period.     *      * @return the number of millis in the period, zero if unsupported     */
/**     * Sets the number of years of the period.     *      * @param years  the number of years     * @throws IllegalArgumentException if field is not supported and the value is non-zero     */
/**     * Adds the specified years to the number of years in the period.     *      * @param years  the number of years     * @throws IllegalArgumentException if field is not supported and the value is non-zero     * @throws ArithmeticException if the addition exceeds the capacity of the period     */
/**     * Sets the number of months of the period.     *      * @param months  the number of months     * @throws IllegalArgumentException if field is not supported and the value is non-zero     */
/**     * Adds the specified months to the number of months in the period.     *      * @param months  the number of months     * @throws IllegalArgumentException if field is not supported and the value is non-zero     * @throws ArithmeticException if the addition exceeds the capacity of the period     */
/**     * Sets the number of weeks of the period.     *      * @param weeks  the number of weeks     * @throws IllegalArgumentException if field is not supported and the value is non-zero     */
/**     * Adds the specified weeks to the number of weeks in the period.     *      * @param weeks  the number of weeks     * @throws IllegalArgumentException if field is not supported and the value is non-zero     * @throws ArithmeticException if the addition exceeds the capacity of the period     */
/**     * Sets the number of days of the period.     *      * @param days  the number of days     * @throws IllegalArgumentException if field is not supported and the value is non-zero     */
/**     * Adds the specified days to the number of days in the period.     *      * @param days  the number of days     * @throws IllegalArgumentException if field is not supported and the value is non-zero     * @throws ArithmeticException if the addition exceeds the capacity of the period     */
/**     * Sets the number of hours of the period.     *      * @param hours  the number of hours     * @throws IllegalArgumentException if field is not supported and the value is non-zero     */
/**     * Adds the specified hours to the number of hours in the period.     *      * @param hours  the number of hours     * @throws IllegalArgumentException if field is not supported and the value is non-zero     * @throws ArithmeticException if the addition exceeds the capacity of the period     */
/**     * Sets the number of minutes of the period.     *      * @param minutes  the number of minutes     * @throws IllegalArgumentException if field is not supported and the value is non-zero     */
/**     * Adds the specified minutes to the number of minutes in the period.     *      * @param minutes  the number of minutes     * @throws IllegalArgumentException if field is not supported and the value is non-zero     * @throws ArithmeticException if the addition exceeds the capacity of the period     */
/**     * Sets the number of seconds of the period.     *      * @param seconds  the number of seconds     * @throws IllegalArgumentException if field is not supported and the value is non-zero     */
/**     * Adds the specified seconds to the number of seconds in the period.     *      * @param seconds  the number of seconds     * @throws IllegalArgumentException if field is not supported and the value is non-zero     * @throws ArithmeticException if the addition exceeds the capacity of the period     */
/**     * Sets the number of millis of the period.     *      * @param millis  the number of millis     * @throws IllegalArgumentException if field is not supported and the value is non-zero     */
/**     * Adds the specified millis to the number of millis in the period.     *      * @param millis  the number of millis     * @throws IllegalArgumentException if field is not supported and the value is non-zero     * @throws ArithmeticException if the addition exceeds the capacity of the period     */
/**     * Clone this object without having to cast the returned object.     *     * @return a clone of the this object.     */
/**     * Constructs a Partial with no fields or values, which can be considered     * to represent any date.     * <p>     * This is most useful when constructing partials, for example:     * <pre>     * Partial p = new Partial()     *     .with(DateTimeFieldType.dayOfWeek(), 5)     *     .with(DateTimeFieldType.hourOfDay(), 12)     *     .with(DateTimeFieldType.minuteOfHour(), 20);     * </pre>     * Note that, although this is a clean way to write code, it is fairly     * inefficient internally.     * <p>     * The constructor uses the default ISO chronology.     */
/**     * Constructs a Partial with no fields or values, which can be considered     * to represent any date.     * <p>     * This is most useful when constructing partials, for example:     * <pre>     * Partial p = new Partial(chrono)     *     .with(DateTimeFieldType.dayOfWeek(), 5)     *     .with(DateTimeFieldType.hourOfDay(), 12)     *     .with(DateTimeFieldType.minuteOfHour(), 20);     * </pre>     * Note that, although this is a clean way to write code, it is fairly     * inefficient internally.     *     * @param chrono  the chronology, null means ISO     */
/**     * Constructs a Partial with the specified field and value.     * <p>     * The constructor uses the default ISO chronology.     *      * @param type  the single type to create the partial from, not null     * @param value  the value to store     * @throws IllegalArgumentException if the type or value is invalid     */
/**     * Constructs a Partial with the specified field and value.     * <p>     * The constructor uses the specified chronology.     *      * @param type  the single type to create the partial from, not null     * @param value  the value to store     * @param chronology  the chronology, null means ISO     * @throws IllegalArgumentException if the type or value is invalid     */
/**     * Constructs a Partial with the specified fields and values.     * The fields must be specified in the order largest to smallest.     * <p>     * The constructor uses the specified chronology.     *      * @param types  the types to create the partial from, not null     * @param values  the values to store, not null     * @throws IllegalArgumentException if the types or values are invalid     */
/**     * Constructs a Partial with the specified fields and values.     * The fields must be specified in the order largest to smallest.     * <p>     * The constructor uses the specified chronology.     *      * @param types  the types to create the partial from, not null     * @param values  the values to store, not null     * @param chronology  the chronology, null means ISO     * @throws IllegalArgumentException if the types or values are invalid     */
/**     * Constructs a Partial by copying all the fields and types from     * another partial.     * <p>     * This is most useful when copying from a YearMonthDay or TimeOfDay.     */
/**     * Creates a new Partial instance with the specified chronology.     * This instance is immutable and unaffected by this method call.     * <p>     * This method retains the values of the fields, thus the result will     * typically refer to a different instant.     * <p>     * The time zone of the specified chronology is ignored, as Partial     * operates without a time zone.     *     * @param newChronology  the new chronology, null means ISO     * @return a copy of this datetime with a different chronology     * @throws IllegalArgumentException if the values are invalid for the new chronology     */
/**     * Gets a copy of this date with the specified field set to a new value.     * <p>     * If this partial did not previously support the field, the new one will.     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.     * <p>     * For example, if the field type is <code>dayOfMonth</code> then the day     * would be changed/added in the returned instance.     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this instance with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Gets a copy of this date with the specified field removed.     * <p>     * If this partial did not previously support the field, no error occurs.     *     * @param fieldType  the field type to remove, may be null     * @return a copy of this instance with the field removed     */
/**     * Gets a copy of this Partial with the specified field set to a new value.     * <p>     * If this partial does not support the field, an exception is thrown.     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.     * <p>     * For example, if the field type is <code>dayOfMonth</code> then the day     * would be changed in the returned instance if supported.     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this instance with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Gets a copy of this Partial with the value of the specified field increased.     * If this partial does not support the field, an exception is thrown.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * The addition will overflow into larger fields (eg. minute to hour).     * However, it will not wrap around if the top maximum is reached.     *     * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this instance with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new datetime exceeds the capacity     */
/**     * Gets a copy of this Partial with the value of the specified field increased.     * If this partial does not support the field, an exception is thrown.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * The addition will overflow into larger fields (eg. minute to hour).     * If the maximum is reached, the addition will wra.     *     * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this instance with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new datetime exceeds the capacity     */
/**     * Gets a copy of this Partial with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * Fields in the period that aren't present in the partial are ignored.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using the method     * {@link #withFieldAdded(DurationFieldType, int)}.     *      * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this instance with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity     */
/**     * Gets a copy of this instance with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *     * @param period  the duration to add to this one, null means zero     * @return a copy of this instance with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Gets a copy of this instance with the specified period take away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *     * @param period  the period to reduce this instant by     * @return a copy of this instance with the period taken away     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**         * Gets the partial that this property belongs to.         *          * @return the partial         */
/**         * Adds to the value of this field in a copy of this Partial.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it will affect larger fields.         * Smaller fields are unaffected.         * <p>         * If the result would be too large, beyond the maximum year, then an         * IllegalArgumentException is thrown.         * <p>         * The Partial attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the Partial with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to the value of this field in a copy of this Partial wrapping         * within this field if the maximum value is reached.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it wraps within this field.         * Other fields are unaffected.         * <p>         * For example,         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.         * <p>         * The Partial attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the Partial with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the Partial.         * <p>         * The Partial attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param value  the value to set the field in the copy to         * @return a copy of the Partial with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the Partial to a parsed text value.         * <p>         * The Partial attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @param locale  optional locale to use for selecting a text symbol         * @return a copy of the Partial with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Sets this field in a copy of the Partial to a parsed text value.         * <p>         * The Partial attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @return a copy of the Partial with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new Partial with this field set to the maximum value         * for this field.         * <p>         * The Partial attached to this property is unchanged by this call.         *         * @return a copy of the Partial with this field set to its maximum         * @since 1.2         */
/**         * Returns a new Partial with this field set to the minimum value         * for this field.         * <p>         * The Partial attached to this property is unchanged by this call.         *         * @return a copy of the Partial with this field set to its minimum         * @since 1.2         */
/**     * Gets the number of fields in this partial.     *      * @return the field count     */
/**     * Gets the chronology of the partial which is never null.     * <p>     * The {@link Chronology} is the calculation engine behind the partial and     * provides conversion and validation of the fields in a particular calendar system.     *      * @return the chronology, never null     */
/**         * Gets the field that this property uses.         *          * @return the field         */
/**     * Gets the field type at the specified index.     *     * @param index  the index to retrieve     * @return the field at the specified index     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Gets an array of the field type of each of the fields that     * this partial supports.     * <p>     * The fields are returned largest to smallest.     *     * @return the array of field types (cloned), largest to smallest     */
/**     * Gets the value of the field at the specifed index.     *      * @param index  the index     * @return the value     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Gets an array of the value of each of the fields that     * this partial supports.     * <p>     * The fields are returned largest to smallest.     * Each value corresponds to the same array index as <code>getFieldTypes()</code>     *     * @return the current values of each field (cloned), largest to smallest     */
/**     * Creates a new Partial instance with the specified chronology.     * This instance is immutable and unaffected by this method call.     * <p>     * This method retains the values of the fields, thus the result will     * typically refer to a different instant.     * <p>     * The time zone of the specified chronology is ignored, as Partial     * operates without a time zone.     *     * @param newChronology  the new chronology, null means ISO     * @return a copy of this datetime with a different chronology     * @throws IllegalArgumentException if the values are invalid for the new chronology     */
/**     * Gets a copy of this date with the specified field set to a new value.     * <p>     * If this partial did not previously support the field, the new one will.     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.     * <p>     * For example, if the field type is <code>dayOfMonth</code> then the day     * would be changed/added in the returned instance.     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this instance with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Gets a copy of this date with the specified field removed.     * <p>     * If this partial did not previously support the field, no error occurs.     *     * @param fieldType  the field type to remove, may be null     * @return a copy of this instance with the field removed     */
/**     * Gets a copy of this Partial with the specified field set to a new value.     * <p>     * If this partial does not support the field, an exception is thrown.     * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.     * <p>     * For example, if the field type is <code>dayOfMonth</code> then the day     * would be changed in the returned instance if supported.     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this instance with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Gets a copy of this Partial with the value of the specified field increased.     * If this partial does not support the field, an exception is thrown.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * The addition will overflow into larger fields (eg. minute to hour).     * However, it will not wrap around if the top maximum is reached.     *     * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this instance with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new datetime exceeds the capacity     */
/**     * Gets a copy of this Partial with the value of the specified field increased.     * If this partial does not support the field, an exception is thrown.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * The addition will overflow into larger fields (eg. minute to hour).     * If the maximum is reached, the addition will wra.     *     * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this instance with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new datetime exceeds the capacity     */
/**     * Gets a copy of this Partial with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * Fields in the period that aren't present in the partial are ignored.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using the method     * {@link #withFieldAdded(DurationFieldType, int)}.     *      * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this instance with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity     */
/**     * Gets a copy of this instance with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *     * @param period  the duration to add to this one, null means zero     * @return a copy of this instance with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Gets a copy of this instance with the specified period take away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     *     * @param period  the period to reduce this instant by     * @return a copy of this instance with the period taken away     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Gets the property object for the specified type, which contains     * many useful methods for getting and manipulating the partial.     * <p>     * See also {@link ReadablePartial#get(DateTimeFieldType)}.     *     * @param type  the field type to get the property for, not null     * @return the property object     * @throws IllegalArgumentException if the field is null or unsupported     */
/**     * Does this partial match the specified partial.     * <p>     * A match occurs when all the fields of this partial are the same as the     * corresponding fields on the specified partial.     *     * @param partial  a partial to check against, must not be null     * @return true if this partial matches the specified partial     * @throws IllegalArgumentException if the partial is null     * @throws IllegalArgumentException if the fields of the two partials do not match     * @since 1.5     */
/**     * Gets a formatter suitable for the fields in this partial.     * <p>     * If there is no appropriate ISO format, null is returned.     * This method may return a formatter that does not display all the     * fields of the partial. This might occur when you have overlapping     * fields, such as dayOfWeek and dayOfMonth.     *     * @return a formatter suitable for the fields in this partial, null     *  if none is suitable     */
/**     * Output the date using the specified format pattern.     * Unsupported fields will appear as special unicode characters.     *     * @param pattern  the pattern specification, null means use <code>toString</code>     * @param locale  Locale to use, null means default     * @see org.joda.time.format.DateTimeFormat     */
/**     * Gets a string version of the partial that lists all the fields.     * <p>     * This method exists to provide a better debugging toString than     * the standard toString. This method lists all the fields and their     * values in a style similar to the collections framework.     *     * @return a toString format that lists all the fields     */
/**         * Gets the partial that this property belongs to.         *          * @return the partial         */
/**         * Gets the partial that this property belongs to.         *          * @return the partial         */
/**         * Gets the value of this field.         *          * @return the field value         */
/**         * Adds to the value of this field in a copy of this Partial.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it will affect larger fields.         * Smaller fields are unaffected.         * <p>         * If the result would be too large, beyond the maximum year, then an         * IllegalArgumentException is thrown.         * <p>         * The Partial attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the Partial with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to the value of this field in a copy of this Partial wrapping         * within this field if the maximum value is reached.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it wraps within this field.         * Other fields are unaffected.         * <p>         * For example,         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.         * <p>         * The Partial attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the Partial with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the Partial to a parsed text value.         * <p>         * The Partial attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @return a copy of the Partial with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new Partial with this field set to the maximum value         * for this field.         * <p>         * The Partial attached to this property is unchanged by this call.         *         * @return a copy of the Partial with this field set to its maximum         * @since 1.2         */
/**         * Returns a new Partial with this field set to the minimum value         * for this field.         * <p>         * The Partial attached to this property is unchanged by this call.         *         * @return a copy of the Partial with this field set to its minimum         * @since 1.2         */
/**     * Creates a new empty period with the standard set of fields.     * <p>     * One way to initialise a period is as follows:     * <pre>     * Period = new Period().withYears(6).withMonths(3).withSeconds(23);     * </pre>     * Bear in mind that this creates four period instances in total, three of     * which are immediately discarded.     * The alterative is more efficient, but less readable:     * <pre>     * Period = new Period(6, 3, 0, 0, 0, 0, 23, 0);     * </pre>     * The following is also slightly less wasteful:     * <pre>     * Period = Period.years(6).withMonths(3).withSeconds(23);     * </pre>     */
/**     * Create a period from a set of field values using the standard set of fields.     * Note that the parameters specify the time fields hours, minutes,     * seconds and millis, not the date fields.     *     * @param hours  amount of hours in this period     * @param minutes  amount of minutes in this period     * @param seconds  amount of seconds in this period     * @param millis  amount of milliseconds in this period     */
/**     * Create a period from a set of field values using the standard set of fields.     *     * @param years  amount of years in this period     * @param months  amount of months in this period     * @param weeks  amount of weeks in this period     * @param days  amount of days in this period     * @param hours  amount of hours in this period     * @param minutes  amount of minutes in this period     * @param seconds  amount of seconds in this period     * @param millis  amount of milliseconds in this period     */
/**     * Creates a period from the given millisecond duration using the standard     * set of fields.     * <p>     * Only precise fields in the period type will be used.     * For the standard period type this is the time fields only.     * Thus the year, month, week and day fields will not be populated.     * <p>     * If the duration is small, less than one day, then this method will perform     * as you might expect and split the fields evenly.     * <p>     * If the duration is larger than one day then all the remaining duration will     * be stored in the largest available precise field, hours in this case.     * <p>     * For example, a duration equal to (365 + 60 + 5) days will be converted to     * ((365 + 60 + 5) * 24) hours by this constructor.     * <p>     * For more control over the conversion process, you have two options:     * <ul>     * <li>convert the duration to an {@link Interval}, and from there obtain the period     * <li>specify a period type that contains precise definitions of the day and larger     * fields, such as UTC     * </ul>     *     * @param duration  the duration, in milliseconds     */
/**     * Creates a period from the given millisecond duration.     * <p>     * Only precise fields in the period type will be used.     * Imprecise fields will not be populated.     * <p>     * If the duration is small then this method will perform     * as you might expect and split the fields evenly.     * <p>     * If the duration is large then all the remaining duration will     * be stored in the largest available precise field.     * For details as to which fields are precise, review the period type javadoc.     *     * @param duration  the duration, in milliseconds     * @param type  which set of fields this period supports, null means standard     */
/**     * Creates a period from the given millisecond duration using the standard     * set of fields.     * <p>     * Only precise fields in the period type will be used.     * Imprecise fields will not be populated.     * <p>     * If the duration is small then this method will perform     * as you might expect and split the fields evenly.     * <p>     * If the duration is large then all the remaining duration will     * be stored in the largest available precise field.     * For details as to which fields are precise, review the period type javadoc.     *     * @param duration  the duration, in milliseconds     * @param chronology  the chronology to use to split the duration, null means ISO default     */
/**     * Creates a period from the given millisecond duration.     * <p>     * Only precise fields in the period type will be used.     * Imprecise fields will not be populated.     * <p>     * If the duration is small then this method will perform     * as you might expect and split the fields evenly.     * <p>     * If the duration is large then all the remaining duration will     * be stored in the largest available precise field.     * For details as to which fields are precise, review the period type javadoc.     *     * @param duration  the duration, in milliseconds     * @param type  which set of fields this period supports, null means standard     * @param chronology  the chronology to use to split the duration, null means ISO default     */
/**     * Creates a period from the given interval endpoints using the standard     * set of fields.     *     * @param startInstant  interval start, in milliseconds     * @param endInstant  interval end, in milliseconds     */
/**     * Creates a period from the given interval endpoints.     *     * @param startInstant  interval start, in milliseconds     * @param endInstant  interval end, in milliseconds     * @param type  which set of fields this period supports, null means standard     */
/**     * Creates a period from the given interval endpoints using the standard     * set of fields.     *     * @param startInstant  interval start, in milliseconds     * @param endInstant  interval end, in milliseconds     * @param chrono  the chronology to use, null means ISO in default zone     */
/**     * Creates a period from the given interval endpoints.     *     * @param startInstant  interval start, in milliseconds     * @param endInstant  interval end, in milliseconds     * @param type  which set of fields this period supports, null means standard     * @param chrono  the chronology to use, null means ISO in default zone     */
/**     * Creates a period between the given instants using the standard set of fields.     * <p>     * Most calculations performed by this method have obvious results.     * The special case is where the calculation is from a "long" month to a "short" month.     * Here, the result favours increasing the months field rather than the days.     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days     * (exposed as 4 weeks and 2 days).     * The results are explained by considering that the start date plus the     * calculated period result in the end date.     *     * @param startInstant  interval start, null means now     * @param endInstant  interval end, null means now     */
/**     * Creates a period between the given instants.     * <p>     * Most calculations performed by this method have obvious results.     * The special case is where the calculation is from a "long" month to a "short" month.     * Here, the result favours increasing the months field rather than the days.     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days.     * The results are explained by considering that the start date plus the     * calculated period result in the end date.     *     * @param startInstant  interval start, null means now     * @param endInstant  interval end, null means now     * @param type  which set of fields this period supports, null means standard     */
/**     * Creates a period from two partially specified times.     * <p>     * The two partials must contain the same fields, thus you can specify     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,     * but not one of each.     * As these are Partial objects, time zones have no effect on the result.     * <p>     * The two partials must also both be contiguous - see     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.     * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.     * <p>     * Most calculations performed by this method have obvious results.     * The special case is where the calculation is from a "long" month to a "short" month.     * Here, the result favours increasing the months field rather than the days.     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days     * (exposed as 4 weeks and 2 days).     * The results are explained by considering that the start date plus the     * calculated period result in the end date.     * <p>     * An alternative way of constructing a Period from two Partials     * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.     * That method handles all kinds of partials.     *     * @param start  the start of the period, must not be null     * @param end  the end of the period, must not be null     * @throws IllegalArgumentException if the partials are null or invalid     * @since 1.1     */
/**     * Creates a period from two partially specified times.     * <p>     * The two partials must contain the same fields, thus you can specify     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,     * but not one of each.     * As these are Partial objects, time zones have no effect on the result.     * <p>     * The two partials must also both be contiguous - see     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a definition.     * Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.     * <p>     * Most calculations performed by this method have obvious results.     * The special case is where the calculation is from a "long" month to a "short" month.     * Here, the result favours increasing the months field rather than the days.     * For example, 2013-01-31 to 2013-02-28 is treated as one whole month.     * By contrast, 2013-01-31 to 2013-03-30 is treated as one month and 30 days.     * The results are explained by considering that the start date plus the     * calculated period result in the end date.     * <p>     * An alternative way of constructing a Period from two Partials     * is {@link #fieldDifference(ReadablePartial, ReadablePartial)}.     * That method handles all kinds of partials.     *     * @param start  the start of the period, must not be null     * @param end  the end of the period, must not be null     * @param type  which set of fields this period supports, null means standard     * @throws IllegalArgumentException if the partials are null or invalid     * @since 1.1     */
/**     * Creates a period from the given start point and the duration.     *     * @param startInstant  the interval start, null means now     * @param duration  the duration of the interval, null means zero-length     */
/**     * Creates a period from the given start point and the duration.     *     * @param startInstant  the interval start, null means now     * @param duration  the duration of the interval, null means zero-length     * @param type  which set of fields this period supports, null means standard     */
/**     * Creates a period from the given duration and end point.     *     * @param duration  the duration of the interval, null means zero-length     * @param endInstant  the interval end, null means now     */
/**     * Creates a period from the given duration and end point.     *     * @param duration  the duration of the interval, null means zero-length     * @param endInstant  the interval end, null means now     * @param type  which set of fields this period supports, null means standard     */
/**     * Creates a period by converting or copying from another object.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePeriod, ReadableInterval and String.     * The String formats are described by {@link ISOPeriodFormat#standard()}.     *     * @param period  period to convert     * @throws IllegalArgumentException if period is invalid     * @throws UnsupportedOperationException if an unsupported field's value is non-zero     */
/**     * Creates a period by converting or copying from another object.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePeriod, ReadableInterval and String.     * The String formats are described by {@link ISOPeriodFormat#standard()}.     *     * @param period  period to convert     * @param type  which set of fields this period supports, null means use converter     * @throws IllegalArgumentException if period is invalid     * @throws UnsupportedOperationException if an unsupported field's value is non-zero     */
/**     * Creates a period by converting or copying from another object.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePeriod, ReadableInterval and String.     * The String formats are described by {@link ISOPeriodFormat#standard()}.     *     * @param period  period to convert     * @param chrono  the chronology to use, null means ISO in default zone     * @throws IllegalArgumentException if period is invalid     * @throws UnsupportedOperationException if an unsupported field's value is non-zero     */
/**     * Creates a period by converting or copying from another object.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadablePeriod, ReadableInterval and String.     * The String formats are described by {@link ISOPeriodFormat#standard()}.     *     * @param period  period to convert     * @param type  which set of fields this period supports, null means use converter     * @param chrono  the chronology to use, null means ISO in default zone     * @throws IllegalArgumentException if period is invalid     * @throws UnsupportedOperationException if an unsupported field's value is non-zero     */
/**     * Get this period as an immutable <code>Period</code> object     * by returning <code>this</code>.     *      * @return <code>this</code>     */
/**     * Creates a new Period instance with the same field values but     * different PeriodType.     * <p>     * This period instance is immutable and unaffected by this method call.     *      * @param type  the period type to use, null means standard     * @return the new period instance     * @throws IllegalArgumentException if the new period won't accept all of the current fields     */
/**     * Creates a new Period instance with the fields from the specified period     * copied on top of those from this period.     * <p>     * This period instance is immutable and unaffected by this method call.     *      * @param period  the period to copy from, null ignored     * @return the new period instance     * @throws IllegalArgumentException if a field type is unsupported     */
/**     * Creates a new Period instance with the specified field set to a new value.     * <p>     * This period instance is immutable and unaffected by this method call.     *      * @param field  the field to set, not null     * @param value  the value to set to     * @return the new period instance     * @throws IllegalArgumentException if the field type is null or unsupported     */
/**     * Creates a new Period instance with the valueToAdd added to the specified field.     * <p>     * This period instance is immutable and unaffected by this method call.     *      * @param field  the field to set, not null     * @param value  the value to add     * @return the new period instance     * @throws IllegalArgumentException if the field type is null or unsupported     */
/**     * Returns a new period with the specified number of years.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to add, may be negative     * @return the new period with the increased years     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified number of months.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to add, may be negative     * @return the new period with the increased months     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified number of weeks.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to add, may be negative     * @return the new period with the increased weeks     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified number of days.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to add, may be negative     * @return the new period with the increased days     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified number of hours.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to add, may be negative     * @return the new period with the increased hours     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified number of minutes.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to add, may be negative     * @return the new period with the increased minutes     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified number of seconds.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to add, may be negative     * @return the new period with the increased seconds     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified number of millis.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param millis  the amount of millis to add, may be negative     * @return the new period with the increased millis     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified period added.     * <p>     * Each field of the period is added separately. Thus a period of     * 2 hours 30 minutes plus 3 hours 40 minutes will produce a result     * of 5 hours 70 minutes - see {@link #normalizedStandard()}.     * <p>     * If the period being added contains a non-zero amount for a field that     * is not supported in this period then an exception is thrown.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param period  the period to add, null adds zero and returns this     * @return the new updated period     * @throws UnsupportedOperationException if any field is not supported     * @since 1.5     */
/**     * Returns a new period with the specified number of years added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to add, may be negative     * @return the new period with the increased years     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period plus the specified number of months added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to add, may be negative     * @return the new period plus the increased months     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period plus the specified number of weeks added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to add, may be negative     * @return the new period plus the increased weeks     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period plus the specified number of days added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to add, may be negative     * @return the new period plus the increased days     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period plus the specified number of hours added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to add, may be negative     * @return the new period plus the increased hours     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period plus the specified number of minutes added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to add, may be negative     * @return the new period plus the increased minutes     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period plus the specified number of seconds added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to add, may be negative     * @return the new period plus the increased seconds     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period plus the specified number of millis added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param millis  the amount of millis to add, may be negative     * @return the new period plus the increased millis     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified period subtracted.     * <p>     * Each field of the period is subtracted separately. Thus a period of     * 3 hours 30 minutes minus 2 hours 40 minutes will produce a result     * of 1 hour and -10 minutes - see {@link #normalizedStandard()}.     * <p>     * If the period being added contains a non-zero amount for a field that     * is not supported in this period then an exception is thrown.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param period  the period to add, null adds zero and returns this     * @return the new updated period     * @throws UnsupportedOperationException if any field is not supported     * @since 1.5     */
/**     * Returns a new period with the specified number of years taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to take away, may be negative     * @return the new period with the increased years     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period minus the specified number of months taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to take away, may be negative     * @return the new period minus the increased months     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period minus the specified number of weeks taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to take away, may be negative     * @return the new period minus the increased weeks     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period minus the specified number of days taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to take away, may be negative     * @return the new period minus the increased days     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period minus the specified number of hours taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to take away, may be negative     * @return the new period minus the increased hours     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period minus the specified number of minutes taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to take away, may be negative     * @return the new period minus the increased minutes     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period minus the specified number of seconds taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to take away, may be negative     * @return the new period minus the increased seconds     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period minus the specified number of millis taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param millis  the amount of millis to take away, may be negative     * @return the new period minus the increased millis     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new instance with each element in this period multiplied     * by the specified scalar.     *     * @param scalar  the scalar to multiply by, not null     * @return a {@code Period} based on this period with the amounts multiplied by the scalar, never null     * @throws ArithmeticException if the capacity of any field is exceeded     * @since 2.1     */
/**     * Returns a new instance with each amount in this period negated.     *     * @return a {@code Period} based on this period with the amounts negated, never null     * @throws ArithmeticException if any field has the minimum value     * @since 2.1     */
/**     * Normalizes this period using standard rules, assuming a 12 month year,     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.     * <p>     * This method allows you to normalize a period.     * However to achieve this it makes the assumption that all years are     * 12 months, all weeks are 7 days, all days are 24 hours,     * all hours are 60 minutes and all minutes are 60 seconds. This is not     * true when daylight savings time is considered, and may also not be true     * for some chronologies. However, it is included as it is a useful operation     * for many applications and business rules.     * <p>     * If the period contains years or months, then the months will be     * normalized to be between 0 and 11. The days field and below will be     * normalized as necessary, however this will not overflow into the months     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.     * But a period of 1 month 40 days will remain as 1 month 40 days.     * <p>     * The result will always have a <code>PeriodType</code> of standard, thus     * days will be grouped into weeks.     *      * @return a normalized period equivalent to this period     * @throws ArithmeticException if any field is too large to be represented     * @since 1.5     */
/**     * Normalizes this period using standard rules, assuming a 12 month year,     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,     * providing control over how the result is split into fields.     * <p>     * This method allows you to normalize a period.     * However to achieve this it makes the assumption that all years are     * 12 months, all weeks are 7 days, all days are 24 hours,     * all hours are 60 minutes and all minutes are 60 seconds. This is not     * true when daylight savings time is considered, and may also not be true     * for some chronologies. However, it is included as it is a useful operation     * for many applications and business rules.     * <p>     * If the period contains years or months, then the months will be     * normalized to be between 0 and 11. The days field and below will be     * normalized as necessary, however this will not overflow into the months     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.     * But a period of 1 month 40 days will remain as 1 month 40 days.     * <p>     * The PeriodType parameter controls how the result is created. It allows     * you to omit certain fields from the result if desired. For example,     * you may not want the result to include weeks, in which case you pass     * in <code>PeriodType.yearMonthDayTime()</code>.     *      * @param type  the period type of the new period, null means standard type     * @return a normalized period equivalent to this period     * @throws ArithmeticException if any field is too large to be represented     * @throws UnsupportedOperationException if this period contains non-zero     *  years or months but the specified period type does not support them     * @since 1.5     */
/**     * Parses a {@code Period} from the specified string using a formatter.     *      * @param str  the string to parse, not null     * @param formatter  the formatter to use, not null     * @since 2.0     */
/**     * Create a period with a specified number of years.     * <p>     * The standard period type is used, thus you can add other fields such     * as months or days using the <code>withXxx()</code> methods.     * For example, <code>Period.years(2).withMonths(6);</code>     * <p>     * If you want a year-based period that cannot have other fields added,     * then you should consider using {@link Years}.     *     * @param years  the amount of years in this period     * @return the period     */
/**     * Create a period with a specified number of months.     * <p>     * The standard period type is used, thus you can add other fields such     * as years or days using the <code>withXxx()</code> methods.     * For example, <code>Period.months(2).withDays(6);</code>     * <p>     * If you want a month-based period that cannot have other fields added,     * then you should consider using {@link Months}.     *     * @param months  the amount of months in this period     * @return the period     */
/**     * Create a period with a specified number of weeks.     * <p>     * The standard period type is used, thus you can add other fields such     * as months or days using the <code>withXxx()</code> methods.     * For example, <code>Period.weeks(2).withDays(6);</code>     * <p>     * If you want a week-based period that cannot have other fields added,     * then you should consider using {@link Weeks}.     *     * @param weeks  the amount of weeks in this period     * @return the period     */
/**     * Create a period with a specified number of days.     * <p>     * The standard period type is used, thus you can add other fields such     * as months or weeks using the <code>withXxx()</code> methods.     * For example, <code>Period.days(2).withHours(6);</code>     * <p>     * If you want a day-based period that cannot have other fields added,     * then you should consider using {@link Days}.     *     * @param days  the amount of days in this period     * @return the period     */
/**     * Create a period with a specified number of hours.     * <p>     * The standard period type is used, thus you can add other fields such     * as months or days using the <code>withXxx()</code> methods.     * For example, <code>Period.hours(2).withMinutes(30);</code>     * <p>     * If you want a hour-based period that cannot have other fields added,     * then you should consider using {@link Hours}.     *     * @param hours  the amount of hours in this period     * @return the period     */
/**     * Create a period with a specified number of minutes.     * <p>     * The standard period type is used, thus you can add other fields such     * as days or hours using the <code>withXxx()</code> methods.     * For example, <code>Period.minutes(2).withSeconds(30);</code>     * <p>     * If you want a minute-based period that cannot have other fields added,     * then you should consider using {@link Minutes}.     *     * @param minutes  the amount of minutes in this period     * @return the period     */
/**     * Create a period with a specified number of seconds.     * <p>     * The standard period type is used, thus you can add other fields such     * as days or hours using the <code>withXxx()</code> methods.     * For example, <code>Period.seconds(2).withMillis(30);</code>     * <p>     * If you want a second-based period that cannot have other fields added,     * then you should consider using {@link Seconds}.     *     * @param seconds  the amount of seconds in this period     * @return the period     */
/**     * Create a period with a specified number of millis.     * <p>     * The standard period type is used, thus you can add other fields such     * as days or hours using the <code>withXxx()</code> methods.     * For example, <code>Period.millis(20).withSeconds(30);</code>     *     * @param millis  the amount of millis in this period     * @return the period     */
/**     * Creates a period from two partially specified times, calculating     * by field difference.     * <p>     * The two partials must contain the same fields, thus you can specify     * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,     * but not one of each. Also, the partial may not contain overlapping     * fields, such as dayOfWeek and dayOfMonth.     * <p>     * Calculation by field difference works by extracting the difference     * one field at a time and not wrapping into other fields.     * Thus 2005-06-09/2007-04-12 will yield P1Y-2M3D.     * <p>     * For example, you have an event that always runs from the 27th of     * each month to the 2nd of the next month. If you calculate this     * period using a standard constructor, then you will get between     * P3D and P6D depending on the month. If you use this method, then     * you will get P1M-25D. This field-difference based period can     * be successfully applied to each month of the year to obtain the     * correct end date for a given start date.     *     * @param start  the start of the period, must not be null     * @param end  the end of the period, must not be null     * @throws IllegalArgumentException if the partials are null or invalid     * @since 1.1     */
/**     * Get this period as an immutable <code>Period</code> object     * by returning <code>this</code>.     *      * @return <code>this</code>     */
/**     * Creates a new Period instance with the same field values but     * different PeriodType.     * <p>     * This period instance is immutable and unaffected by this method call.     *      * @param type  the period type to use, null means standard     * @return the new period instance     * @throws IllegalArgumentException if the new period won't accept all of the current fields     */
/**     * Creates a new Period instance with the fields from the specified period     * copied on top of those from this period.     * <p>     * This period instance is immutable and unaffected by this method call.     *      * @param period  the period to copy from, null ignored     * @return the new period instance     * @throws IllegalArgumentException if a field type is unsupported     */
/**     * Creates a new Period instance with the specified field set to a new value.     * <p>     * This period instance is immutable and unaffected by this method call.     *      * @param field  the field to set, not null     * @param value  the value to set to     * @return the new period instance     * @throws IllegalArgumentException if the field type is null or unsupported     */
/**     * Creates a new Period instance with the valueToAdd added to the specified field.     * <p>     * This period instance is immutable and unaffected by this method call.     *      * @param field  the field to set, not null     * @param value  the value to add     * @return the new period instance     * @throws IllegalArgumentException if the field type is null or unsupported     */
/**     * Returns a new period with the specified number of years.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to add, may be negative     * @return the new period with the increased years     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified number of months.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to add, may be negative     * @return the new period with the increased months     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified number of weeks.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to add, may be negative     * @return the new period with the increased weeks     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified number of days.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to add, may be negative     * @return the new period with the increased days     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified number of hours.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to add, may be negative     * @return the new period with the increased hours     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified number of minutes.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to add, may be negative     * @return the new period with the increased minutes     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified number of seconds.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to add, may be negative     * @return the new period with the increased seconds     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified number of millis.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param millis  the amount of millis to add, may be negative     * @return the new period with the increased millis     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified period added.     * <p>     * Each field of the period is added separately. Thus a period of     * 2 hours 30 minutes plus 3 hours 40 minutes will produce a result     * of 5 hours 70 minutes - see {@link #normalizedStandard()}.     * <p>     * If the period being added contains a non-zero amount for a field that     * is not supported in this period then an exception is thrown.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param period  the period to add, null adds zero and returns this     * @return the new updated period     * @throws UnsupportedOperationException if any field is not supported     * @since 1.5     */
/**     * Returns a new period with the specified number of years added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to add, may be negative     * @return the new period with the increased years     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period plus the specified number of months added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to add, may be negative     * @return the new period plus the increased months     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period plus the specified number of weeks added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to add, may be negative     * @return the new period plus the increased weeks     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period plus the specified number of days added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to add, may be negative     * @return the new period plus the increased days     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period plus the specified number of hours added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to add, may be negative     * @return the new period plus the increased hours     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period plus the specified number of minutes added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to add, may be negative     * @return the new period plus the increased minutes     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period plus the specified number of seconds added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to add, may be negative     * @return the new period plus the increased seconds     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period plus the specified number of millis added.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param millis  the amount of millis to add, may be negative     * @return the new period plus the increased millis     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period with the specified period subtracted.     * <p>     * Each field of the period is subtracted separately. Thus a period of     * 3 hours 30 minutes minus 2 hours 40 minutes will produce a result     * of 1 hour and -10 minutes - see {@link #normalizedStandard()}.     * <p>     * If the period being added contains a non-zero amount for a field that     * is not supported in this period then an exception is thrown.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param period  the period to add, null adds zero and returns this     * @return the new updated period     * @throws UnsupportedOperationException if any field is not supported     * @since 1.5     */
/**     * Returns a new period with the specified number of years taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to take away, may be negative     * @return the new period with the increased years     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period minus the specified number of months taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param months  the amount of months to take away, may be negative     * @return the new period minus the increased months     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period minus the specified number of weeks taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to take away, may be negative     * @return the new period minus the increased weeks     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period minus the specified number of days taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param days  the amount of days to take away, may be negative     * @return the new period minus the increased days     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period minus the specified number of hours taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param hours  the amount of hours to take away, may be negative     * @return the new period minus the increased hours     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period minus the specified number of minutes taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param minutes  the amount of minutes to take away, may be negative     * @return the new period minus the increased minutes     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period minus the specified number of seconds taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to take away, may be negative     * @return the new period minus the increased seconds     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new period minus the specified number of millis taken away.     * <p>     * This period instance is immutable and unaffected by this method call.     *     * @param millis  the amount of millis to take away, may be negative     * @return the new period minus the increased millis     * @throws UnsupportedOperationException if the field is not supported     */
/**     * Returns a new instance with each element in this period multiplied     * by the specified scalar.     *     * @param scalar  the scalar to multiply by, not null     * @return a {@code Period} based on this period with the amounts multiplied by the scalar, never null     * @throws ArithmeticException if the capacity of any field is exceeded     * @since 2.1     */
/**     * Returns a new instance with each amount in this period negated.     *     * @return a {@code Period} based on this period with the amounts negated, never null     * @throws ArithmeticException if any field has the minimum value     * @since 2.1     */
/**     * Converts this period to a period in weeks assuming a     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and     * all minutes are 60 seconds. This is not true when daylight savings time     * is considered, and may also not be true for some unusual chronologies.     * However, it is included as it is a useful operation for many     * applications and business rules.     * <p>     * If the period contains years or months, an exception will be thrown.     *      * @return a period representing the number of standard weeks in this period     * @throws UnsupportedOperationException if the period contains years or months     * @throws ArithmeticException if the number of weeks is too large to be represented     * @since 1.5     */
/**     * Converts this period to a period in days assuming a     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and     * all minutes are 60 seconds. This is not true when daylight savings time     * is considered, and may also not be true for some unusual chronologies.     * However, it is included as it is a useful operation for many     * applications and business rules.     * <p>     * If the period contains years or months, an exception will be thrown.     *      * @return a period representing the number of standard days in this period     * @throws UnsupportedOperationException if the period contains years or months     * @throws ArithmeticException if the number of days is too large to be represented     * @since 1.5     */
/**     * Converts this period to a period in hours assuming a     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and     * all minutes are 60 seconds. This is not true when daylight savings time     * is considered, and may also not be true for some unusual chronologies.     * However, it is included as it is a useful operation for many     * applications and business rules.     * <p>     * If the period contains years or months, an exception will be thrown.     *      * @return a period representing the number of standard hours in this period     * @throws UnsupportedOperationException if the period contains years or months     * @throws ArithmeticException if the number of hours is too large to be represented     * @since 1.5     */
/**     * Converts this period to a period in minutes assuming a     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and     * all minutes are 60 seconds. This is not true when daylight savings time     * is considered, and may also not be true for some unusual chronologies.     * However, it is included as it is a useful operation for many     * applications and business rules.     * <p>     * If the period contains years or months, an exception will be thrown.     *      * @return a period representing the number of standard minutes in this period     * @throws UnsupportedOperationException if the period contains years or months     * @throws ArithmeticException if the number of minutes is too large to be represented     * @since 1.5     */
/**     * Converts this period to a period in seconds assuming a     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and     * all minutes are 60 seconds. This is not true when daylight savings time     * is considered, and may also not be true for some unusual chronologies.     * However, it is included as it is a useful operation for many     * applications and business rules.     * <p>     * If the period contains years or months, an exception will be thrown.     *      * @return a period representing the number of standard seconds in this period     * @throws UnsupportedOperationException if the period contains years or months     * @throws ArithmeticException if the number of seconds is too large to be represented     * @since 1.5     */
/**     * Converts this period to a duration assuming a     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert from a period to a duration.     * However to achieve this it makes the assumption that all     * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and     * all minutes are 60 seconds. This is not true when daylight savings time     * is considered, and may also not be true for some unusual chronologies.     * However, it is included as it is a useful operation for many     * applications and business rules.     * <p>     * If the period contains years or months, an exception will be thrown.     *      * @return a duration equivalent to this period     * @throws UnsupportedOperationException if the period contains years or months     * @since 1.5     */
/**     * Check that there are no years or months in the period.     *      * @param destintionType  the destination type, not null     * @throws UnsupportedOperationException if the period contains years or months     */
/**     * Normalizes this period using standard rules, assuming a 12 month year,     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,     * providing control over how the result is split into fields.     * <p>     * This method allows you to normalize a period.     * However to achieve this it makes the assumption that all years are     * 12 months, all weeks are 7 days, all days are 24 hours,     * all hours are 60 minutes and all minutes are 60 seconds. This is not     * true when daylight savings time is considered, and may also not be true     * for some chronologies. However, it is included as it is a useful operation     * for many applications and business rules.     * <p>     * If the period contains years or months, then the months will be     * normalized to be between 0 and 11. The days field and below will be     * normalized as necessary, however this will not overflow into the months     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.     * But a period of 1 month 40 days will remain as 1 month 40 days.     * <p>     * The PeriodType parameter controls how the result is created. It allows     * you to omit certain fields from the result if desired. For example,     * you may not want the result to include weeks, in which case you pass     * in <code>PeriodType.yearMonthDayTime()</code>.     *      * @param type  the period type of the new period, null means standard type     * @return a normalized period equivalent to this period     * @throws ArithmeticException if any field is too large to be represented     * @throws UnsupportedOperationException if this period contains non-zero     *  years or months but the specified period type does not support them     * @since 1.5     */
/**     * Returns a version of this PeriodType instance that does not support years.     *      * @return a new period type that supports the original set of fields except years     */
/**     * Returns a version of this PeriodType instance that does not support months.     *      * @return a new period type that supports the original set of fields except months     */
/**     * Returns a version of this PeriodType instance that does not support weeks.     *      * @return a new period type that supports the original set of fields except weeks     */
/**     * Returns a version of this PeriodType instance that does not support days.     *      * @return a new period type that supports the original set of fields except days     */
/**     * Returns a version of this PeriodType instance that does not support hours.     *      * @return a new period type that supports the original set of fields except hours     */
/**     * Returns a version of this PeriodType instance that does not support minutes.     *      * @return a new period type that supports the original set of fields except minutes     */
/**     * Returns a version of this PeriodType instance that does not support seconds.     *      * @return a new period type that supports the original set of fields except seconds     */
/**     * Returns a version of this PeriodType instance that does not support milliseconds.     *      * @return a new period type that supports the original set of fields except milliseconds     */
/**     * Gets a type that defines all standard fields.     * <ul>     * <li>years     * <li>months     * <li>weeks     * <li>days     * <li>hours     * <li>minutes     * <li>seconds     * <li>milliseconds     * </ul>     *     * @return the period type     */
/**     * Gets a type that defines all standard fields except weeks.     * <ul>     * <li>years     * <li>months     * <li>days     * <li>hours     * <li>minutes     * <li>seconds     * <li>milliseconds     * </ul>     *     * @return the period type     */
/**     * Gets a type that defines the year, month and day fields.     * <ul>     * <li>years     * <li>months     * <li>days     * </ul>     *     * @return the period type     * @since 1.1     */
/**     * Gets a type that defines all standard fields except months.     * <ul>     * <li>years     * <li>weeks     * <li>days     * <li>hours     * <li>minutes     * <li>seconds     * <li>milliseconds     * </ul>     *     * @return the period type     */
/**     * Gets a type that defines year, week and day fields.     * <ul>     * <li>years     * <li>weeks     * <li>days     * </ul>     *     * @return the period type     * @since 1.1     */
/**     * Gets a type that defines all standard fields except months and weeks.     * <ul>     * <li>years     * <li>days     * <li>hours     * <li>minutes     * <li>seconds     * <li>milliseconds     * </ul>     *     * @return the period type     */
/**     * Gets a type that defines the year and day fields.     * <ul>     * <li>years     * <li>days     * </ul>     *     * @return the period type     * @since 1.1     */
/**     * Gets a type that defines all standard fields from days downwards.     * <ul>     * <li>days     * <li>hours     * <li>minutes     * <li>seconds     * <li>milliseconds     * </ul>     *     * @return the period type     */
/**     * Gets a type that defines all standard time fields.     * <ul>     * <li>hours     * <li>minutes     * <li>seconds     * <li>milliseconds     * </ul>     *     * @return the period type     */
/**     * Gets a type that defines just the years field.     *     * @return the period type     */
/**     * Gets a type that defines just the months field.     *     * @return the period type     */
/**     * Gets a type that defines just the weeks field.     *     * @return the period type     */
/**     * Gets a type that defines just the days field.     *     * @return the period type     */
/**     * Gets a type that defines just the hours field.     *     * @return the period type     */
/**     * Gets a type that defines just the minutes field.     *     * @return the period type     */
/**     * Gets a type that defines just the seconds field.     *     * @return the period type     */
/**     * Gets a type that defines just the millis field.     *     * @return the period type     */
/**     * Gets a period type that contains the duration types of the array.     * <p>     * Only the 8 standard duration field types are supported.     *     * @param types  the types to include in the array.     * @return the period type     * @since 1.1     */
/**     * Gets the name of the period type.     *      * @return the name     */
/**     * Gets the number of fields in the period type.     *      * @return the number of fields     */
/**     * Gets the field type by index.     *      * @param index  the index to retrieve     * @return the field type     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Checks whether the field specified is supported by this period.     *     * @param type  the type to check, may be null which returns false     * @return true if the field is supported     */
/**     * Gets the index of the field in this period.     *     * @param type  the type to check, may be null which returns -1     * @return the index of -1 if not supported     */
/**     * Gets a debugging to string.     *      * @return a string     */
/**     * Gets the indexed field part of the period.     *      * @param period  the period to query     * @param index  the index to use     * @return the value of the field, zero if unsupported     */
/**     * Sets the indexed field part of the period.     *      * @param period  the period to query     * @param index  the index to use     * @param values  the array to populate     * @param newValue  the value to set     * @throws UnsupportedOperationException if not supported     */
/**     * Adds to the indexed field part of the period.     *      * @param period  the period to query     * @param index  the index to use     * @param values  the array to populate     * @param valueToAdd  the value to add     * @return true if the array is updated     * @throws UnsupportedOperationException if not supported     */
/**     * Returns a version of this PeriodType instance that does not support years.     *      * @return a new period type that supports the original set of fields except years     */
/**     * Returns a version of this PeriodType instance that does not support months.     *      * @return a new period type that supports the original set of fields except months     */
/**     * Returns a version of this PeriodType instance that does not support weeks.     *      * @return a new period type that supports the original set of fields except weeks     */
/**     * Returns a version of this PeriodType instance that does not support days.     *      * @return a new period type that supports the original set of fields except days     */
/**     * Returns a version of this PeriodType instance that does not support hours.     *      * @return a new period type that supports the original set of fields except hours     */
/**     * Returns a version of this PeriodType instance that does not support minutes.     *      * @return a new period type that supports the original set of fields except minutes     */
/**     * Returns a version of this PeriodType instance that does not support seconds.     *      * @return a new period type that supports the original set of fields except seconds     */
/**     * Returns a version of this PeriodType instance that does not support milliseconds.     *      * @return a new period type that supports the original set of fields except milliseconds     */
/**     * Removes the field specified by indices index.     *      * @param indicesIndex  the index to remove     * @param name  the name addition     * @return the new type     */
/**     * Compares this type to another object.     * To be equal, the object must be a PeriodType with the same set of fields.     *      * @param obj  the object to compare to     * @return true if equal     */
/**     * Returns a hashcode based on the field types.     *      * @return a suitable hashcode     */
/**     * Returns a new instance with the specified number of seconds added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to add, may be negative     * @return the new period plus the specified number of seconds     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of seconds added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to add, may be negative, null means zero     * @return the new period plus the specified number of seconds     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of seconds taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to take away, may be negative     * @return the new period minus the specified number of seconds     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of seconds taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to take away, may be negative, null means zero     * @return the new period minus the specified number of seconds     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the seconds multiplied by the specified scalar.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param scalar  the amount to multiply by, may be negative     * @return the new period multiplied by the specified scalar     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the seconds divided by the specified divisor.     * The calculation uses integer division, thus 3 divided by 2 is 1.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param divisor  the amount to divide by, may be negative     * @return the new period divided by the specified divisor     * @throws ArithmeticException if the divisor is zero     */
/**     * Returns a new instance with the seconds value negated.     *     * @return the new period with a negated value     * @throws ArithmeticException if the result overflows an int     */
/**     * Obtains an instance of <code>Seconds</code> that may be cached.     * <code>Seconds</code> is immutable, so instances can be cached and shared.     * This factory method provides access to shared instances.     *     * @param seconds  the number of seconds to obtain an instance for     * @return the instance of Seconds     */
/**     * Creates a <code>Seconds</code> representing the number of whole seconds     * between the two specified partial datetimes.     * <p>     * The two partials must contain the same fields, for example you can specify     * two <code>LocalTime</code> objects.     *     * @param start  the start partial date, must not be null     * @param end  the end partial date, must not be null     * @return the period in seconds     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Creates a <code>Seconds</code> representing the number of whole seconds     * in the specified interval.     *     * @param interval  the interval to extract seconds from, null returns zero     * @return the period in seconds     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Creates a new <code>Seconds</code> representing the number of complete     * standard length seconds in the specified period.     * <p>     * This factory method converts all fields from the period to hours using standardised     * durations for each field. Only those fields which have a precise duration in     * the ISO UTC chronology can be converted.     * <ul>     * <li>One week consists of 7 seconds.     * <li>One day consists of 24 hours.     * <li>One hour consists of 60 minutes.     * <li>One minute consists of 60 seconds.     * <li>One second consists of 1000 milliseconds.     * </ul>     * Months and Years are imprecise and periods containing these values cannot be converted.     *     * @param period  the period to get the number of hours from, null returns zero     * @return the period in seconds     * @throws IllegalArgumentException if the period contains imprecise duration values     */
/**     * Resolves singletons.     *      * @return the singleton instance     */
/**     * Gets the duration field type, which is <code>seconds</code>.     *     * @return the period type     */
/**     * Gets the period type, which is <code>seconds</code>.     *     * @return the period type     */
/**     * Converts this period in seconds to a period in weeks assuming a     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all weeks are 7 days     * long, all days are 24 hours long, all hours are 60 minutes long and     * all minutes are 60 seconds long.     * This is not true when daylight savings time is considered, and may also     * not be true for some unusual chronologies. However, it is included as it     * is a useful operation for many applications and business rules.     *      * @return a period representing the number of whole weeks for this number of seconds     */
/**     * Converts this period in seconds to a period in days assuming a     * 24 hour day, 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all days are 24 hours     * long, all hours are 60 minutes long and all minutes are 60 seconds long.     * This is not true when daylight savings is considered and may also not     * be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of days for this number of seconds     */
/**     * Converts this period in seconds to a period in hours assuming a     * 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all hours are     * 60 minutes long and all minutes are 60 seconds long.     * This may not be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of hours for this number of seconds     */
/**     * Converts this period in seconds to a period in minutes assuming a     * 60 second minute.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all minutes are     * 60 seconds long.     * This may not be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of minutes for this number of seconds     */
/**     * Converts this period in seconds to a duration in milliseconds assuming a     * 24 hour day, 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert from a period to a duration.     * However to achieve this it makes the assumption that all seconds are 24 hours     * long, all hours are 60 minutes and all minutes are 60 seconds.     * This is not true when daylight savings time is considered, and may also     * not be true for some unusual chronologies. However, it is included as it     * is a useful operation for many applications and business rules.     *      * @return a duration equivalent to this number of seconds     */
/**     * Gets the number of seconds that this period represents.     *     * @return the number of seconds in the period     */
/**     * Returns a new instance with the specified number of seconds added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to add, may be negative, null means zero     * @return the new period plus the specified number of seconds     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of seconds taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param seconds  the amount of seconds to take away, may be negative, null means zero     * @return the new period minus the specified number of seconds     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the seconds multiplied by the specified scalar.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param scalar  the amount to multiply by, may be negative     * @return the new period multiplied by the specified scalar     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the seconds divided by the specified divisor.     * The calculation uses integer division, thus 3 divided by 2 is 1.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param divisor  the amount to divide by, may be negative     * @return the new period divided by the specified divisor     * @throws ArithmeticException if the divisor is zero     */
/**     * Returns a new instance with the seconds value negated.     *     * @return the new period with a negated value     * @throws ArithmeticException if the result overflows an int     */
/**     * Is this seconds instance greater than the specified number of seconds.     *     * @param other  the other period, null means zero     * @return true if this seconds instance is greater than the specified one     */
/**     * Is this seconds instance less than the specified number of seconds.     *     * @param other  the other period, null means zero     * @return true if this seconds instance is less than the specified one     */
/**     * Constructs a TimeOfDay with the current time, using ISOChronology in     * the default zone to extract the fields.     * <p>     * The constructor uses the default time zone, resulting in the local time     * being initialised. Once the constructor is complete, all further calculations     * are performed without reference to a timezone (by switching to UTC).     */
/**     * Constructs a TimeOfDay with the current time, using ISOChronology in     * the specified zone to extract the fields.     * <p>     * The constructor uses the specified time zone to obtain the current time.     * Once the constructor is complete, all further calculations     * are performed without reference to a timezone (by switching to UTC).     *      * @param zone  the zone to use, null means default zone     * @since 1.1     */
/**     * Constructs a TimeOfDay with the current time, using the specified chronology     * and zone to extract the fields.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a timezone (by switching to UTC).     *     * @param chronology  the chronology, null means ISOChronology in the default zone     */
/**     * Constructs a TimeOfDay extracting the partial fields from the specified     * milliseconds using the ISOChronology in the default zone.     * <p>     * The constructor uses the default time zone, resulting in the local time     * being initialised. Once the constructor is complete, all further calculations     * are performed without reference to a timezone (by switching to UTC).     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     */
/**     * Constructs a TimeOfDay extracting the partial fields from the specified     * milliseconds using the chronology provided.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a timezone (by switching to UTC).     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param chronology  the chronology, null means ISOChronology in the default zone     */
/**     * Constructs a TimeOfDay from an Object that represents a time.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#timeParser()}.     * <p>     * The chronology used will be derived from the object, defaulting to ISO.     * <p>     * NOTE: Prior to v1.3 the string format was described by     * {@link ISODateTimeFormat#dateTimeParser()}. Dates are now rejected.     *     * @param instant  the datetime object, null means now     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs a TimeOfDay from an Object that represents a time, using the     * specified chronology.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#timeParser()}.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a timezone (by switching to UTC).     * The specified chronology overrides that of the object.     * <p>     * NOTE: Prior to v1.3 the string format was described by     * {@link ISODateTimeFormat#dateTimeParser()}. Dates are now rejected.     *     * @param instant  the datetime object, null means now     * @param chronology  the chronology, null means ISO default     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds     * using <code>ISOChronology</code> in the default zone.     * <p>     * The constructor uses the no time zone initialising the fields as provided.     * Once the constructor is complete, all further calculations     * are performed without reference to a timezone (by switching to UTC).     *     * @param hourOfDay  the hour of the day     * @param minuteOfHour  the minute of the hour     */
/**     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a timezone (by switching to UTC).     *     * @param hourOfDay  the hour of the day     * @param minuteOfHour  the minute of the hour     * @param chronology  the chronology, null means ISOChronology in the default zone     */
/**     * Constructs a TimeOfDay with specified time field values and zero milliseconds     * using <code>ISOChronology</code> in the default zone.     * <p>     * The constructor uses the no time zone initialising the fields as provided.     * Once the constructor is complete, all further calculations     * are performed without reference to a timezone (by switching to UTC).     *     * @param hourOfDay  the hour of the day     * @param minuteOfHour  the minute of the hour     * @param secondOfMinute  the second of the minute     */
/**     * Constructs a TimeOfDay with specified time field values and zero milliseconds.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a timezone (by switching to UTC).     *     * @param hourOfDay  the hour of the day     * @param minuteOfHour  the minute of the hour     * @param secondOfMinute  the second of the minute     * @param chronology  the chronology, null means ISOChronology in the default zone     */
/**     * Constructs a TimeOfDay with specified time field values using     * <code>ISOChronology</code> in the default zone.     * <p>     * The constructor uses the no time zone initialising the fields as provided.     * Once the constructor is complete, all further calculations     * are performed without reference to a timezone (by switching to UTC).     *     * @param hourOfDay  the hour of the day     * @param minuteOfHour  the minute of the hour     * @param secondOfMinute  the second of the minute     * @param millisOfSecond  the millisecond of the second     */
/**     * Constructs a TimeOfDay with specified hour and minute and zero seconds and milliseconds     * using <code>ISOChronology</code> in the default zone.     * <p>     * The constructor uses the no time zone initialising the fields as provided.     * Once the constructor is complete, all further calculations     * are performed without reference to a timezone (by switching to UTC).     *     * @param hourOfDay  the hour of the day     * @param minuteOfHour  the minute of the hour     */
/**     * Returns a copy of this time with the specified chronology.     * This instance is immutable and unaffected by this method call.     * <p>     * This method retains the values of the fields, thus the result will     * typically refer to a different instant.     * <p>     * The time zone of the specified chronology is ignored, as TimeOfDay     * operates without a time zone.     *     * @param newChronology  the new chronology, null means ISO     * @return a copy of this datetime with a different chronology     * @throws IllegalArgumentException if the values are invalid for the new chronology     */
/**     * Returns a copy of this time with the specified field set to a new value.     * <p>     * For example, if the field type is <code>minuteOfHour</code> then the day     * would be changed in the returned instance.     * <p>     * These three lines are equivalent:     * <pre>     * TimeOfDay updated = tod.withField(DateTimeFieldType.minuteOfHour(), 6);     * TimeOfDay updated = tod.minuteOfHour().setCopy(6);     * TimeOfDay updated = tod.property(DateTimeFieldType.minuteOfHour()).setCopy(6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this instance with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this time with the value of the specified field increased,     * wrapping to what would be a new day if required.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * TimeOfDay added = tod.withFieldAdded(DurationFieldType.minutes(), 6);     * TimeOfDay added = tod.plusMinutes(6);     * TimeOfDay added = tod.minuteOfHour().addToCopy(6);     * </pre>     *      * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this instance with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new datetime exceeds the capacity     */
/**     * Returns a copy of this time with the specified period added,     * wrapping to what would be a new day if required.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * Fields in the period that aren't present in the partial are ignored.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusHours(int)}.     *      * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this instance with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity     */
/**     * Returns a copy of this time with the specified period added,     * wrapping to what would be a new day if required.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusHours(int)}.     *      * @param period  the duration to add to this one, null means zero     * @return a copy of this instance with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this time plus the specified number of hours.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay added = dt.plusHours(6);     * TimeOfDay added = dt.plus(Period.hours(6));     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.hours(), 6);     * </pre>     *     * @param hours  the amount of hours to add, may be negative     * @return the new time plus the increased hours     * @since 1.1     */
/**     * Returns a copy of this time plus the specified number of minutes.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay added = dt.plusMinutes(6);     * TimeOfDay added = dt.plus(Period.minutes(6));     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.minutes(), 6);     * </pre>     *     * @param minutes  the amount of minutes to add, may be negative     * @return the new time plus the increased minutes     * @since 1.1     */
/**     * Returns a copy of this time plus the specified number of seconds.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay added = dt.plusSeconds(6);     * TimeOfDay added = dt.plus(Period.seconds(6));     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.seconds(), 6);     * </pre>     *     * @param seconds  the amount of seconds to add, may be negative     * @return the new time plus the increased seconds     * @since 1.1     */
/**     * Returns a copy of this time plus the specified number of millis.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay added = dt.plusMillis(6);     * TimeOfDay added = dt.plus(Period.millis(6));     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.millis(), 6);     * </pre>     *     * @param millis  the amount of millis to add, may be negative     * @return the new time plus the increased millis     * @since 1.1     */
/**     * Returns a copy of this time with the specified period taken away,     * wrapping to what would be a new day if required.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusHours(int)}.     *      * @param period  the period to reduce this instant by     * @return a copy of this instance with the period taken away     * @throws ArithmeticException if the new time exceeds capacity     */
/**     * Returns a copy of this time minus the specified number of hours.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay subtracted = dt.minusHours(6);     * TimeOfDay subtracted = dt.minus(Period.hours(6));     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);     * </pre>     *     * @param hours  the amount of hours to subtract, may be negative     * @return the new time minus the increased hours     * @since 1.1     */
/**     * Returns a copy of this time minus the specified number of minutes.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay subtracted = dt.minusMinutes(6);     * TimeOfDay subtracted = dt.minus(Period.minutes(6));     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);     * </pre>     *     * @param minutes  the amount of minutes to subtract, may be negative     * @return the new time minus the increased minutes     * @since 1.1     */
/**     * Returns a copy of this time minus the specified number of seconds.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay subtracted = dt.minusSeconds(6);     * TimeOfDay subtracted = dt.minus(Period.seconds(6));     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);     * </pre>     *     * @param seconds  the amount of seconds to subtract, may be negative     * @return the new time minus the increased seconds     * @since 1.1     */
/**     * Returns a copy of this time minus the specified number of millis.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay subtracted = dt.minusMillis(6);     * TimeOfDay subtracted = dt.minus(Period.millis(6));     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);     * </pre>     *     * @param millis  the amount of millis to subtract, may be negative     * @return the new time minus the increased millis     * @since 1.1     */
/**     * Returns a copy of this time with the hour of day field updated.     * <p>     * TimeOfDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * hour of day changed.     *     * @param hour  the hour of day to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this time with the minute of hour field updated.     * <p>     * TimeOfDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * minute of hour changed.     *     * @param minute  the minute of hour to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this time with the second of minute field updated.     * <p>     * TimeOfDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * second of minute changed.     *     * @param second  the second of minute to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this time with the millis of second field updated.     * <p>     * TimeOfDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * millis of second changed.     *     * @param millis  the millis of second to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**         * Gets the partial that this property belongs to.         *          * @return the partial         */
/**         * Adds to the value of this field in a copy of this TimeOfDay,         * wrapping to what would be the next day if necessary.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it will affect larger fields.         * Smaller fields are unaffected.         * <p>         * If the result would be too large, beyond 23:59:59:999, then the         * calculation wraps to 00:00:00.000. For the alternate strict behaviour         * with no wrapping see {@link #addNoWrapToCopy(int)}.         * <p>         * The TimeOfDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the TimeOfDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to the value of this field in a copy of this TimeOfDay,         * throwing an Exception if the bounds are exceeded.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it will affect larger fields.         * Smaller fields are unaffected.         * <p>         * If the result would be too large (beyond 23:59:59:999) or too         * small (less than 00:00:00.000) then an Execption is thrown.         * For the alternate behaviour which wraps to the next 'day',         * see {@link #addToCopy(int)}.         * <p>         * The TimeOfDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the TimeOfDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to the value of this field in a copy of this TimeOfDay wrapping         * within this field if the maximum value is reached.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it wraps within this field.         * Other fields are unaffected.         * <p>         * For example,         * <code>12:59:37</code> addWrapField one minute returns <code>12:00:37</code>.         * <p>         * The TimeOfDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the TimeOfDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the TimeOfDay.         * <p>         * The TimeOfDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param value  the value to set the field in the copy to         * @return a copy of the TimeOfDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the TimeOfDay to a parsed text value.         * <p>         * The TimeOfDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @param locale  optional locale to use for selecting a text symbol         * @return a copy of the TimeOfDay with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Sets this field in a copy of the TimeOfDay to a parsed text value.         * <p>         * The TimeOfDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @return a copy of the TimeOfDay with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new TimeOfDay with this field set to the maximum value         * for this field.         * <p>         * The TimeOfDay attached to this property is unchanged by this call.         *         * @return a copy of the TimeOfDay with this field set to its maximum         * @since 1.2         */
/**         * Returns a new TimeOfDay with this field set to the minimum value         * for this field.         * <p>         * The TimeOfDay attached to this property is unchanged by this call.         *         * @return a copy of the TimeOfDay with this field set to its minimum         * @since 1.2         */
/**     * Constructs a TimeOfDay from a <code>java.util.Calendar</code>     * using exactly the same field values avoiding any time zone effects.     * <p>     * Each field is queried from the Calendar and assigned to the TimeOfDay.     * This is useful to ensure that the field values are the same in the     * created TimeOfDay no matter what the time zone is. For example, if     * the Calendar states that the time is 04:29, then the created TimeOfDay     * will always have the time 04:29 irrespective of time zone issues.     * <p>     * This factory method ignores the type of the calendar and always     * creates a TimeOfDay with ISO chronology.     *     * @param calendar  the Calendar to extract fields from     * @return the created TimeOfDay     * @throws IllegalArgumentException if the calendar is null     * @throws IllegalArgumentException if the time is invalid for the ISO chronology     * @since 1.2     */
/**     * Constructs a TimeOfDay from a <code>java.util.Date</code>     * using exactly the same field values avoiding any time zone effects.     * <p>     * Each field is queried from the Date and assigned to the TimeOfDay.     * This is useful to ensure that the field values are the same in the     * created TimeOfDay no matter what the time zone is. For example, if     * the Calendar states that the time is 04:29, then the created TimeOfDay     * will always have the time 04:29 irrespective of time zone issues.     * <p>     * This factory method always creates a TimeOfDay with ISO chronology.     *     * @param date  the Date to extract fields from     * @return the created TimeOfDay     * @throws IllegalArgumentException if the calendar is null     * @throws IllegalArgumentException if the date is invalid for the ISO chronology     * @since 1.2     */
/**     * Constructs a TimeOfDay from the specified millis of day using the     * specified chronology.     * <p>     * The millisOfDay value may exceed the number of millis in one day,     * but additional days will be ignored.     * This method uses the UTC time zone internally.     *     * @param millisOfDay  the number of milliseconds into a day to convert     * @param chrono  the chronology, null means ISO chronology     */
/**     * Gets the number of fields in this partial.     *      * @return the field count     */
/**         * Gets the field that this property uses.         *          * @return the field         */
/**     * Gets the field type at the specified index.     *     * @param index  the index to retrieve     * @return the field at the specified index     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Gets an array of the field type of each of the fields that this partial supports.     * <p>     * The fields are returned largest to smallest, Hour, Minute, Second, Millis.     *     * @return the array of field types (cloned), largest to smallest     */
/**     * Returns a copy of this time with the specified chronology.     * This instance is immutable and unaffected by this method call.     * <p>     * This method retains the values of the fields, thus the result will     * typically refer to a different instant.     * <p>     * The time zone of the specified chronology is ignored, as TimeOfDay     * operates without a time zone.     *     * @param newChronology  the new chronology, null means ISO     * @return a copy of this datetime with a different chronology     * @throws IllegalArgumentException if the values are invalid for the new chronology     */
/**     * Returns a copy of this time with the specified field set to a new value.     * <p>     * For example, if the field type is <code>minuteOfHour</code> then the day     * would be changed in the returned instance.     * <p>     * These three lines are equivalent:     * <pre>     * TimeOfDay updated = tod.withField(DateTimeFieldType.minuteOfHour(), 6);     * TimeOfDay updated = tod.minuteOfHour().setCopy(6);     * TimeOfDay updated = tod.property(DateTimeFieldType.minuteOfHour()).setCopy(6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this instance with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this time with the value of the specified field increased,     * wrapping to what would be a new day if required.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * TimeOfDay added = tod.withFieldAdded(DurationFieldType.minutes(), 6);     * TimeOfDay added = tod.plusMinutes(6);     * TimeOfDay added = tod.minuteOfHour().addToCopy(6);     * </pre>     *      * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this instance with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new datetime exceeds the capacity     */
/**     * Returns a copy of this time with the specified period added,     * wrapping to what would be a new day if required.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * Fields in the period that aren't present in the partial are ignored.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusHours(int)}.     *      * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this instance with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity     */
/**     * Returns a copy of this time with the specified period added,     * wrapping to what would be a new day if required.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusHours(int)}.     *      * @param period  the duration to add to this one, null means zero     * @return a copy of this instance with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this time plus the specified number of hours.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay added = dt.plusHours(6);     * TimeOfDay added = dt.plus(Period.hours(6));     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.hours(), 6);     * </pre>     *     * @param hours  the amount of hours to add, may be negative     * @return the new time plus the increased hours     * @since 1.1     */
/**     * Returns a copy of this time plus the specified number of minutes.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay added = dt.plusMinutes(6);     * TimeOfDay added = dt.plus(Period.minutes(6));     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.minutes(), 6);     * </pre>     *     * @param minutes  the amount of minutes to add, may be negative     * @return the new time plus the increased minutes     * @since 1.1     */
/**     * Returns a copy of this time plus the specified number of seconds.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay added = dt.plusSeconds(6);     * TimeOfDay added = dt.plus(Period.seconds(6));     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.seconds(), 6);     * </pre>     *     * @param seconds  the amount of seconds to add, may be negative     * @return the new time plus the increased seconds     * @since 1.1     */
/**     * Returns a copy of this time plus the specified number of millis.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay added = dt.plusMillis(6);     * TimeOfDay added = dt.plus(Period.millis(6));     * TimeOfDay added = dt.withFieldAdded(DurationFieldType.millis(), 6);     * </pre>     *     * @param millis  the amount of millis to add, may be negative     * @return the new time plus the increased millis     * @since 1.1     */
/**     * Returns a copy of this time with the specified period taken away,     * wrapping to what would be a new day if required.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusHours(int)}.     *      * @param period  the period to reduce this instant by     * @return a copy of this instance with the period taken away     * @throws ArithmeticException if the new time exceeds capacity     */
/**     * Returns a copy of this time minus the specified number of hours.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay subtracted = dt.minusHours(6);     * TimeOfDay subtracted = dt.minus(Period.hours(6));     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);     * </pre>     *     * @param hours  the amount of hours to subtract, may be negative     * @return the new time minus the increased hours     * @since 1.1     */
/**     * Returns a copy of this time minus the specified number of minutes.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay subtracted = dt.minusMinutes(6);     * TimeOfDay subtracted = dt.minus(Period.minutes(6));     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);     * </pre>     *     * @param minutes  the amount of minutes to subtract, may be negative     * @return the new time minus the increased minutes     * @since 1.1     */
/**     * Returns a copy of this time minus the specified number of seconds.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay subtracted = dt.minusSeconds(6);     * TimeOfDay subtracted = dt.minus(Period.seconds(6));     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);     * </pre>     *     * @param seconds  the amount of seconds to subtract, may be negative     * @return the new time minus the increased seconds     * @since 1.1     */
/**     * Returns a copy of this time minus the specified number of millis.     * <p>     * This time instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * TimeOfDay subtracted = dt.minusMillis(6);     * TimeOfDay subtracted = dt.minus(Period.millis(6));     * TimeOfDay subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);     * </pre>     *     * @param millis  the amount of millis to subtract, may be negative     * @return the new time minus the increased millis     * @since 1.1     */
/**     * Converts this object to a LocalTime with the same time and chronology.     *     * @return a LocalTime with the same time and chronology     * @since 1.3     */
/**     * Converts this partial to a full datetime using the specified time zone     * setting the time fields from this instance and the date fields from     * the current time.     * <p>     * This method uses the chronology from this instance plus the time zone     * specified.     *     * @param zone  the zone to use, null means default     * @return this date as a datetime with the time as the current time     */
/**     * Get the hour of day (0-23) field value.     *     * @return the hour of day     */
/**     * Get the minute of hour field value.     *     * @return the minute of hour     */
/**     * Get the second of minute field value.     *     * @return the second of minute     */
/**     * Get the millis of second field value.     *     * @return the millis of second     */
/**     * Returns a copy of this time with the hour of day field updated.     * <p>     * TimeOfDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * hour of day changed.     *     * @param hour  the hour of day to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this time with the minute of hour field updated.     * <p>     * TimeOfDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * minute of hour changed.     *     * @param minute  the minute of hour to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this time with the second of minute field updated.     * <p>     * TimeOfDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * second of minute changed.     *     * @param second  the second of minute to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this time with the millis of second field updated.     * <p>     * TimeOfDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * millis of second changed.     *     * @param millis  the millis of second to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Get the hour of day field property which provides access to advanced functionality.     *      * @return the hour of day property     */
/**     * Get the minute of hour field property which provides access to advanced functionality.     *      * @return the minute of hour property     */
/**     * Get the second of minute field property which provides access to advanced functionality.     *      * @return the second of minute property     */
/**     * Get the millis of second property which provides access to advanced functionality.     *      * @return the millis of second property     */
/**     * Output the time in the ISO8601 format THH:mm:ss.SSS.     *      * @return ISO8601 formatted string     */
/**         * Gets the partial that this property belongs to.         *          * @return the partial         */
/**         * Gets the partial that this property belongs to.         *          * @return the partial         */
/**         * Gets the value of this field.         *          * @return the field value         */
/**         * Adds to the value of this field in a copy of this TimeOfDay,         * wrapping to what would be the next day if necessary.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it will affect larger fields.         * Smaller fields are unaffected.         * <p>         * If the result would be too large, beyond 23:59:59:999, then the         * calculation wraps to 00:00:00.000. For the alternate strict behaviour         * with no wrapping see {@link #addNoWrapToCopy(int)}.         * <p>         * The TimeOfDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the TimeOfDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to the value of this field in a copy of this TimeOfDay,         * throwing an Exception if the bounds are exceeded.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it will affect larger fields.         * Smaller fields are unaffected.         * <p>         * If the result would be too large (beyond 23:59:59:999) or too         * small (less than 00:00:00.000) then an Execption is thrown.         * For the alternate behaviour which wraps to the next 'day',         * see {@link #addToCopy(int)}.         * <p>         * The TimeOfDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the TimeOfDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to the value of this field in a copy of this TimeOfDay wrapping         * within this field if the maximum value is reached.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it wraps within this field.         * Other fields are unaffected.         * <p>         * For example,         * <code>12:59:37</code> addWrapField one minute returns <code>12:00:37</code>.         * <p>         * The TimeOfDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the TimeOfDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the TimeOfDay to a parsed text value.         * <p>         * The TimeOfDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @return a copy of the TimeOfDay with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new TimeOfDay with this field set to the maximum value         * for this field.         * <p>         * The TimeOfDay attached to this property is unchanged by this call.         *         * @return a copy of the TimeOfDay with this field set to its maximum         * @since 1.2         */
/**         * Returns a new TimeOfDay with this field set to the minimum value         * for this field.         * <p>         * The TimeOfDay attached to this property is unchanged by this call.         *         * @return a copy of the TimeOfDay with this field set to its minimum         * @since 1.2         */
/**     * Returns a new instance with the specified number of weeks added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to add, may be negative     * @return the new period plus the specified number of weeks     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of weeks added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to add, may be negative, null means zero     * @return the new period plus the specified number of weeks     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of weeks taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to take away, may be negative     * @return the new period minus the specified number of weeks     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of weeks taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to take away, may be negative, null means zero     * @return the new period minus the specified number of weeks     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the weeks multiplied by the specified scalar.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param scalar  the amount to multiply by, may be negative     * @return the new period multiplied by the specified scalar     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the weeks divided by the specified divisor.     * The calculation uses integer division, thus 3 divided by 2 is 1.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param divisor  the amount to divide by, may be negative     * @return the new period divided by the specified divisor     * @throws ArithmeticException if the divisor is zero     */
/**     * Returns a new instance with the weeks value negated.     *     * @return the new period with a negated value     * @throws ArithmeticException if the result overflows an int     */
/**     * Obtains an instance of <code>Weeks</code> that may be cached.     * <code>Weeks</code> is immutable, so instances can be cached and shared.     * This factory method provides access to shared instances.     *     * @param weeks  the number of weeks to obtain an instance for     * @return the instance of Weeks     */
/**     * Creates a <code>Weeks</code> representing the number of whole weeks     * between the two specified partial datetimes.     * <p>     * The two partials must contain the same fields, for example you can specify     * two <code>LocalDate</code> objects.     *     * @param start  the start partial date, must not be null     * @param end  the end partial date, must not be null     * @return the period in weeks     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Creates a <code>Weeks</code> representing the number of whole weeks     * in the specified interval.     *     * @param interval  the interval to extract weeks from, null returns zero     * @return the period in weeks     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Creates a new <code>Weeks</code> representing the number of complete     * standard length weeks in the specified period.     * <p>     * This factory method converts all fields from the period to hours using standardised     * durations for each field. Only those fields which have a precise duration in     * the ISO UTC chronology can be converted.     * <ul>     * <li>One week consists of 7 days.     * <li>One day consists of 24 hours.     * <li>One hour consists of 60 minutes.     * <li>One minute consists of 60 weeks.     * <li>One second consists of 1000 milliseconds.     * </ul>     * Months and Years are imprecise and periods containing these values cannot be converted.     *     * @param period  the period to get the number of hours from, null returns zero     * @return the period in weeks     * @throws IllegalArgumentException if the period contains imprecise duration values     */
/**     * Resolves singletons.     *      * @return the singleton instance     */
/**     * Gets the duration field type, which is <code>weeks</code>.     *     * @return the period type     */
/**     * Gets the period type, which is <code>weeks</code>.     *     * @return the period type     */
/**     * Converts this period in weeks to a period in days assuming a     * 7 day week.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all weeks are     * 7 days long.     * This may not be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of days for this number of weeks     * @throws ArithmeticException if the number of days is too large to be represented     */
/**     * Converts this period in weeks to a period in hours assuming a     * 7 day week and 24 hour day.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all weeks are     * 7 days long and all days are 24 hours long.     * This is not true when daylight savings is considered and may also not     * be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of hours for this number of weeks     * @throws ArithmeticException if the number of hours is too large to be represented     */
/**     * Converts this period in weeks to a period in minutes assuming a     * 7 day week, 24 hour day and 60 minute hour.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all weeks are     * 7 days long, all days are 24 hours long and all hours are 60 minutes long.     * This is not true when daylight savings is considered and may also not     * be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of minutes for this number of weeks     * @throws ArithmeticException if the number of minutes is too large to be represented     */
/**     * Converts this period in weeks to a period in seconds assuming a     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert between different types of period.     * However to achieve this it makes the assumption that all weeks are     * 7 days long, all days are 24 hours long, all hours are 60 minutes long     * and all minutes are 60 seconds long.     * This is not true when daylight savings is considered and may also not     * be true for some unusual chronologies. However, it is included     * as it is a useful operation for many applications and business rules.     *      * @return a period representing the number of seconds for this number of weeks     * @throws ArithmeticException if the number of seconds is too large to be represented     */
/**     * Converts this period in weeks to a duration in milliweeks assuming a     * 7 day week, 24 hour day, 60 minute hour and 60 second minute.     * <p>     * This method allows you to convert from a period to a duration.     * However to achieve this it makes the assumption that all weeks are     * 7 days long, all days are 24 hours long, all hours are 60 minutes long     * and all minutes are 60 seconds long.     * This is not true when daylight savings time is considered, and may also     * not be true for some unusual chronologies. However, it is included as it     * is a useful operation for many applications and business rules.     *      * @return a duration equivalent to this number of weeks     */
/**     * Gets the number of weeks that this period represents.     *     * @return the number of weeks in the period     */
/**     * Returns a new instance with the specified number of weeks added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to add, may be negative, null means zero     * @return the new period plus the specified number of weeks     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of weeks taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param weeks  the amount of weeks to take away, may be negative, null means zero     * @return the new period minus the specified number of weeks     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the weeks multiplied by the specified scalar.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param scalar  the amount to multiply by, may be negative     * @return the new period multiplied by the specified scalar     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the weeks divided by the specified divisor.     * The calculation uses integer division, thus 3 divided by 2 is 1.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param divisor  the amount to divide by, may be negative     * @return the new period divided by the specified divisor     * @throws ArithmeticException if the divisor is zero     */
/**     * Returns a new instance with the weeks value negated.     *     * @return the new period with a negated value     * @throws ArithmeticException if the result overflows an int     */
/**     * Is this weeks instance greater than the specified number of weeks.     *     * @param other  the other period, null means zero     * @return true if this weeks instance is greater than the specified one     */
/**     * Is this weeks instance less than the specified number of weeks.     *     * @param other  the other period, null means zero     * @return true if this weeks instance is less than the specified one     */
/**     * Constructs a YearMonth with the current year-month, using ISOChronology in     * the default zone to extract the fields.     * <p>     * The constructor uses the default time zone, resulting in the local time     * being initialised. Once the constructor is complete, all further calculations     * are performed without reference to a time-zone (by switching to UTC).     *      * @see #now()     */
/**     * Constructs a YearMonth with the current year-month, using ISOChronology in     * the specified zone to extract the fields.     * <p>     * The constructor uses the specified time zone to obtain the current year-month.     * Once the constructor is complete, all further calculations     * are performed without reference to a time-zone (by switching to UTC).     *      * @param zone  the zone to use, null means default zone     * @see #now(DateTimeZone)     */
/**     * Constructs a YearMonth with the current year-month, using the specified chronology     * and zone to extract the fields.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a time-zone (by switching to UTC).     *     * @param chronology  the chronology, null means ISOChronology in the default zone     * @see #now(Chronology)     */
/**     * Constructs a YearMonth extracting the partial fields from the specified     * milliseconds using the ISOChronology in the default zone.     * <p>     * The constructor uses the default time zone, resulting in the local time     * being initialised. Once the constructor is complete, all further calculations     * are performed without reference to a time-zone (by switching to UTC).     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     */
/**     * Constructs a YearMonth extracting the partial fields from the specified     * milliseconds using the chronology provided.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a time-zone (by switching to UTC).     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param chronology  the chronology, null means ISOChronology in the default zone     */
/**     * Constructs a YearMonth from an Object that represents some form of time.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.     * <p>     * The chronology used will be derived from the object, defaulting to ISO.     *     * @param instant  the date-time object, null means now     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs a YearMonth from an Object that represents some form of time,     * using the specified chronology.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#localDateParser()}.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a time-zone (by switching to UTC).     * The specified chronology overrides that of the object.     *     * @param instant  the date-time object, null means now     * @param chronology  the chronology, null means ISO default     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs a YearMonth with specified year and month     * using <code>ISOChronology</code>.     * <p>     * The constructor uses the no time zone initialising the fields as provided.     * Once the constructor is complete, all further calculations     * are performed without reference to a time-zone (by switching to UTC).     *     * @param year  the year     * @param monthOfYear  the month of the year     */
/**     * Constructs an instance set to the specified year and month     * using the specified chronology, whose zone is ignored.     * <p>     * If the chronology is null, <code>ISOChronology</code> is used.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a time-zone (by switching to UTC).     *     * @param year  the year     * @param monthOfYear  the month of the year     * @param chronology  the chronology, null means ISOChronology in the default zone     */
/**     * Returns a copy of this year-month with the specified chronology.     * This instance is immutable and unaffected by this method call.     * <p>     * This method retains the values of the fields, thus the result will     * typically refer to a different instant.     * <p>     * The time zone of the specified chronology is ignored, as YearMonth     * operates without a time zone.     *     * @param newChronology  the new chronology, null means ISO     * @return a copy of this year-month with a different chronology, never null     * @throws IllegalArgumentException if the values are invalid for the new chronology     */
/**     * Returns a copy of this year-month with the specified field set to a new value.     * <p>     * For example, if the field type is <code>monthOfYear</code> then the month     * would be changed in the returned instance.     * <p>     * These three lines are equivalent:     * <pre>     * YearMonth updated = ym.withField(DateTimeFieldType.monthOfYear(), 6);     * YearMonth updated = ym.monthOfYear().setCopy(6);     * YearMonth updated = ym.property(DateTimeFieldType.monthOfYear()).setCopy(6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this instance with the field set, never null     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this year-month with the value of the specified field increased.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6);     * YearMonth added = ym.plusMonths(6);     * YearMonth added = ym.monthOfYear().addToCopy(6);     * </pre>     *      * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this instance with the field updated, never null     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new date-time exceeds the capacity     */
/**     * Returns a copy of this year-month with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * Fields in the period that aren't present in the partial are ignored.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusYears(int)}.     *      * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this instance with the period added, never null     * @throws ArithmeticException if the new date-time exceeds the capacity     */
/**     * Returns a copy of this year-month with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusYears(int)}.     *      * @param period  the duration to add to this one, null means zero     * @return a copy of this instance with the period added, never null     * @throws ArithmeticException if the new year-month exceeds the capacity     */
/**     * Returns a copy of this year-month plus the specified number of years.     * <p>     * This year-month instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonth added = ym.plusYears(6);     * YearMonth added = ym.plus(Period.years(6));     * YearMonth added = ym.withFieldAdded(DurationFieldType.years(), 6);     * </pre>     *     * @param years  the amount of years to add, may be negative     * @return the new year-month plus the increased years, never null     */
/**     * Returns a copy of this year-month plus the specified number of months.     * <p>     * This year-month instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonth added = ym.plusMonths(6);     * YearMonth added = ym.plus(Period.months(6));     * YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6);     * </pre>     *     * @param months  the amount of months to add, may be negative     * @return the new year-month plus the increased months, never null     */
/**     * Returns a copy of this year-month with the specified period taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusYears(int)}.     *      * @param period  the period to reduce this instant by     * @return a copy of this instance with the period taken away, never null     * @throws ArithmeticException if the new year-month exceeds the capacity     */
/**     * Returns a copy of this year-month minus the specified number of years.     * <p>     * This year-month instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonth subtracted = ym.minusYears(6);     * YearMonth subtracted = ym.minus(Period.years(6));     * YearMonth subtracted = ym.withFieldAdded(DurationFieldType.years(), -6);     * </pre>     *     * @param years  the amount of years to subtract, may be negative     * @return the new year-month minus the increased years, never null     */
/**     * Returns a copy of this year-month minus the specified number of months.     * <p>     * This year-month instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonth subtracted = ym.minusMonths(6);     * YearMonth subtracted = ym.minus(Period.months(6));     * YearMonth subtracted = ym.withFieldAdded(DurationFieldType.months(), -6);     * </pre>     *     * @param months  the amount of months to subtract, may be negative     * @return the new year-month minus the increased months, never null     */
/**     * Returns a copy of this year-month with the year field updated.     * <p>     * YearMonth is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year changed.     *     * @param year  the year to set     * @return a copy of this object with the field set, never null     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this year-month with the month of year field updated.     * <p>     * YearMonth is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * month of year changed.     *     * @param monthOfYear  the month of year to set     * @return a copy of this object with the field set, never null     * @throws IllegalArgumentException if the value is invalid     */
/**         * Gets the partial that this property belongs to.         *          * @return the partial         */
/**         * Adds to the value of this field in a copy of this YearMonth.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it will affect larger fields.         * Smaller fields are unaffected.         * <p>         * If the result would be too large, beyond the maximum year, then an         * IllegalArgumentException is thrown.         * <p>         * The YearMonth attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the YearMonth with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to the value of this field in a copy of this YearMonth wrapping         * within this field if the maximum value is reached.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it wraps within this field.         * Other fields are unaffected.         * <p>         * For example,         * <code>2004-12</code> addWrapField one month returns <code>2004-01</code>.         * <p>         * The YearMonth attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the YearMonth with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the YearMonth.         * <p>         * The YearMonth attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param value  the value to set the field in the copy to         * @return a copy of the YearMonth with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the YearMonth to a parsed text value.         * <p>         * The YearMonth attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @param locale  optional locale to use for selecting a text symbol         * @return a copy of the YearMonth with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Sets this field in a copy of the YearMonth to a parsed text value.         * <p>         * The YearMonth attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @return a copy of the YearMonth with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**     * Obtains a {@code YearMonth} set to the current system millisecond time     * using the specified chronology.     * The resulting object does not use the zone.     *     * @param chronology  the chronology, not null     * @return the current year-month, not null     * @since 2.0     */
/**     * Parses a {@code YearMonth} from the specified string using a formatter.     *      * @param str  the string to parse, not null     * @param formatter  the formatter to use, not null     * @since 2.0     */
/**     * Constructs a YearMonth from a <code>java.util.Calendar</code>     * using exactly the same field values avoiding any time zone effects.     * <p>     * Each field is queried from the Calendar and assigned to the YearMonth.     * <p>     * This factory method ignores the type of the calendar and always     * creates a YearMonth with ISO chronology. It is expected that you     * will only pass in instances of <code>GregorianCalendar</code> however     * this is not validated.     *     * @param calendar  the Calendar to extract fields from     * @return the created YearMonth, never null     * @throws IllegalArgumentException if the calendar is null     * @throws IllegalArgumentException if the year or month is invalid for the ISO chronology     */
/**     * Handle broken serialization from other tools.     * @return the resolved object, not null     */
/**     * Gets the number of fields in this partial, which is two.     * The supported fields are Year and MonthOfYear.     * Note that only these fields may be queried.     *     * @return the field count, two     */
/**     * Gets an array of the field type of each of the fields that this partial supports.     * <p>     * The fields are returned largest to smallest, Year, Month.     *     * @return the array of field types (cloned), largest to smallest, never null     */
/**     * Returns a copy of this year-month with the specified chronology.     * This instance is immutable and unaffected by this method call.     * <p>     * This method retains the values of the fields, thus the result will     * typically refer to a different instant.     * <p>     * The time zone of the specified chronology is ignored, as YearMonth     * operates without a time zone.     *     * @param newChronology  the new chronology, null means ISO     * @return a copy of this year-month with a different chronology, never null     * @throws IllegalArgumentException if the values are invalid for the new chronology     */
/**     * Returns a copy of this year-month with the specified field set to a new value.     * <p>     * For example, if the field type is <code>monthOfYear</code> then the month     * would be changed in the returned instance.     * <p>     * These three lines are equivalent:     * <pre>     * YearMonth updated = ym.withField(DateTimeFieldType.monthOfYear(), 6);     * YearMonth updated = ym.monthOfYear().setCopy(6);     * YearMonth updated = ym.property(DateTimeFieldType.monthOfYear()).setCopy(6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this instance with the field set, never null     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this year-month with the value of the specified field increased.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6);     * YearMonth added = ym.plusMonths(6);     * YearMonth added = ym.monthOfYear().addToCopy(6);     * </pre>     *      * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this instance with the field updated, never null     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new date-time exceeds the capacity     */
/**     * Returns a copy of this year-month with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * Fields in the period that aren't present in the partial are ignored.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusYears(int)}.     *      * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this instance with the period added, never null     * @throws ArithmeticException if the new date-time exceeds the capacity     */
/**     * Returns a copy of this year-month with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusYears(int)}.     *      * @param period  the duration to add to this one, null means zero     * @return a copy of this instance with the period added, never null     * @throws ArithmeticException if the new year-month exceeds the capacity     */
/**     * Returns a copy of this year-month plus the specified number of years.     * <p>     * This year-month instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonth added = ym.plusYears(6);     * YearMonth added = ym.plus(Period.years(6));     * YearMonth added = ym.withFieldAdded(DurationFieldType.years(), 6);     * </pre>     *     * @param years  the amount of years to add, may be negative     * @return the new year-month plus the increased years, never null     */
/**     * Returns a copy of this year-month plus the specified number of months.     * <p>     * This year-month instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonth added = ym.plusMonths(6);     * YearMonth added = ym.plus(Period.months(6));     * YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6);     * </pre>     *     * @param months  the amount of months to add, may be negative     * @return the new year-month plus the increased months, never null     */
/**     * Returns a copy of this year-month with the specified period taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusYears(int)}.     *      * @param period  the period to reduce this instant by     * @return a copy of this instance with the period taken away, never null     * @throws ArithmeticException if the new year-month exceeds the capacity     */
/**     * Returns a copy of this year-month minus the specified number of years.     * <p>     * This year-month instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonth subtracted = ym.minusYears(6);     * YearMonth subtracted = ym.minus(Period.years(6));     * YearMonth subtracted = ym.withFieldAdded(DurationFieldType.years(), -6);     * </pre>     *     * @param years  the amount of years to subtract, may be negative     * @return the new year-month minus the increased years, never null     */
/**     * Returns a copy of this year-month minus the specified number of months.     * <p>     * This year-month instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonth subtracted = ym.minusMonths(6);     * YearMonth subtracted = ym.minus(Period.months(6));     * YearMonth subtracted = ym.withFieldAdded(DurationFieldType.months(), -6);     * </pre>     *     * @param months  the amount of months to subtract, may be negative     * @return the new year-month minus the increased months, never null     */
/**     * Converts this object to a LocalDate with the same year-month and chronology.     *     * @param dayOfMonth the day of month to use, valid for chronology, such as 1-31 for ISO     * @return a LocalDate with the same year-month and chronology, never null     */
/**     * Converts this object to an Interval representing the whole month.     * <p>     * The interval will use the chronology of the year-month in the specified zone.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param zone  the zone to get the Interval in, null means default     * @return an interval over the month, never null     */
/**     * Get the year field value.     *     * @return the year     */
/**     * Returns a copy of this year-month with the year field updated.     * <p>     * YearMonth is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year changed.     *     * @param year  the year to set     * @return a copy of this object with the field set, never null     * @throws IllegalArgumentException if the value is invalid     */
/**     * Returns a copy of this year-month with the month of year field updated.     * <p>     * YearMonth is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * month of year changed.     *     * @param monthOfYear  the month of year to set     * @return a copy of this object with the field set, never null     * @throws IllegalArgumentException if the value is invalid     */
/**     * Get the year field property which provides access to advanced functionality.     *      * @return the year property     */
/**     * Output the year-month using the specified format pattern.     *     * @param pattern  the pattern specification, null means use <code>toString</code>     * @param locale  Locale to use, null means default     * @see org.joda.time.format.DateTimeFormat     */
/**         * Gets the partial that this property belongs to.         *          * @return the partial         */
/**         * Adds to the value of this field in a copy of this YearMonth.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it will affect larger fields.         * Smaller fields are unaffected.         * <p>         * If the result would be too large, beyond the maximum year, then an         * IllegalArgumentException is thrown.         * <p>         * The YearMonth attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the YearMonth with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to the value of this field in a copy of this YearMonth wrapping         * within this field if the maximum value is reached.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it wraps within this field.         * Other fields are unaffected.         * <p>         * For example,         * <code>2004-12</code> addWrapField one month returns <code>2004-01</code>.         * <p>         * The YearMonth attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the YearMonth with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the YearMonth to a parsed text value.         * <p>         * The YearMonth attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @return a copy of the YearMonth with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**     * Constructs a YearMonthDay with the current date, using ISOChronology in     * the default zone to extract the fields.     * <p>     * The constructor uses the default time zone, resulting in the local time     * being initialised. Once the constructor is complete, all further calculations     * are performed without reference to a timezone (by switching to UTC).     */
/**     * Constructs a YearMonthDay with the current date, using ISOChronology in     * the specified zone to extract the fields.     * <p>     * The constructor uses the specified time zone to obtain the current date.     * Once the constructor is complete, all further calculations     * are performed without reference to a timezone (by switching to UTC).     *      * @param zone  the zone to use, null means default zone     * @since 1.1     */
/**     * Constructs a YearMonthDay with the current date, using the specified chronology     * and zone to extract the fields.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a timezone (by switching to UTC).     *     * @param chronology  the chronology, null means ISOChronology in the default zone     */
/**     * Constructs a YearMonthDay extracting the partial fields from the specified     * milliseconds using the ISOChronology in the default zone.     * <p>     * The constructor uses the default time zone, resulting in the local time     * being initialised. Once the constructor is complete, all further calculations     * are performed without reference to a timezone (by switching to UTC).     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     */
/**     * Constructs a YearMonthDay extracting the partial fields from the specified     * milliseconds using the chronology provided.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a timezone (by switching to UTC).     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param chronology  the chronology, null means ISOChronology in the default zone     */
/**     * Constructs a YearMonthDay from an Object that represents a time.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.     * <p>     * The chronology used will be derived from the object, defaulting to ISO.     * <p>     * NOTE: Prior to v1.3 the string format was described by     * {@link ISODateTimeFormat#dateTimeParser()}. Time ony strings are now rejected.     *     * @param instant  the datetime object, null means now     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs a YearMonthDay from an Object that represents a time, using the     * specified chronology.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     * The String formats are described by {@link ISODateTimeFormat#dateOptionalTimeParser()}.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a timezone (by switching to UTC).     * The specified chronology overrides that of the object.     * <p>     * NOTE: Prior to v1.3 the string format was described by     * {@link ISODateTimeFormat#dateTimeParser()}. Time only strings are now rejected.     *     * @param instant  the datetime object, null means now     * @param chronology  the chronology, null means ISO default     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs a YearMonthDay with specified time field values     * using <code>ISOChronology</code> in the default zone.     * <p>     * The constructor uses the no time zone initialising the fields as provided.     * Once the constructor is complete, all further calculations     * are performed without reference to a timezone (by switching to UTC).     *     * @param year  the year     * @param monthOfYear  the month of the year     * @param dayOfMonth  the day of the month     */
/**     * Constructs a YearMonthDay with specified time field values.     * <p>     * The constructor uses the time zone of the chronology specified.     * Once the constructor is complete, all further calculations are performed     * without reference to a timezone (by switching to UTC).     *     * @param year  the year     * @param monthOfYear  the month of the year     * @param dayOfMonth  the day of the month     * @param chronology  the chronology, null means ISOChronology in the default zone     */
/**     * Returns a copy of this date with the specified chronology.     * This instance is immutable and unaffected by this method call.     * <p>     * This method retains the values of the fields, thus the result will     * typically refer to a different instant.     * <p>     * The time zone of the specified chronology is ignored, as YearMonthDay     * operates without a time zone.     *     * @param newChronology  the new chronology, null means ISO     * @return a copy of this datetime with a different chronology     * @throws IllegalArgumentException if the values are invalid for the new chronology     */
/**     * Returns a copy of this date with the specified field set to a new value.     * <p>     * For example, if the field type is <code>dayOfMonth</code> then the day     * would be changed in the returned instance.     * <p>     * These three lines are equivalent:     * <pre>     * YearMonthDay updated = ymd.withField(DateTimeFieldType.dayOfMonth(), 6);     * YearMonthDay updated = ymd.dayOfMonth().setCopy(6);     * YearMonthDay updated = ymd.property(DateTimeFieldType.dayOfMonth()).setCopy(6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this instance with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this date with the value of the specified field increased.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * YearMonthDay added = ymd.withFieldAdded(DurationFieldType.days(), 6);     * YearMonthDay added = ymd.plusDays(6);     * YearMonthDay added = ymd.dayOfMonth().addToCopy(6);     * </pre>     *      * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this instance with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new datetime exceeds the capacity     */
/**     * Returns a copy of this date with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * Fields in the period that aren't present in the partial are ignored.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusYears(int)}.     *      * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this instance with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity     */
/**     * Returns a copy of this date with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusYears(int)}.     *      * @param period  the duration to add to this one, null means zero     * @return a copy of this instance with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date plus the specified number of years.     * <p>     * This date instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonthDay added = dt.plusYears(6);     * YearMonthDay added = dt.plus(Period.years(6));     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.years(), 6);     * </pre>     *     * @param years  the amount of years to add, may be negative     * @return the new date plus the increased years     * @since 1.1     */
/**     * Returns a copy of this date plus the specified number of months.     * <p>     * This date instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonthDay added = dt.plusMonths(6);     * YearMonthDay added = dt.plus(Period.months(6));     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.months(), 6);     * </pre>     *     * @param months  the amount of months to add, may be negative     * @return the new date plus the increased months     * @since 1.1     */
/**     * Returns a copy of this date plus the specified number of days.     * <p>     * This date instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonthDay added = dt.plusDays(6);     * YearMonthDay added = dt.plus(Period.days(6));     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.days(), 6);     * </pre>     *     * @param days  the amount of days to add, may be negative     * @return the new date plus the increased days     * @since 1.1     */
/**     * Returns a copy of this date with the specified period taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusYears(int)}.     *      * @param period  the period to reduce this instant by     * @return a copy of this instance with the period taken away     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date minus the specified number of years.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonthDay subtracted = dt.minusYears(6);     * YearMonthDay subtracted = dt.minus(Period.years(6));     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);     * </pre>     *     * @param years  the amount of years to subtract, may be negative     * @return the new datetime minus the increased years     * @since 1.1     */
/**     * Returns a copy of this date minus the specified number of months.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonthDay subtracted = dt.minusMonths(6);     * YearMonthDay subtracted = dt.minus(Period.months(6));     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);     * </pre>     *     * @param months  the amount of months to subtract, may be negative     * @return the new datetime minus the increased months     * @since 1.1     */
/**     * Returns a copy of this date minus the specified number of days.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonthDay subtracted = dt.minusDays(6);     * YearMonthDay subtracted = dt.minus(Period.days(6));     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);     * </pre>     *     * @param days  the amount of days to subtract, may be negative     * @return the new datetime minus the increased days     * @since 1.1     */
/**     * Returns a copy of this date with the year field updated.     * <p>     * YearMonthDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year changed.     *     * @param year  the year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the month of year field updated.     * <p>     * YearMonthDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * month of year changed.     *     * @param monthOfYear  the month of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the day of month field updated.     * <p>     * YearMonthDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of month changed.     *     * @param dayOfMonth  the day of month to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**         * Gets the partial that this property belongs to.         *          * @return the partial         */
/**         * Adds to the value of this field in a copy of this YearMonthDay.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it will affect larger fields.         * Smaller fields are unaffected.         * <p>         * If the result would be too large, beyond the maximum year, then an         * IllegalArgumentException is thrown.         * <p>         * The YearMonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the YearMonthDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to the value of this field in a copy of this YearMonthDay wrapping         * within this field if the maximum value is reached.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it wraps within this field.         * Other fields are unaffected.         * <p>         * For example,         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.         * <p>         * The YearMonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the YearMonthDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the YearMonthDay.         * <p>         * The YearMonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param value  the value to set the field in the copy to         * @return a copy of the YearMonthDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the YearMonthDay to a parsed text value.         * <p>         * The YearMonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @param locale  optional locale to use for selecting a text symbol         * @return a copy of the YearMonthDay with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Sets this field in a copy of the YearMonthDay to a parsed text value.         * <p>         * The YearMonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @return a copy of the YearMonthDay with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new YearMonthDay with this field set to the maximum value         * for this field.         * <p>         * This operation is useful for obtaining a DateTime on the last day         * of the month, as month lengths vary.         * <pre>         * YearMonthDay lastDayOfMonth = dt.dayOfMonth().withMaximumValue();         * </pre>         * <p>         * The YearMonthDay attached to this property is unchanged by this call.         *         * @return a copy of the YearMonthDay with this field set to its maximum         * @since 1.2         */
/**         * Returns a new YearMonthDay with this field set to the minimum value         * for this field.         * <p>         * The YearMonthDay attached to this property is unchanged by this call.         *         * @return a copy of the YearMonthDay with this field set to its minimum         * @since 1.2         */
/**     * Constructs a YearMonthDay from a <code>java.util.Calendar</code>     * using exactly the same field values avoiding any time zone effects.     * <p>     * Each field is queried from the Calendar and assigned to the YearMonthDay.     * This is useful if you have been using the Calendar as a local date,     * ignoing the zone.     * <p>     * This factory method ignores the type of the calendar and always     * creates a YearMonthDay with ISO chronology. It is expected that you     * will only pass in instances of <code>GregorianCalendar</code> however     * this is not validated.     *     * @param calendar  the Calendar to extract fields from     * @return the created YearMonthDay     * @throws IllegalArgumentException if the calendar is null     * @throws IllegalArgumentException if the date is invalid for the ISO chronology     * @since 1.2     */
/**     * Constructs a YearMonthDay from a <code>java.util.Date</code>     * using exactly the same field values avoiding any time zone effects.     * <p>     * Each field is queried from the Date and assigned to the YearMonthDay.     * This is useful if you have been using the Date as a local date,     * ignoing the zone.     * <p>     * This factory method always creates a YearMonthDay with ISO chronology.     *     * @param date  the Date to extract fields from     * @return the created YearMonthDay     * @throws IllegalArgumentException if the calendar is null     * @throws IllegalArgumentException if the date is invalid for the ISO chronology     * @since 1.2     */
/**     * Gets the number of fields in this partial.     *      * @return the field count     */
/**         * Gets the field that this property uses.         *          * @return the field         */
/**     * Gets an array of the field type of each of the fields that this partial supports.     * <p>     * The fields are returned largest to smallest, Year, Month, Day     *     * @return the array of field types (cloned), largest to smallest     */
/**     * Returns a copy of this date with the specified chronology.     * This instance is immutable and unaffected by this method call.     * <p>     * This method retains the values of the fields, thus the result will     * typically refer to a different instant.     * <p>     * The time zone of the specified chronology is ignored, as YearMonthDay     * operates without a time zone.     *     * @param newChronology  the new chronology, null means ISO     * @return a copy of this datetime with a different chronology     * @throws IllegalArgumentException if the values are invalid for the new chronology     */
/**     * Returns a copy of this date with the specified field set to a new value.     * <p>     * For example, if the field type is <code>dayOfMonth</code> then the day     * would be changed in the returned instance.     * <p>     * These three lines are equivalent:     * <pre>     * YearMonthDay updated = ymd.withField(DateTimeFieldType.dayOfMonth(), 6);     * YearMonthDay updated = ymd.dayOfMonth().setCopy(6);     * YearMonthDay updated = ymd.property(DateTimeFieldType.dayOfMonth()).setCopy(6);     * </pre>     *     * @param fieldType  the field type to set, not null     * @param value  the value to set     * @return a copy of this instance with the field set     * @throws IllegalArgumentException if the value is null or invalid     */
/**     * Returns a copy of this date with the value of the specified field increased.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * <p>     * These three lines are equivalent:     * <pre>     * YearMonthDay added = ymd.withFieldAdded(DurationFieldType.days(), 6);     * YearMonthDay added = ymd.plusDays(6);     * YearMonthDay added = ymd.dayOfMonth().addToCopy(6);     * </pre>     *      * @param fieldType  the field type to add to, not null     * @param amount  the amount to add     * @return a copy of this instance with the field updated     * @throws IllegalArgumentException if the value is null or invalid     * @throws ArithmeticException if the new datetime exceeds the capacity     */
/**     * Returns a copy of this date with the specified period added.     * <p>     * If the addition is zero, then <code>this</code> is returned.     * Fields in the period that aren't present in the partial are ignored.     * <p>     * This method is typically used to add multiple copies of complex     * period instances. Adding one field is best achieved using methods     * like {@link #withFieldAdded(DurationFieldType, int)}     * or {@link #plusYears(int)}.     *      * @param period  the period to add to this one, null means zero     * @param scalar  the amount of times to add, such as -1 to subtract once     * @return a copy of this instance with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity     */
/**     * Returns a copy of this date with the specified period added.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to add complex period instances.     * Adding one field is best achieved using methods     * like {@link #plusYears(int)}.     *      * @param period  the duration to add to this one, null means zero     * @return a copy of this instance with the period added     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date plus the specified number of years.     * <p>     * This date instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonthDay added = dt.plusYears(6);     * YearMonthDay added = dt.plus(Period.years(6));     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.years(), 6);     * </pre>     *     * @param years  the amount of years to add, may be negative     * @return the new date plus the increased years     * @since 1.1     */
/**     * Returns a copy of this date plus the specified number of months.     * <p>     * This date instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonthDay added = dt.plusMonths(6);     * YearMonthDay added = dt.plus(Period.months(6));     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.months(), 6);     * </pre>     *     * @param months  the amount of months to add, may be negative     * @return the new date plus the increased months     * @since 1.1     */
/**     * Returns a copy of this date plus the specified number of days.     * <p>     * This date instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonthDay added = dt.plusDays(6);     * YearMonthDay added = dt.plus(Period.days(6));     * YearMonthDay added = dt.withFieldAdded(DurationFieldType.days(), 6);     * </pre>     *     * @param days  the amount of days to add, may be negative     * @return the new date plus the increased days     * @since 1.1     */
/**     * Returns a copy of this date with the specified period taken away.     * <p>     * If the amount is zero or null, then <code>this</code> is returned.     * <p>     * This method is typically used to subtract complex period instances.     * Subtracting one field is best achieved using methods     * like {@link #minusYears(int)}.     *      * @param period  the period to reduce this instant by     * @return a copy of this instance with the period taken away     * @throws ArithmeticException if the new datetime exceeds the capacity of a long     */
/**     * Returns a copy of this date minus the specified number of years.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonthDay subtracted = dt.minusYears(6);     * YearMonthDay subtracted = dt.minus(Period.years(6));     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);     * </pre>     *     * @param years  the amount of years to subtract, may be negative     * @return the new datetime minus the increased years     * @since 1.1     */
/**     * Returns a copy of this date minus the specified number of months.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonthDay subtracted = dt.minusMonths(6);     * YearMonthDay subtracted = dt.minus(Period.months(6));     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);     * </pre>     *     * @param months  the amount of months to subtract, may be negative     * @return the new datetime minus the increased months     * @since 1.1     */
/**     * Returns a copy of this date minus the specified number of days.     * <p>     * This datetime instance is immutable and unaffected by this method call.     * <p>     * The following three lines are identical in effect:     * <pre>     * YearMonthDay subtracted = dt.minusDays(6);     * YearMonthDay subtracted = dt.minus(Period.days(6));     * YearMonthDay subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);     * </pre>     *     * @param days  the amount of days to subtract, may be negative     * @return the new datetime minus the increased days     * @since 1.1     */
/**     * Converts this object to a LocalDate with the same date and chronology.     *     * @return a LocalDate with the same date and chronology     * @since 1.3     */
/**     * Converts this YearMonthDay to a full datetime at midnight using the     * specified time zone.     * <p>     * This method uses the chronology from this instance plus the time zone     * specified.     *     * @param zone  the zone to use, null means default     * @return this date as a datetime at midnight     */
/**     * Converts this partial to a full datetime using the specified time zone     * setting the date fields from this instance and the time fields from     * the current time.     * <p>     * This method uses the chronology from this instance plus the time zone     * specified.     *     * @param zone  the zone to use, null means default     * @return this date as a datetime with the time as the current time     */
/**     * Converts this object to a DateMidnight.     *     * @param zone  the zone to get the DateMidnight in, null means default     * @return the DateMidnight instance     */
/**     * Converts this object to a DateTime using a TimeOfDay to fill in the     * missing fields.     * This instance is immutable and unaffected by this method call.     * <p>     * The resulting chronology is determined by the chronology of this     * YearMonthDay plus the time zone.     * The chronology of the time is ignored - only the field values are used.     *     * @param time  the time of day to use, null means current time     * @param zone  the zone to get the DateTime in, null means default     * @return the DateTime instance     */
/**     * Converts this object to an Interval representing the whole day.     *     * @param zone  the zone to get the Interval in, null means default     * @return a interval over the day     */
/**     * Returns a copy of this date with the year field updated.     * <p>     * YearMonthDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * year changed.     *     * @param year  the year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the month of year field updated.     * <p>     * YearMonthDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * month of year changed.     *     * @param monthOfYear  the month of year to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Returns a copy of this date with the day of month field updated.     * <p>     * YearMonthDay is immutable, so there are no set methods.     * Instead, this method returns a new instance with the value of     * day of month changed.     *     * @param dayOfMonth  the day of month to set     * @return a copy of this object with the field set     * @throws IllegalArgumentException if the value is invalid     * @since 1.3     */
/**     * Output the date in the ISO8601 format YYYY-MM-DD.     *      * @return ISO8601 formatted string     */
/**         * Gets the partial that this property belongs to.         *          * @return the partial         */
/**         * Gets the partial that this property belongs to.         *          * @return the partial         */
/**         * Gets the value of this field.         *          * @return the field value         */
/**         * Adds to the value of this field in a copy of this YearMonthDay.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it will affect larger fields.         * Smaller fields are unaffected.         * <p>         * If the result would be too large, beyond the maximum year, then an         * IllegalArgumentException is thrown.         * <p>         * The YearMonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the YearMonthDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Adds to the value of this field in a copy of this YearMonthDay wrapping         * within this field if the maximum value is reached.         * <p>         * The value will be added to this field. If the value is too large to be         * added solely to this field then it wraps within this field.         * Other fields are unaffected.         * <p>         * For example,         * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.         * <p>         * The YearMonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param valueToAdd  the value to add to the field in the copy         * @return a copy of the YearMonthDay with the field value changed         * @throws IllegalArgumentException if the value isn't valid         */
/**         * Sets this field in a copy of the YearMonthDay to a parsed text value.         * <p>         * The YearMonthDay attached to this property is unchanged by this call.         * Instead, a new instance is returned.         *          * @param text  the text value to set         * @return a copy of the YearMonthDay with the field value changed         * @throws IllegalArgumentException if the text value isn't valid         */
/**         * Returns a new YearMonthDay with this field set to the maximum value         * for this field.         * <p>         * This operation is useful for obtaining a DateTime on the last day         * of the month, as month lengths vary.         * <pre>         * YearMonthDay lastDayOfMonth = dt.dayOfMonth().withMaximumValue();         * </pre>         * <p>         * The YearMonthDay attached to this property is unchanged by this call.         *         * @return a copy of the YearMonthDay with this field set to its maximum         * @since 1.2         */
/**         * Returns a new YearMonthDay with this field set to the minimum value         * for this field.         * <p>         * The YearMonthDay attached to this property is unchanged by this call.         *         * @return a copy of the YearMonthDay with this field set to its minimum         * @since 1.2         */
/**     * Returns a new instance with the specified number of years added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to add, may be negative     * @return the new period plus the specified number of years     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of years added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to add, may be negative, null means zero     * @return the new period plus the specified number of years     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of years taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to take away, may be negative     * @return the new period minus the specified number of years     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of years taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to take away, may be negative, null means zero     * @return the new period minus the specified number of years     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the years multiplied by the specified scalar.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param scalar  the amount to multiply by, may be negative     * @return the new period multiplied by the specified scalar     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the years divided by the specified divisor.     * The calculation uses integer division, thus 3 divided by 2 is 1.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param divisor  the amount to divide by, may be negative     * @return the new period divided by the specified divisor     * @throws ArithmeticException if the divisor is zero     */
/**     * Returns a new instance with the years value negated.     *     * @return the new period with a negated value     * @throws ArithmeticException if the result overflows an int     */
/**     * Obtains an instance of <code>Years</code> that may be cached.     * <code>Years</code> is immutable, so instances can be cached and shared.     * This factory method provides access to shared instances.     *     * @param years  the number of years to obtain an instance for     * @return the instance of Years     */
/**     * Creates a <code>Years</code> representing the number of whole years     * between the two specified partial datetimes.     * <p>     * The two partials must contain the same fields, for example you can specify     * two <code>LocalDate</code> objects.     *     * @param start  the start partial date, must not be null     * @param end  the end partial date, must not be null     * @return the period in years     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Creates a <code>Years</code> representing the number of whole years     * in the specified interval. This method corectly handles any daylight     * savings time changes that may occur during the interval.     *     * @param interval  the interval to extract years from, null returns zero     * @return the period in years     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Resolves singletons.     *      * @return the singleton instance     */
/**     * Gets the duration field type, which is <code>years</code>.     *     * @return the period type     */
/**     * Gets the period type, which is <code>years</code>.     *     * @return the period type     */
/**     * Gets the number of years that this period represents.     *     * @return the number of years in the period     */
/**     * Returns a new instance with the specified number of years added.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to add, may be negative, null means zero     * @return the new period plus the specified number of years     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the specified number of years taken away.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param years  the amount of years to take away, may be negative, null means zero     * @return the new period minus the specified number of years     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the years multiplied by the specified scalar.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param scalar  the amount to multiply by, may be negative     * @return the new period multiplied by the specified scalar     * @throws ArithmeticException if the result overflows an int     */
/**     * Returns a new instance with the years divided by the specified divisor.     * The calculation uses integer division, thus 3 divided by 2 is 1.     * <p>     * This instance is immutable and unaffected by this method call.     *     * @param divisor  the amount to divide by, may be negative     * @return the new period divided by the specified divisor     * @throws ArithmeticException if the divisor is zero     */
/**     * Returns a new instance with the years value negated.     *     * @return the new period with a negated value     * @throws ArithmeticException if the result overflows an int     */
/**     * Is this years instance greater than the specified number of years.     *     * @param other  the other period, null means zero     * @return true if this years instance is greater than the specified one     */
/**     * Is this years instance less than the specified number of years.     *     * @param other  the other period, null means zero     * @return true if this years instance is less than the specified one     */
/**     * Get the value of one of the fields of a datetime.     * <p>     * This method uses the chronology of the datetime to obtain the value.     * It is essentially a generic way of calling one of the get methods.     *     * @param type  a field type, usually obtained from DateTimeFieldType     * @return the value of that field     * @throws IllegalArgumentException if the field type is null     */
/**     * Get the era field value.     *      * @return the era     */
/**     * Get the year of era field value.     *      * @return the year of era     */
/**     * Get the year of era field value.     *      * @return the year of era     */
/**     * Get the year of century field value.     *      * @return the year of century     */
/**     * Get the year field value.     *      * @return the year     */
/**     * Get the weekyear field value.     * <p>     * The weekyear is the year that matches with the weekOfWeekyear field.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     * The weekyear allows you to query the effective year for that day.     *      * @return the year of a week based year     */
/**     * Get the month of year field value.     *      * @return the month of year     */
/**     * Get the week of weekyear field value.     * <p>     * This field is associated with the "weekyear" via {@link #getWeekyear()}.     * In the standard ISO8601 week algorithm, the first week of the year     * is that in which at least 4 days are in the year. As a result of this     * definition, day 1 of the first week may be in the previous year.     *      * @return the week of a week based year     */
/**     * Get the day of year field value.     *      * @return the day of year     */
/**     * Get the day of month field value.     * <p>     * The values for the day of month are defined in {@link org.joda.time.DateTimeConstants}.     *      * @return the day of month     */
/**     * Get the day of week field value.     * <p>     * The values for the day of week are defined in {@link org.joda.time.DateTimeConstants}.     *      * @return the day of week     */
/**     * Get the hour of day field value.     *     * @return the hour of day     */
/**     * Get the minute of day field value.     *     * @return the minute of day     */
/**     * Get the minute of hour field value.     *     * @return the minute of hour     */
/**     * Get the second of day field value.     *     * @return the second of day     */
/**     * Get the second of minute field value.     *     * @return the second of minute     */
/**     * Get the millis of day field value.     *     * @return the millis of day     */
/**     * Get the millis of second field value.     *     * @return the millis of second     */
/**     * Get the date time as a <code>java.util.Calendar</code>, assigning     * exactly the same millisecond instant.     * The locale is passed in, enabling Calendar to select the correct     * localized subclass.     * <p>     * The JDK and Joda-Time both have time zone implementations and these     * differ in accuracy. Joda-Time's implementation is generally more up to     * date and thus more accurate - for example JDK1.3 has no historical data.     * The effect of this is that the field values of the <code>Calendar</code>     * may differ from those of this object, even though the milliseond value     * is the same. Most of the time this just means that the JDK field values     * are wrong, as our time zone information is more up to date.     *     * @param locale  the locale to get the Calendar for, or default if null     * @return a localized Calendar initialised with this datetime     */
/**     * Get the date time as a <code>java.util.GregorianCalendar</code>,     * assigning exactly the same millisecond instant.     * <p>     * The JDK and Joda-Time both have time zone implementations and these     * differ in accuracy. Joda-Time's implementation is generally more up to     * date and thus more accurate - for example JDK1.3 has no historical data.     * The effect of this is that the field values of the <code>Calendar</code>     * may differ from those of this object, even though the milliseond value     * is the same. Most of the time this just means that the JDK field values     * are wrong, as our time zone information is more up to date.     *     * @return a GregorianCalendar initialised with this datetime     */
/**     * Output the instant using the specified format pattern.     *     * @param pattern  the pattern specification, null means use <code>toString</code>     * @param locale  Locale to use, null means default     * @see  org.joda.time.format.DateTimeFormat     */
/**     * Get this duration as an immutable <code>Duration</code> object.     *      * @return a Duration created using the millisecond duration from this instance     */
/**     * Converts this duration to a Period instance using the standard period type     * and the ISO chronology.     * <p>     * Only precise fields in the period type will be used. Thus, only the hour,     * minute, second and millisecond fields on the period will be used.     * The year, month, week and day fields will not be populated.     * <p>     * If the duration is small, less than one day, then this method will perform     * as you might expect and split the fields evenly.     * If the duration is larger than one day then all the remaining duration will     * be stored in the largest available field, hours in this case.     * <p>     * For example, a duration effectively equal to (365 + 60 + 5) days will be     * converted to ((365 + 60 + 5) * 24) hours by this constructor.     * <p>     * For more control over the conversion process, you must pair the duration with     * an instant, see {@link Period#Period(ReadableInstant,ReadableDuration)}.     *      * @return a Period created using the millisecond duration from this instance     */
/**     * Compares this duration with the specified duration based on length.     *     * @param other  a duration to check against     * @return negative value if this is less, 0 if equal, or positive value if greater     * @throws NullPointerException if the object is null     * @throws ClassCastException if the given object is not supported     */
/**     * Is the length of this duration equal to the duration passed in.     *     * @param duration  another duration to compare to, null means zero milliseconds     * @return true if this duration is equal to than the duration passed in     */
/**     * Is the length of this duration longer than the duration passed in.     *     * @param duration  another duration to compare to, null means zero milliseconds     * @return true if this duration is equal to than the duration passed in     */
/**     * Is the length of this duration shorter than the duration passed in.     *     * @param duration  another duration to compare to, null means zero milliseconds     * @return true if this duration is equal to than the duration passed in     */
/**     * Compares this object with the specified object for equality based     * on the millisecond length. All ReadableDuration instances are accepted.     *     * @param duration  a readable duration to check against     * @return true if the length of the duration is equal     */
/**     * Gets a hash code for the duration that is compatible with the      * equals method.     *     * @return a hash code     */
/**     * Gets the time zone of the instant from the chronology.     *      * @return the DateTimeZone that the instant is using, never null     */
/**     * Get the value of one of the fields of a datetime.     * <p>     * This could be used to get a field using a different Chronology.     * For example:     * <pre>     * Instant dt = new Instant();     * int gjYear = dt.get(Chronology.getCoptic().year());     * </pre>     *      * @param field  the DateTimeField to use, not null     * @return the value     * @throws IllegalArgumentException if the field is null     */
/**     * Checks if the field type specified is supported by this instant and chronology.     * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.     *     * @param type  a field type, usually obtained from DateTimeFieldType     * @return true if the field type is supported     */
/**     * Get this object as an Instant.     *      * @return an Instant using the same millis     */
/**     * Get this object as a DateTime using the given chronology and its zone.     *      * @param chronology chronology to apply, or ISOChronology if null     * @return a DateTime using the same millis     */
/**     * Get this object as a DateTime using ISOChronology in the same zone.     *     * @return a DateTime using the same millis with ISOChronology     */
/**     * Get this object as a MutableDateTime using the given chronology and its zone.     *      * @param chronology chronology to apply, or ISOChronology if null     * @return a MutableDateTime using the same millis     */
/**     * Get this object as a MutableDateTime using ISOChronology in the same zone.     *     * @return a MutableDateTime using the same millis with ISOChronology     */
/**     * Get the date time as a <code>java.util.Date</code>.     * <p>     * The <code>Date</code> object created has exactly the same millisecond     * instant as this object.     *     * @return a Date initialised with this datetime     */
/**     * Compares this object with the specified object for equality based     * on the millisecond instant, chronology and time zone.     * <p>     * Two objects which represent the same instant in time, but are in     * different time zones (based on time zone id), will be considered to     * be different. Only two objects with the same {@link DateTimeZone},     * {@link Chronology} and instant are equal.     * <p>     * See {@link #isEqual(ReadableInstant)} for an equals method that     * ignores the Chronology and time zone.     * <p>     * All ReadableInstant instances are accepted.     *     * @param readableInstant  a readable instant to check against     * @return true if millisecond and chronology are equal, false if     *  not or the instant is null or of an incorrect type     */
/**     * Gets a hash code for the instant as defined in <code>ReadableInstant</code>.     *     * @return a suitable hash code     */
/**     * Compares this object with the specified object for ascending     * millisecond instant order. This ordering is inconsistent with     * equals, as it ignores the Chronology.     * <p>     * All ReadableInstant instances are accepted.     *     * @param other  a readable instant to check against     * @return negative value if this is less, 0 if equal, or positive value if greater     * @throws NullPointerException if the object is null     * @throws ClassCastException if the object type is not supported     */
/**     * Is this instant after the instant passed in     * comparing solely by millisecond.     *     * @param instant  an instant to check against, null means now     * @return true if the instant is after the instant passed in     */
/**     * Is this instant after the current instant     * comparing solely by millisecond.     *      * @return true if this instant is after the current instant     */
/**     * Is this instant before the instant passed in     * comparing solely by millisecond.     *     * @param instant  an instant to check against, null means now     * @return true if the instant is before the instant passed in     */
/**     * Is this instant before the current instant     * comparing solely by millisecond.     *      * @return true if this instant is before the current instant     */
/**     * Is this instant equal to the instant passed in     * comparing solely by millisecond.     *     * @param instant  an instant to check against, null means now     * @return true if the instant is equal to the instant passed in     */
/**     * Is this instant equal to the current instant     * comparing solely by millisecond.     *      * @return true if this instant is before the current instant     */
/**     * Uses the specified formatter to convert this partial to a String.     *     * @param formatter  the formatter to use, null means use <code>toString()</code>.     * @return the formatted string     * @since 1.1     */
/**     * Validates an interval.     *      * @param start  the start instant in milliseconds     * @param end  the end instant in milliseconds     * @throws IllegalArgumentException if the interval is invalid     */
/**     * Gets the start of this time interval, which is inclusive, as a DateTime.     *     * @return the start of the time interval     */
/**      * Gets the end of this time interval, which is exclusive, as a DateTime.     *     * @return the end of the time interval     */
/**     * Does this time interval contain the specified time interval.     * <p>     * Non-zero duration intervals are inclusive of the start instant and     * exclusive of the end. The other interval is contained if this interval     * wholly contains, starts, finishes or equals it.     * A zero duration interval cannot contain anything.     * <p>     * When two intervals are compared the result is one of three states:     * (a) they abut, (b) there is a gap between them, (c) they overlap.     * The <code>contains</code> method is not related to these states.     * In particular, a zero duration interval is contained at the start of     * a larger interval, but does not overlap (it abuts instead).     * <p>     * For example:     * <pre>     * [09:00 to 10:00) contains [09:00 to 10:00)  = true     * [09:00 to 10:00) contains [09:00 to 09:30)  = true     * [09:00 to 10:00) contains [09:30 to 10:00)  = true     * [09:00 to 10:00) contains [09:15 to 09:45)  = true     * [09:00 to 10:00) contains [09:00 to 09:00)  = true     *      * [09:00 to 10:00) contains [08:59 to 10:00)  = false (otherStart before thisStart)     * [09:00 to 10:00) contains [09:00 to 10:01)  = false (otherEnd after thisEnd)     * [09:00 to 10:00) contains [10:00 to 10:00)  = false (otherStart equals thisEnd)     *      * [14:00 to 14:00) contains [14:00 to 14:00)  = false (zero duration contains nothing)     * </pre>     * Passing in a <code>null</code> parameter will have the same effect as     * calling {@link #containsNow()}.     *     * @param interval  the time interval to compare to, null means a zero duration interval now     * @return true if this time interval contains the time interval     */
/**     * Does this time interval contain the current instant.     * <p>     * Non-zero duration intervals are inclusive of the start instant and     * exclusive of the end. A zero duration interval cannot contain anything.     *     * @return true if this time interval contains the current instant     */
/**     * Does this time interval overlap the specified time interval.     * <p>     * Intervals are inclusive of the start instant and exclusive of the end.     * An interval overlaps another if it shares some common part of the     * datetime continuum.      * <p>     * When two intervals are compared the result is one of three states:     * (a) they abut, (b) there is a gap between them, (c) they overlap.     * The abuts state takes precedence over the other two, thus a zero duration     * interval at the start of a larger interval abuts and does not overlap.     * <p>     * For example:     * <pre>     * [09:00 to 10:00) overlaps [08:00 to 08:30)  = false (completely before)     * [09:00 to 10:00) overlaps [08:00 to 09:00)  = false (abuts before)     * [09:00 to 10:00) overlaps [08:00 to 09:30)  = true     * [09:00 to 10:00) overlaps [08:00 to 10:00)  = true     * [09:00 to 10:00) overlaps [08:00 to 11:00)  = true     *      * [09:00 to 10:00) overlaps [09:00 to 09:00)  = false (abuts before)     * [09:00 to 10:00) overlaps [09:00 to 09:30)  = true     * [09:00 to 10:00) overlaps [09:00 to 10:00)  = true     * [09:00 to 10:00) overlaps [09:00 to 11:00)  = true     *      * [09:00 to 10:00) overlaps [09:30 to 09:30)  = true     * [09:00 to 10:00) overlaps [09:30 to 10:00)  = true     * [09:00 to 10:00) overlaps [09:30 to 11:00)  = true     *      * [09:00 to 10:00) overlaps [10:00 to 10:00)  = false (abuts after)     * [09:00 to 10:00) overlaps [10:00 to 11:00)  = false (abuts after)     *      * [09:00 to 10:00) overlaps [10:30 to 11:00)  = false (completely after)     *      * [14:00 to 14:00) overlaps [14:00 to 14:00)  = false (abuts before and after)     * [14:00 to 14:00) overlaps [13:00 to 15:00)  = true     * </pre>     *     * @param interval  the time interval to compare to, null means a zero length interval now     * @return true if the time intervals overlap     */
/**     * Is this interval equal to the specified interval ignoring the chronology.     * <p>     * This compares the underlying instants, ignoring the chronology.     *     * @param other  a readable interval to check against     * @return true if the intervals are equal comparing the start and end millis     * @since 2.3     */
/**     * Is this time interval entirely before the specified instant.     * <p>     * Intervals are inclusive of the start instant and exclusive of the end.     *      * @param interval  the interval to compare to, null means now     * @return true if this time interval is before the interval specified     */
/**     * Is this time interval before the current instant.     * <p>     * Intervals are inclusive of the start instant and exclusive of the end.     *      * @return true if this time interval is before the current instant     */
/**     * Is this time interval entirely after the specified interval.     * <p>     * Intervals are inclusive of the start instant and exclusive of the end.     * Only the end time of the specified interval is used in the comparison.     *      * @param interval  the interval to compare to, null means now     * @return true if this time interval is after the interval specified     */
/**     * Is this time interval after the current instant.     * <p>     * Intervals are inclusive of the start instant and exclusive of the end.     *      * @return true if this time interval is after the current instant     */
/**     * Get this interval as an immutable <code>Interval</code> object.     *     * @return the interval as an Interval object     */
/**     * Get this time interval as a <code>MutableInterval</code>.     * <p>     * This will always return a new <code>MutableInterval</code> with the same interval.     *     * @return the time interval as a MutableInterval object     */
/**     * Gets the duration of this time interval in milliseconds.     * <p>     * The duration is equal to the end millis minus the start millis.     *     * @return the duration of the time interval in milliseconds     * @throws ArithmeticException if the duration exceeds the capacity of a long     */
/**     * Gets the duration of this time interval.     * <p>     * The duration is equal to the end millis minus the start millis.     *     * @return the duration of the time interval     * @throws ArithmeticException if the duration exceeds the capacity of a long     */
/**     * Converts the duration of the interval to a <code>Period</code> using the     * specified period type.     * <p>     * This method should be used to exract the field values describing the     * difference between the start and end instants.     *     * @param type  the requested type of the duration, null means AllType     * @return a time period derived from the interval     */
/**     * Compares this object with the specified object for equality based     * on start and end millis plus the chronology.     * All ReadableInterval instances are accepted.     * <p>     * To compare the duration of two time intervals, use {@link #toDuration()}     * to get the durations and compare those.     *     * @param readableInterval  a readable interval to check against     * @return true if the intervals are equal comparing the start millis,     *  end millis and chronology     */
/**     * Hashcode compatible with equals method.     *     * @return suitable hashcode     */
/**     * Output a string in ISO8601 interval format.     * <p>     * From version 2.1, the string includes the time zone offset.     *     * @return re-parsable string (in the default zone)     */
/**     * Gets the field at the specifed index.     *      * @param index  the index     * @return the field     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Gets the field type at the specifed index.     *      * @param index  the index     * @return the field type     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Gets an array of the field types that this partial supports.     * <p>     * The fields are returned largest to smallest, for example Hour, Minute, Second.     *     * @return the fields supported in an array that may be altered, largest to smallest     */
/**     * Gets an array of the fields that this partial supports.     * <p>     * The fields are returned largest to smallest, for example Hour, Minute, Second.     *     * @return the fields supported in an array that may be altered, largest to smallest     */
/**     * Gets an array of the value of each of the fields that this partial supports.     * <p>     * The fields are returned largest to smallest, for example Hour, Minute, Second.     * Each value corresponds to the same array index as <code>getFields()</code>     *     * @return the current values of each field in an array that may be altered, largest to smallest     */
/**     * Get the value of one of the fields of a datetime.     * <p>     * The field specified must be one of those that is supported by the partial.     *     * @param type  a DateTimeFieldType instance that is supported by this partial     * @return the value of that field     * @throws IllegalArgumentException if the field is null or not supported     */
/**     * Checks whether the field specified is supported by this partial.     *     * @param type  the type to check, may be null which returns false     * @return true if the field is supported     */
/**     * Gets the index of the first fields to have the specified duration,     * or -1 if the field is unsupported.     *     * @param type  the type to check, may be null which returns -1     * @return the index of the field, -1 if unsupported     */
/**     * Gets the index of the first fields to have the specified duration,     * throwing an exception if the field is unsupported.     *     * @param type  the type to check, not null     * @return the index of the field     * @throws IllegalArgumentException if the field is null or not supported     */
/**     * Resolves this partial against another complete instant to create a new     * full instant. The combination is performed using the chronology of the     * specified instant.     * <p>     * For example, if this partial represents a time, then the result of this     * method will be the datetime from the specified base instant plus the     * time from this partial.     *     * @param baseInstant  the instant that provides the missing fields, null means now     * @return the combined datetime     */
/**     * Compares this ReadablePartial with another returning true if the chronology,     * field types and values are equal.     *     * @param partial  an object to check against     * @return true if fields and values are equal     */
/**     * Gets a hash code for the ReadablePartial that is compatible with the      * equals method.     *     * @return a suitable hash code     */
/**     * Compares this partial with another returning an integer     * indicating the order.     * <p>     * The fields are compared in order, from largest to smallest.     * The first field that is non-equal is used to determine the result.     * <p>     * The specified object must be a partial instance whose field types     * match those of this partial.     * <p>     * NOTE: Prior to v2.0, the {@code Comparable} interface was only implemented     * in this class and not in the {@code ReadablePartial} interface.     *     * @param other  an object to check against     * @return negative if this is less, zero if equal, positive if greater     * @throws ClassCastException if the partial is the wrong class     *  or if it has field types that don't match     * @throws NullPointerException if the partial is null     * @since 1.1     */
/**     * Is this partial later than the specified partial.     * <p>     * The fields are compared in order, from largest to smallest.     * The first field that is non-equal is used to determine the result.     * <p>     * You may not pass null into this method. This is because you need     * a time zone to accurately determine the current date.     *     * @param partial  a partial to check against, must not be null     * @return true if this date is after the date passed in     * @throws IllegalArgumentException if the specified partial is null     * @throws ClassCastException if the partial has field types that don't match     * @since 1.1     */
/**     * Is this partial earlier than the specified partial.     * <p>     * The fields are compared in order, from largest to smallest.     * The first field that is non-equal is used to determine the result.     * <p>     * You may not pass null into this method. This is because you need     * a time zone to accurately determine the current date.     *     * @param partial  a partial to check against, must not be null     * @return true if this date is before the date passed in     * @throws IllegalArgumentException if the specified partial is null     * @throws ClassCastException if the partial has field types that don't match     * @since 1.1     */
/**     * Is this partial the same as the specified partial.     * <p>     * The fields are compared in order, from largest to smallest.     * If all fields are equal, the result is true.     * <p>     * You may not pass null into this method. This is because you need     * a time zone to accurately determine the current date.     *     * @param partial  a partial to check against, must not be null     * @return true if this date is the same as the date passed in     * @throws IllegalArgumentException if the specified partial is null     * @throws ClassCastException if the partial has field types that don't match     * @since 1.1     */
/**     * Gets the number of fields that this period supports.     *     * @return the number of fields supported     * @since 2.0 (previously on BasePeriod)     */
/**     * Gets the field type at the specified index.     *     * @param index  the index to retrieve     * @return the field at the specified index     * @throws IndexOutOfBoundsException if the index is invalid     * @since 2.0 (previously on BasePeriod)     */
/**     * Gets an array of the field types that this period supports.     * <p>     * The fields are returned largest to smallest, for example Hours, Minutes, Seconds.     *     * @return the fields supported in an array that may be altered, largest to smallest     */
/**     * Gets an array of the value of each of the fields that this period supports.     * <p>     * The fields are returned largest to smallest, for example Hours, Minutes, Seconds.     * Each value corresponds to the same array index as <code>getFields()</code>     *     * @return the current values of each field in an array that may be altered, largest to smallest     */
/**     * Gets the value of one of the fields.     * <p>     * If the field type specified is not supported by the period then zero     * is returned.     *     * @param type  the field type to query, null returns zero     * @return the value of that field, zero if field not supported     */
/**     * Checks whether the field specified is supported by this period.     *     * @param type  the type to check, may be null which returns false     * @return true if the field is supported     */
/**     * Gets the index of the field in this period.     *     * @param type  the type to check, may be null which returns -1     * @return the index of -1 if not supported     */
/**     * Get this period as an immutable <code>Period</code> object.     *      * @return a Period using the same field set and values     */
/**     * Get this object as a <code>MutablePeriod</code>.     * <p>     * This will always return a new <code>MutablePeriod</code> with the same fields.     *      * @return a MutablePeriod using the same field set and values     */
/**     * Compares this object with the specified object for equality based     * on the value of each field. All ReadablePeriod instances are accepted.     * <p>     * Note that a period of 1 day is not equal to a period of 24 hours,     * nor is 1 hour equal to 60 minutes. Only periods with the same amount     * in each field are equal.     * <p>     * This is because periods represent an abstracted definition of a time     * period (eg. a day may not actually be 24 hours, it might be 23 or 25     * at daylight savings boundary).     * <p>     * To compare the actual duration of two periods, convert both to     * {@link org.joda.time.Duration Duration}s, an operation that emphasises     * that the result may differ according to the date you choose.     *     * @param period  a readable period to check against     * @return true if all the field values are equal, false if     *  not or the period is null or of an incorrect type     */
/**     * Gets a hash code for the period as defined by ReadablePeriod.     *     * @return a hash code     */
/**     * Uses the specified formatter to convert this period to a String.     *     * @param formatter  the formatter to use, null means use <code>toString()</code>.     * @return the formatted string     * @since 1.5     */
/**     * Constructs an instance set to the current system millisecond time     * using <code>ISOChronology</code> in the default time zone.     */
/**     * Constructs an instance set to the current system millisecond time     * using <code>ISOChronology</code> in the specified time zone.     * <p>     * If the specified time zone is null, the default zone is used.     *     * @param zone  the time zone, null means default zone     */
/**     * Constructs an instance set to the current system millisecond time     * using the specified chronology.     * <p>     * If the chronology is null, <code>ISOChronology</code>     * in the default time zone is used.     *     * @param chronology  the chronology, null means ISOChronology in default zone     */
/**     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z     * using <code>ISOChronology</code> in the default time zone.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     */
/**     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z     * using <code>ISOChronology</code> in the specified time zone.     * <p>     * If the specified time zone is null, the default zone is used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param zone  the time zone, null means default zone     */
/**     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z     * using the specified chronology.     * <p>     * If the chronology is null, <code>ISOChronology</code>     * in the default time zone is used.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z     * @param chronology  the chronology, null means ISOChronology in default zone     */
/**     * Constructs an instance from an Object that represents a datetime,     * forcing the time zone to that specified.     * <p>     * If the object contains no chronology, <code>ISOChronology</code> is used.     * If the specified time zone is null, the default zone is used.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     *     * @param instant  the datetime object     * @param zone  the time zone     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Constructs an instance from an Object that represents a datetime,     * using the specified chronology.     * <p>     * If the chronology is null, ISO in the default time zone is used.     * <p>     * The recognised object types are defined in     * {@link org.joda.time.convert.ConverterManager ConverterManager} and     * include ReadableInstant, String, Calendar and Date.     *     * @param instant  the datetime object     * @param chronology  the chronology     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Checks the specified chronology before storing it, potentially altering it.     * This method must not access any instance variables.     * <p>     * This implementation converts nulls to ISOChronology in the default zone.     *     * @param chronology  the chronology to use, may be null     * @return the chronology to store in this datetime, not null     */
/**     * Checks the specified instant before storing it, potentially altering it.     * This method must not access any instance variables.     * <p>     * This implementation simply returns the instant.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round     * @param chronology  the chronology to use, not null     * @return the instant to store in this datetime     */
/**     * Gets the milliseconds of the datetime instant from the Java epoch     * of 1970-01-01T00:00:00Z.     *      * @return the number of milliseconds since 1970-01-01T00:00:00Z     */
/**     * Gets the chronology of the datetime.     *      * @return the Chronology that the datetime is using     */
/**     * Sets the milliseconds of the datetime.     * <p>     * All changes to the millisecond field occurs via this method.     * Override and block this method to make a subclass immutable.     *     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the datetime to     */
/**     * Sets the chronology of the datetime.     * <p>     * All changes to the chronology field occurs via this method.     * Override and block this method to make a subclass immutable.     *     * @param chronology  the chronology to set     */
/**     * Gets the length of this duration in milliseconds.     *     * @return the length of the duration in milliseconds.     */
/**     * Sets the length of this duration in milliseconds.     *      * @param duration  the new length of the duration     */
/**     * Converts this duration to a Period instance using the specified period type     * and chronology.     * <p>     * Only precise fields in the period type will be used.     * Exactly which fields are precise depends on the chronology.     * Only the time fields are precise for ISO chronology with a time zone.     * However, ISO UTC also has precise days and weeks.     * <p>     * For more control over the conversion process, you must pair the duration with     * an instant, see {@link #toPeriodFrom(ReadableInstant, PeriodType)} and     * {@link #toPeriodTo(ReadableInstant, PeriodType)}     *      * @param type  the period type to use, null means standard     * @param chrono  the chronology to use, null means ISO default     * @return a Period created using the millisecond duration from this instance     */
/**     * Converts this duration to a Period instance by adding the duration to a start     * instant to obtain an interval.     * <p>     * This conversion will determine the fields of a period accurately.     * The results are based on the instant millis, the chronology of the instant,     * the period type and the length of this duration.     *      * @param startInstant  the instant to calculate the period from, null means now     * @param type  the period type determining how to split the duration into fields, null means All type     * @return a Period created using the millisecond duration from this instance     */
/**     * Converts this duration to a Period instance by subtracting the duration     * from an end instant to obtain an interval using the standard period     * type.     * <p>     * This conversion will determine the fields of a period accurately.     * The results are based on the instant millis, the chronology of the instant,     * the period type and the length of this duration.     *      * @param endInstant  the instant to calculate the period to, null means now     * @param type  the period type determining how to split the duration into fields, null means All type     * @return a Period created using the millisecond duration from this instance     */
/**     * Converts this duration to an Interval starting at the specified instant.     *      * @param startInstant  the instant to start the interval at, null means now     * @return an Interval starting at the specified instant     */
/**     * Converts this duration to an Interval ending at the specified instant.     *      * @param endInstant  the instant to end the interval at, null means now     * @return an Interval ending at the specified instant     */
/**     * Gets the chronology of this interval.     *     * @return the chronology     */
/**     * Gets the start of this time interval which is inclusive.     *     * @return the start of the time interval,     *  millisecond instant from 1970-01-01T00:00:00Z     */
/**     * Gets the end of this time interval which is exclusive.     *     * @return the end of the time interval,     *  millisecond instant from 1970-01-01T00:00:00Z     */
/**     * Sets this interval from two millisecond instants and a chronology.     *     * @param startInstant  the start of the time interval     * @param endInstant  the start of the time interval     * @param chrono  the chronology, not null     * @throws IllegalArgumentException if the end is before the start     */
/**     * Gets an array of the value of each of the fields that this partial supports.     * <p>     * The fields are returned largest to smallest, for example Hour, Minute, Second.     * Each value corresponds to the same array index as <code>getFields()</code>     *     * @return the current values of each field (cloned), largest to smallest     */
/**     * Sets the value of the field at the specified index.     * <p>     * In version 2.0 and later, this method copies the array into the original.     * This is because the instance variable has been changed to be final to satisfy the Java Memory Model.     * This only impacts subclasses that are mutable.     *      * @param index  the index     * @param value  the value to set     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Sets the values of all fields.     * <p>     * In version 2.0 and later, this method copies the array into the original.     * This is because the instance variable has been changed to be final to satisfy the Java Memory Model.     * This only impacts subclasses that are mutable.     *      * @param values  the array of values     */
/**     * Validates a period type, converting nulls to a default value and     * checking the type is suitable for this instance.     *      * @param type  the type to check, may be null     * @return the validated type to use, not null     * @throws IllegalArgumentException if the period type is invalid     */
/**     * Gets the total millisecond duration of this period relative to a start instant.     * <p>     * This method adds the period to the specified instant in order to     * calculate the duration.     * <p>     * An instant must be supplied as the duration of a period varies.     * For example, a period of 1 month could vary between the equivalent of     * 28 and 31 days in milliseconds due to different length months.     * Similarly, a day can vary at Daylight Savings cutover, typically between     * 23 and 25 hours.     *     * @param startInstant  the instant to add the period to, thus obtaining the duration     * @return the total length of the period as a duration relative to the start instant     * @throws ArithmeticException if the millis exceeds the capacity of the duration     */
/**     * Gets the total millisecond duration of this period relative to an     * end instant.     * <p>     * This method subtracts the period from the specified instant in order     * to calculate the duration.     * <p>     * An instant must be supplied as the duration of a period varies.     * For example, a period of 1 month could vary between the equivalent of     * 28 and 31 days in milliseconds due to different length months.     * Similarly, a day can vary at Daylight Savings cutover, typically between     * 23 and 25 hours.     *     * @param endInstant  the instant to subtract the period from, thus obtaining the duration     * @return the total length of the period as a duration relative to the end instant     * @throws ArithmeticException if the millis exceeds the capacity of the duration     */
/**     * Checks whether a field type is supported, and if so adds the new value     * to the relevant index in the specified array.     *      * @param type  the field type     * @param values  the array to update     * @param newValue  the new value to store if successful     */
/**     * Sets the eight standard the fields in one go.     *      * @param years  amount of years in this period, which must be zero if unsupported     * @param months  amount of months in this period, which must be zero if unsupported     * @param weeks  amount of weeks in this period, which must be zero if unsupported     * @param days  amount of days in this period, which must be zero if unsupported     * @param hours  amount of hours in this period, which must be zero if unsupported     * @param minutes  amount of minutes in this period, which must be zero if unsupported     * @param seconds  amount of seconds in this period, which must be zero if unsupported     * @param millis  amount of milliseconds in this period, which must be zero if unsupported     * @throws IllegalArgumentException if an unsupported field's value is non-zero     */
/**     * Private method called from constructor.     */
/**     * Sets the value of a field in this period.     *      * @param field  the field to set     * @param value  the value to set     * @throws IllegalArgumentException if field is is null or not supported.     */
/**     * Sets the value of a field in this period.     *      * @param values  the array of values to update     * @param field  the field to set     * @param value  the value to set     * @throws IllegalArgumentException if field is null or not supported.     */
/**     * Adds the value of a field in this period.     *      * @param field  the field to set     * @param value  the value to set     * @throws IllegalArgumentException if field is is null or not supported.     */
/**     * Adds the value of a field in this period.     *      * @param values  the array of values to update     * @param field  the field to set     * @param value  the value to set     * @throws IllegalArgumentException if field is is null or not supported.     */
/**     * Merges the fields from another period.     *      * @param period  the period to add from, not null     * @throws IllegalArgumentException if an unsupported field's value is non-zero     */
/**     * Merges the fields from another period.     *      * @param values  the array of values to update     * @param period  the period to add from, not null     * @return the updated values     * @throws IllegalArgumentException if an unsupported field's value is non-zero     */
/**     * Adds the fields from another period.     *      * @param period  the period to add from, not null     * @throws IllegalArgumentException if an unsupported field's value is non-zero     */
/**     * Adds the fields from another period.     *      * @param values  the array of values to update     * @param period  the period to add from, not null     * @return the updated values     * @throws IllegalArgumentException if an unsupported field's value is non-zero     */
/**     * Sets the value of the field at the specified index.     *      * @param index  the index     * @param value  the value to set     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Sets the values of all fields.     * <p>     * In version 2.0 and later, this method copies the array into the original.     * This is because the instance variable has been changed to be final to satisfy the Java Memory Model.     * This only impacts subclasses that are mutable.     *      * @param values  the array of values     */
/**     * Calculates the number of whole units between the two specified partial datetimes.     * <p>     * The two partials must contain the same fields, for example you can specify     * two <code>LocalDate</code> objects.     *     * @param start  the start partial date, validated to not be null     * @param end  the end partial date, validated to not be null     * @param zeroInstance  the zero instance constant, must not be null     * @return the period     * @throws IllegalArgumentException if the partials are null or invalid     */
/**     * Creates a new instance representing the number of complete standard length units     * in the specified period.     * <p>     * This factory method converts all fields from the period to hours using standardised     * durations for each field. Only those fields which have a precise duration in     * the ISO UTC chronology can be converted.     * <ul>     * <li>One week consists of 7 days.     * <li>One day consists of 24 hours.     * <li>One hour consists of 60 minutes.     * <li>One minute consists of 60 seconds.     * <li>One second consists of 1000 milliseconds.     * </ul>     * Months and Years are imprecise and periods containing these values cannot be converted.     *     * @param period  the period to get the number of hours from, must not be null     * @param millisPerUnit  the number of milliseconds in one standard unit of this period     * @throws IllegalArgumentException if the period contains imprecise duration values     */
/**     * Gets the value at the specified index.     * <p>     * The only index supported by this period is zero.     *     * @param index  the index to retrieve, which must be zero     * @return the value of the field at the specified index     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Sets the amount of this period.     * To make a subclass immutable you must declare it final, or block this method.     *     * @param value  the period value     */
/**     * Gets the field type at the specified index.     * <p>     * The only index supported by this period is zero which returns the     * field type of this class.     *     * @param index  the index to retrieve, which must be zero     * @return the field at the specified index     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Gets the number of fields that this period supports, which is one.     *     * @return the number of fields supported, which is one     */
/**     * Gets the value of a duration field represented by this period.     * <p>     * If the field type specified does not match the type used by this class     * then zero is returned.     *     * @param type  the field type to query, null returns zero     * @return the value of that field, zero if field not supported     */
/**     * Checks whether the duration field specified is supported by this period.     *     * @param type  the type to check, may be null which returns false     * @return true if the field is supported     */
/**     * Get this period as an immutable <code>Period</code> object.     * The period will use <code>PeriodType.standard()</code>.     *     * @return a <code>Period</code> representing the same number of days     */
/**     * Get this object as a <code>MutablePeriod</code>.     * <p>     * This will always return a new <code>MutablePeriod</code> with the same fields.     * The period will use <code>PeriodType.standard()</code>.     *      * @return a MutablePeriod using the same field set and values     */
/**     * Compares this object with the specified object for equality based on the     * value of each field. All ReadablePeriod instances are accepted, but only     * those with a matching <code>PeriodType</code> can return true.     *     * @param period  a readable period to check against     * @return true if all the field values are equal, false if     *  not or the period is null or of an incorrect type     */
/**     * Gets a hash code for the period as defined by ReadablePeriod.     *     * @return a hash code     */
/**     * Compares this period to another object of the same class.     *     * @param other  the other period, must not be null     * @return zero if equal, positive if greater, negative if less     * @throws NullPointerException if the other period is null     * @throws ClassCastException if the other period is of a different type     */
/**     * Returns the same base chronology as passed into the constructor.     */
/**     * Returns the same param object as passed into the constructor.     */
/**         * Copy the supported fields from a chronology into this container.         */
/**     * Returns a datetime millisecond instant, from from the given instant,     * hour, minute, second, and millisecond values. The set of given values     * must refer to a valid datetime, or else an IllegalArgumentException is     * thrown.     * <p>     * The default implementation calls upon separate DateTimeFields to     * determine the result. Subclasses are encouraged to provide a more     * efficient implementation.     *     * @param instant instant to start from     * @param hourOfDay hour to use     * @param minuteOfHour minute to use     * @param secondOfMinute second to use     * @param millisOfSecond millisecond to use     * @return millisecond instant from 1970-01-01T00:00:00Z     */
/**     * Validates whether the fields stored in a partial instant are valid.     * <p>     * This implementation uses {@link DateTimeField#getMinimumValue(ReadablePartial, int[])}     * and {@link DateTimeField#getMaximumValue(ReadablePartial, int[])}.     *     * @param partial  the partial instant to validate     * @param values  the values to validate, not null unless the partial is empty     * @throws IllegalArgumentException if the instant is invalid     */
/**     * Gets the values of a period from an interval.     *     * @param period  the period instant to use     * @param duration  the duration to query     * @return the values of the period extracted from the duration     */
/**     * Sets the partial into the instant.     *     * @param partial  the partial instant to use     * @param instant  the instant to update     * @return the updated instant     */
/**     * Adds the duration to the instant, specifying the number of times to add.     *     * @param instant  the instant to add to     * @param duration  the duration to add     * @param scalar  the number of times to add     * @return the updated instant     */
/**     * Get the millis duration field for this chronology.     *      * @return DurationField or UnsupportedDurationField if unsupported     */
/**     * Get the millis of second field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the millis of day field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the seconds duration field for this chronology.     *      * @return DurationField or UnsupportedDurationField if unsupported     */
/**     * Get the second of minute field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the second of day field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the minutes duration field for this chronology.     *      * @return DurationField or UnsupportedDurationField if unsupported     */
/**     * Get the minute of hour field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the minute of day field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the hours duration field for this chronology.     *      * @return DurationField or UnsupportedDurationField if unsupported     */
/**     * Get the hour of day (0-23) field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the hour of day (offset to 1-24) field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the halfdays duration field for this chronology.     *      * @return DurationField or UnsupportedDurationField if unsupported     */
/**     * Get the hour of am/pm (0-11) field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the hour of am/pm (offset to 1-12) field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the AM(0) PM(1) field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the days duration field for this chronology.     *      * @return DurationField or UnsupportedDurationField if unsupported     */
/**     * Get the day of week field for this chronology.     *     * <p>DayOfWeek values are defined in     * {@link org.joda.time.DateTimeConstants DateTimeConstants}.     * They use the ISO definitions, where 1 is Monday and 7 is Sunday.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the day of month field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the day of year field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the weeks duration field for this chronology.     *      * @return DurationField or UnsupportedDurationField if unsupported     */
/**     * Get the week of a week based year field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the weekyears duration field for this chronology.     *      * @return DurationField or UnsupportedDurationField if unsupported     */
/**     * Get the year of a week based year field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the year of a week based year in a century field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the months duration field for this chronology.     *      * @return DurationField or UnsupportedDurationField if unsupported     */
/**     * Get the month of year field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the years duration field for this chronology.     *      * @return DurationField or UnsupportedDurationField if unsupported     */
/**     * Get the year field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the year of era field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the year of century field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the centuries duration field for this chronology.     *      * @return DurationField or UnsupportedDurationField if unsupported     */
/**     * Get the century of era field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Get the eras duration field for this chronology.     *      * @return DurationField or UnsupportedDurationField if unsupported     */
/**     * Get the era field for this chronology.     *      * @return DateTimeField or UnsupportedDateTimeField if unsupported     */
/**     * Checks if this chronology instance equals another.     *      * @param obj  the object to compare to     * @return true if equal     * @since 1.6     */
/**     * A suitable hash code for the chronology.     *      * @return the hash code     * @since 1.6     */
/**     * Gets a debugging toString.     *      * @return a debugging string     */
/**     * Get the number of days in the year.     *     * @return 366     */
/**     * Get the number of days in the year.     *     * @param year  the year to use     * @return 366 if a leap year, otherwise 365     */
/**     * Get the number of weeks in the year.     *     * @param year  the year to use     * @return number of weeks in the year     */
/**     * Get the millis for the first week of a year.     *     * @param year  the year to use     * @return millis     */
/**     * Get the milliseconds for the start of a year.     *     * @param year The year to use.     * @return millis from 1970-01-01T00:00:00Z     */
/**     * Get the milliseconds for the start of a month.     *     * @param year The year to use.     * @param month The month to use     * @return millis from 1970-01-01T00:00:00Z     */
/**     * Get the milliseconds for a particular date.     *     * @param year The year to use.     * @param month The month to use     * @param dayOfMonth The day of the month to use     * @return millis from 1970-01-01T00:00:00Z     */
/**     * @param millis from 1970-01-01T00:00:00Z     * @param year precalculated year of millis     * @param month precalculated month of millis     */
/**     * @param instant millis from 1970-01-01T00:00:00Z     * @param year precalculated year of millis     */
/**     * @param instant millis from 1970-01-01T00:00:00Z     * @param year precalculated year of millis     */
/**     * Gets the maximum number of days in the month specified by the instant.     * The value represents what the user is trying to set, and can be     * used to optimise this method.     *      * @param instant  millis from 1970-01-01T00:00:00Z     * @param value  the value being set     * @return the maximum number of days in the month     */
/**     * Gets the milliseconds for a date at midnight.     *      * @param year  the year     * @param monthOfYear  the month     * @param dayOfMonth  the day     * @return the milliseconds     */
/**     * Gets the maximum number of months.     *      * @return 12     */
/**     * Serialization singleton     */
/**     * Get the day of the year component of the specified time instant.     *      * @param instant  the time instant in millis to query.     * @return the day of the year extracted from the input.     */
/**     * Serialization singleton     */
/**     * Gets the number of days in the specified month and year.     *      * @param year  the year     * @param month  the month     * @return the number of days     */
/**     * Get the Month component of the specified time instant.     *     * @see org.joda.time.DateTimeField#get(long)     * @see org.joda.time.ReadableDateTime#getMonthOfYear()     * @param instant  the time instant in millis to query.     * @return the month extracted from the input.     */
/**     * Add to the Month component of the specified time instant     * wrapping around within that component if necessary.     *      * @see org.joda.time.DateTimeField#addWrapField     * @param instant  the time instant in millis to update.     * @param months  the months to add (can be negative).     * @return the updated time instant.     */
/**     * Set the Month component of the specified time instant.<p>     * If the new month has less total days than the specified     * day of the month, this value is coerced to the nearest     * sane value. e.g.<p>     * 07-31 to month 6 = 06-30<p>     * 03-31 to month 2 = 02-28 or 02-29 depending<p>     *      * @param instant  the time instant in millis to update.     * @param month  the month (1,12) to update the time to.     * @return the updated time instant.     * @throws IllegalArgumentException  if month is invalid     */
/**     * Serialization singleton     */
/** @inheritDoc */
/** @inheritDoc */
/** @inheritDoc */
/** @inheritDoc */
/** @inheritDoc */
/** @inheritDoc */
/** @inheritDoc */
/** @inheritDoc */
/** @inheritDoc */
/** @inheritDoc */
/** @inheritDoc */
/** @inheritDoc */
/** @inheritDoc */
/** @inheritDoc */
/**     * Get the week of a week based year component of the specified time instant.     *      * @see org.joda.time.DateTimeField#get(long)     * @param instant  the time instant in millis to query.     * @return the week of the year extracted from the input.     */
/**     * Serialization singleton     */
/**     * Get the Year of a week based year component of the specified time instant.     *      * @see org.joda.time.DateTimeField#get     * @param instant  the time instant in millis to query.     * @return the year extracted from the input.     */
/**     * Add to the year component of the specified time instant     * wrapping around within that component if necessary.     *      * @see org.joda.time.DateTimeField#addWrapField     * @param instant  the time instant in millis to update.     * @param years  the years to add (can be negative).     * @return the updated time instant.     */
/**     * Set the Year of a week based year component of the specified time instant.     *     * @see org.joda.time.DateTimeField#set     * @param instant  the time instant in millis to update.     * @param year  the year (-9999,9999) to set the date to.     * @return the updated DateTime.     * @throws IllegalArgumentException  if year is invalid.     */
/**     * Serialization singleton     */
/**     * Serialization singleton     */
/**     * Standard instance of a Buddhist Chronology, that matches     * Sun's BuddhistCalendar class. This means that it follows the     * GregorianJulian calendar rules with a cutover date.     * <p>     * The time zone of the returned instance is UTC.     */
/**     * Standard instance of a Buddhist Chronology, that matches     * Sun's BuddhistCalendar class. This means that it follows the     * GregorianJulian calendar rules with a cutover date.     *     * @param zone  the time zone to use, null is default     */
/**     * Serialization singleton     */
/**     * Gets the Chronology in the UTC time zone.     *      * @return the chronology in UTC     */
/**     * Gets the Chronology in a specific time zone.     *      * @param zone  the zone to get the chronology in, null is default     * @return the chronology     */
/**     * Checks if this chronology instance equals another.     *      * @param obj  the object to compare to     * @return true if equal     * @since 1.6     */
/**     * A suitable hash code for the chronology.     *      * @return the hash code     * @since 1.6     */
/**     * Gets a debugging toString.     *      * @return a debugging string     */
/**     * Gets an instance of the CopticChronology.     * The time zone of the returned instance is UTC.     *      * @return a singleton UTC instance of the chronology     */
/**     * Gets an instance of the CopticChronology in the given time zone.     *      * @param zone  the time zone to get the chronology in, null is default     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4     * @return a chronology in the specified time zone     */
/**     * Serialization singleton.     */
/**     * Gets an instance of the EthiopicChronology.     * The time zone of the returned instance is UTC.     *      * @return a singleton UTC instance of the chronology     */
/**     * Gets an instance of the EthiopicChronology in the given time zone.     *      * @param zone  the time zone to get the chronology in, null is default     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4     * @return a chronology in the specified time zone     */
/**     * Serialization singleton.     */
/**     * Convert a datetime from one chronology to another.     */
/**     * Convert a datetime from one chronology to another.     */
/**     * Factory method returns instances of the default GJ cutover     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by     * October 15, 1582 (Gregorian).     *     * <p>The first day of the week is designated to be     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},     * and the minimum days in the first week of the year is 4.     *     * <p>The time zone of the returned instance is UTC.     */
/**     * Factory method returns instances of the GJ cutover chronology. Any     * cutover date may be specified.     *     * @param zone  the time zone to use, null is default     * @param gregorianCutover  the cutover to use     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4     */
/**     * Serialization singleton     */
/**     * Gets the Chronology in the UTC time zone.     *      * @return the chronology in UTC     */
/**     * Gets the Chronology in a specific time zone.     *      * @param zone  the zone to get the chronology in, null is default     * @return the chronology     */
/**     * Gets the cutover instant between Gregorian and Julian chronologies.     * @return the cutover instant     */
/**     * Gets the minimum days needed for a week to be the first week in a year.     *      * @return the minimum days     */
/**     * Checks if this chronology instance equals another.     *      * @param obj  the object to compare to     * @return true if equal     * @since 1.6     */
/**     * A suitable hash code for the chronology.     *      * @return the hash code     * @since 1.6     */
/**     * Gets a debugging toString.     *      * @return a debugging string     */
/**     * Get the value of the specified time instant.     *      * @param instant  the time instant in millis to query     * @return the day of the week extracted from the input     */
/**     * Get the textual value of the specified time instant.     *      * @param fieldValue  the field value to query     * @param locale  the locale to use     * @return the day of the week, such as 'Monday'     */
/**     * Get the abbreviated textual value of the specified time instant.     *      * @param fieldValue  the field value to query     * @param locale  the locale to use     * @return the day of the week, such as 'Mon'     */
/**     * Convert the specified text and locale into a value.     *      * @param text  the text to convert     * @param locale  the locale to convert using     * @return the value extracted from the text     * @throws IllegalArgumentException if the text is invalid     */
/**     * Get the minimum value that this field can have.     *      * @return the field's minimum value     */
/**     * Get the maximum value that this field can have.     *      * @return the field's maximum value     */
/**     * Get the maximum length of the text returned by this field.     *      * @param locale  the locale to use     * @return the maximum textual length     */
/**     * Get the maximum length of the abbreviated text returned by this field.     *      * @param locale  the locale to use     * @return the maximum abbreviated textual length     */
/**     * Serialization singleton     */
/**     * Get the Era component of the specified time instant.     *      * @param instant  the time instant in millis to query.     */
/**     * Serialization singleton     */
/**     * Set the year component of the specified time instant.     *      * @param instant  the time instant in millis to update.     * @param year  the year (0,292278994) to update the time to.     * @return the updated time instant.     * @throws IllegalArgumentException  if year is invalid.     */
/**     * Serialization singleton     */
/**     * Gets an instance of the GregorianChronology.     * The time zone of the returned instance is UTC.     *      * @return a singleton UTC instance of the chronology     */
/**     * Gets an instance of the GregorianChronology in the given time zone.     *      * @param zone  the time zone to get the chronology in, null is default     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4     * @return a chronology in the specified time zone     */
/**     * Serialization singleton     */
/**     * Gets an instance of the IslamicChronology.     * The time zone of the returned instance is UTC.     *      * @return a singleton UTC instance of the chronology     */
/**     * Gets an instance of the IslamicChronology in the given time zone.     *      * @param zone  the time zone to get the chronology in, null is default     * @param leapYears  the type defining the leap year pattern     * @return a chronology in the specified time zone     */
/**         * Ensure a singleton is returned if possible.         * @return the singleton instance         */
/**     * Gets the leap year pattern type.     *     * @return the pattern type     */
/**         * Is the year a leap year.         * @param year  the year to query         * @return true if leap         */
/**     * Gets an instance of the ISOChronology.     * The time zone of the returned instance is UTC.     *      * @return a singleton UTC instance of the chronology     */
/**     * Gets an instance of the ISOChronology in the given time zone.     *      * @param zone  the time zone to get the chronology in, null is default     * @return a chronology in the specified time zone     */
/**     * Checks if this chronology instance equals another.     *      * @param obj  the object to compare to     * @return true if equal     * @since 1.6     */
/**     * Serialize ISOChronology instances using a small stub. This reduces the     * serialized size, and deserialized instances come from the cache.     */
/**     * Serialization singleton     */
/**     * Gets an instance of the JulianChronology.     * The time zone of the returned instance is UTC.     *      * @return a singleton UTC instance of the chronology     */
/**     * Gets an instance of the JulianChronology in the given time zone.     *      * @param zone  the time zone to get the chronology in, null is default     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4     * @return a chronology in the specified time zone     */
/**     * Create a LenientChronology for any chronology.     *     * @param base the chronology to wrap     * @throws IllegalArgumentException if chronology is null     */
/**     * A lenient chronology is only equal to a lenient chronology with the     * same base chronology.     *      * @param obj  the object to compare to     * @return true if equal     * @since 1.4     */
/**     * A suitable hashcode for the chronology.     *      * @return the hashcode     * @since 1.4     */
/**     * A debugging string for the chronology.     *      * @return the debugging string     */
/**     * Wraps another chronology, with datetime limits. When withUTC or     * withZone is called, the returned LimitChronology instance has     * the same limits, except they are time zone adjusted.     *     * @param base  base chronology to wrap     * @param lowerLimit  inclusive lower limit, or null if none     * @param upperLimit  exclusive upper limit, or null if none     * @throws IllegalArgumentException if chronology is null or limits are invalid     */
/**     * Returns the inclusive lower limit instant.     *      * @return lower limit     */
/**     * Returns the inclusive upper limit instant.     *      * @return upper limit     */
/**     * If this LimitChronology is already UTC, then this is     * returned. Otherwise, a new instance is returned, with the limits     * adjusted to the new time zone.     */
/**     * If this LimitChronology has the same time zone as the one given, then     * this is returned. Otherwise, a new instance is returned, with the limits     * adjusted to the new time zone.     */
/**     * A limit chronology is only equal to a limit chronology with the     * same base chronology and limits.     *      * @param obj  the object to compare to     * @return true if equal     * @since 1.4     */
/**     * A suitable hashcode for the chronology.     *      * @return the hashcode     * @since 1.4     */
/**     * Create a StrictChronology for any chronology.     *     * @param base the chronology to wrap     * @throws IllegalArgumentException if chronology is null     */
/**     * A strict chronology is only equal to a strict chronology with the     * same base chronology.     *      * @param obj  the object to compare to     * @return true if equal     * @since 1.4     */
/**     * A suitable hashcode for the chronology.     *      * @return the hashcode     * @since 1.4     */
/**     * Create a ZonedChronology for any chronology, overriding any time zone it     * may already have.     *     * @param base base chronology to wrap     * @param zone the time zone     * @throws IllegalArgumentException if chronology or time zone is null     */
/**     * @param localInstant  the instant from 1970-01-01T00:00:00 local time     * @return the instant from 1970-01-01T00:00:00Z     */
/**     * A zoned chronology is only equal to a zoned chronology with the     * same base chronology and zone.     *      * @param obj  the object to compare to     * @return true if equal     * @since 1.4     */
/**     * A suitable hashcode for the chronology.     *      * @return the hashcode     * @since 1.4     */
/**     * A debugging string for the chronology.     *      * @return the debugging string     */
/**     * Extracts the millis from an object of this convertor's type.     * <p>     * This implementation returns the current time.     *      * @param object  the object to convert     * @param chrono  the chronology to use, which is always non-null     * @return the millisecond value     */
/**     * Extracts the chronology from an object of this convertor's type     * where the chronology is specified.     * <p>     * This implementation returns the chronology specified, or the     * ISO chronology in the default zone if null passed in.     *      * @param object  the object to convert     * @param chrono  the chronology to use, null means ISO default     * @return the chronology, never null     */
/**     * Extracts the values of the partial from an object of this converter's type.     * The chrono parameter is a hint to the converter, should it require a     * chronology to aid in conversion.     * <p>     * This implementation calls {@link #getPartialValues(ReadablePartial, Object, Chronology)}.     *      * @param fieldSource  a partial that provides access to the fields.     *  This partial may be incomplete and only getFieldType(int) should be used     * @param object  the object to convert     * @param chrono  the chronology to use, which is the non-null result of getChronology()     * @param parser  if converting from a String, the given parser is preferred     * @return the array of field values that match the fieldSource, must be non-null valid     * @throws ClassCastException if the object is invalid     * @since 1.3     */
/**     * Selects a suitable period type for the given object.     *     * @param object  the object to examine     * @return the period type, never null     */
/**     * Checks if the input is a ReadableInterval.     * <p>     * If it is, then the calling code should cast and copy the fields directly.     *     * @param object  the object to convert     * @param chrono  the chronology to use, may be null     * @return true if the input is a ReadableInterval     */
/**     * Gets a debugging string version of this converter.     *      * @return a debugging string     */
/**     * Gets the chronology, which is the GJChronology if a GregorianCalendar is used,     * BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise.     * The time zone specified is used in preference to that on the calendar.     *      * @param object  the Calendar to convert, must not be null     * @param zone  the specified zone to use, null means default zone     * @return the chronology, never null     * @throws NullPointerException if the object is null     * @throws ClassCastException if the object is an invalid type     */
/**     * Gets the millis, which is the Calendar millis value.     *      * @param object  the Calendar to convert, must not be null     * @param chrono  the chronology result from getChronology, non-null     * @return the millisecond value     * @throws NullPointerException if the object is null     * @throws ClassCastException if the object is an invalid type     */
/**     * Returns Calendar.class.     *      * @return Calendar.class     */
/**     * Gets the best converter for the object specified.     *      * @param object  the object to convert     * @return the converter to use     * @throws IllegalArgumentException if no suitable converter     * @throws IllegalStateException if multiple converters match the type     * equally well     */
/**     * Gets a copy of the set of converters.     *      * @return the converters, a copy of the real data, never null     */
/**     * Adds a converter to the set of converters. If a matching converter is     * already in the set, the given converter replaces it. If the converter is     * exactly the same as one already in the set, no changes are made.     * <p>     * The order in which converters are added is not relevent. The best     * converter is selected by examining the object hierarchy.     *      * @param converter  the converter to add, null ignored     * @return replaced converter, or null     */
/**     * Removes a converter from the set of converters. If the converter was     * not in the set, no changes are made.     *      * @param converter  the converter to remove, null ignored     * @return replaced converter, or null     */
/**     * Checks whether the user has permission 'ConverterManager.alterInstantConverters'.     *      * @throws SecurityException if the user does not have the permission     */
/**     * Gets the best converter for the object specified.     *      * @param object  the object to convert     * @return the converter to use     * @throws IllegalArgumentException if no suitable converter     * @throws IllegalStateException if multiple converters match the type     * equally well     */
/**     * Gets a copy of the set of converters.     *      * @return the converters, a copy of the real data, never null     */
/**     * Adds a converter to the set of converters. If a matching converter is     * already in the set, the given converter replaces it. If the converter is     * exactly the same as one already in the set, no changes are made.     * <p>     * The order in which converters are added is not relevent. The best     * converter is selected by examining the object hierarchy.     *      * @param converter  the converter to add, null ignored     * @return replaced converter, or null     */
/**     * Removes a converter from the set of converters. If the converter was     * not in the set, no changes are made.     *      * @param converter  the converter to remove, null ignored     * @return replaced converter, or null     */
/**     * Checks whether the user has permission 'ConverterManager.alterPartialConverters'.     *      * @throws SecurityException if the user does not have the permission     */
/**     * Gets the best converter for the object specified.     *      * @param object  the object to convert     * @return the converter to use     * @throws IllegalArgumentException if no suitable converter     * @throws IllegalStateException if multiple converters match the type     * equally well     */
/**     * Gets a copy of the list of converters.     *      * @return the converters, a copy of the real data, never null     */
/**     * Adds a converter to the set of converters. If a matching converter is     * already in the set, the given converter replaces it. If the converter is     * exactly the same as one already in the set, no changes are made.     * <p>     * The order in which converters are added is not relevent. The best     * converter is selected by examining the object hierarchy.     *      * @param converter  the converter to add, null ignored     * @return replaced converter, or null     */
/**     * Removes a converter from the set of converters. If the converter was     * not in the set, no changes are made.     *      * @param converter  the converter to remove, null ignored     * @return replaced converter, or null     */
/**     * Checks whether the user has permission 'ConverterManager.alterDurationConverters'.     *      * @throws SecurityException if the user does not have the permission     */
/**     * Gets the best converter for the object specified.     *      * @param object  the object to convert     * @return the converter to use     * @throws IllegalArgumentException if no suitable converter     * @throws IllegalStateException if multiple converters match the type     * equally well     */
/**     * Gets a copy of the list of converters.     *      * @return the converters, a copy of the real data, never null     */
/**     * Adds a converter to the set of converters. If a matching converter is     * already in the set, the given converter replaces it. If the converter is     * exactly the same as one already in the set, no changes are made.     * <p>     * The order in which converters are added is not relevent. The best     * converter is selected by examining the object hierarchy.     *      * @param converter  the converter to add, null ignored     * @return replaced converter, or null     */
/**     * Removes a converter from the set of converters. If the converter was     * not in the set, no changes are made.     *      * @param converter  the converter to remove, null ignored     * @return replaced converter, or null     */
/**     * Checks whether the user has permission 'ConverterManager.alterPeriodConverters'.     *      * @throws SecurityException if the user does not have the permission     */
/**     * Gets the best converter for the object specified.     *      * @param object  the object to convert     * @return the converter to use     * @throws IllegalArgumentException if no suitable converter     * @throws IllegalStateException if multiple converters match the type     * equally well     */
/**     * Gets a copy of the list of converters.     *      * @return the converters, a copy of the real data, never null     */
/**     * Adds a converter to the set of converters. If a matching converter is     * already in the set, the given converter replaces it. If the converter is     * exactly the same as one already in the set, no changes are made.     * <p>     * The order in which converters are added is not relevent. The best     * converter is selected by examining the object hierarchy.     *      * @param converter  the converter to add, null ignored     * @return replaced converter, or null     */
/**     * Removes a converter from the set of converters. If the converter was     * not in the set, no changes are made.     *      * @param converter  the converter to remove, null ignored     * @return replaced converter, or null     */
/**     * Checks whether the user has permission 'ConverterManager.alterIntervalConverters'.     *      * @throws SecurityException if the user does not have the permission     */
/**     * Gets a debug representation of the object.     */
/**     * Returns the closest matching converter for the given type, or null if     * none found.     *     * @param type type to select, which may be null     * @throws IllegalStateException if multiple converters match the type     * equally well     */
/**     * Returns the amount of converters in the set.     */
/**     * Copies all the converters in the set to the given array.     */
/**     * Returns a copy of this set, with the given converter added. If a     * matching converter is already in the set, the given converter replaces     * it. If the converter is exactly the same as one already in the set, the     * original set is returned.     *     * @param converter  converter to add, must not be null     * @param removed  if not null, element 0 is set to the removed converter     * @throws NullPointerException if converter is null     */
/**     * Returns a copy of this set, with the converter at the given index     * removed.     *     * @param index index of converter to remove     * @param removed if not null, element 0 is set to the removed converter     * @throws IndexOutOfBoundsException if the index is invalid     */
/**     * Returns the closest matching converter for the given type, but not very     * efficiently.     */
/**     * Gets the millis, which is the Date millis value.     *      * @param object  the Date to convert, must not be null     * @param chrono  the non-null result of getChronology     * @return the millisecond value     * @throws NullPointerException if the object is null     * @throws ClassCastException if the object is an invalid type     */
/**     * Returns Date.class.     *      * @return Date.class     */
/**     * Gets the millisecond instant, which is the Long value.     *      * @param object  the Long to convert, must not be null     * @param chrono  the chronology to use, which is always non-null     * @return the millisecond value     * @throws NullPointerException if the object is null     * @throws ClassCastException if the object is an invalid type     */
/**     * Gets the millisecond duration, which is the Long value.     *      * @param object  the Long to convert, must not be null     * @return the millisecond duration     * @throws NullPointerException if the object is null     * @throws ClassCastException if the object is an invalid type     */
/**     * Returns Long.class.     *      * @return Long.class     */
/**     * Gets the millisecond duration, which is zero.     *      * @param object  the object to convert, which is null     * @return the millisecond duration     */
/**     * Extracts interval endpoint values from an object of this converter's     * type, and sets them into the given ReadWritableInterval.     *     * @param writableInterval interval to get modified, not null     * @param object  the object to convert, which is null     * @param chrono  the chronology to use, may be null     * @throws NullPointerException if the interval is null     */
/**     * Returns null.     *      * @return null     */
/**     * Extracts the millis from an object of this convertor's type.     *      * @param object  the object to convert, must not be null     * @return the millisecond value     * @throws NullPointerException if the object is null     * @throws ClassCastException if the object is an invalid type     * @throws IllegalArgumentException if the object is invalid     */
/**     * Extracts duration values from an object of this converter's type, and     * sets them into the given ReadWritableDuration.     *     * @param writablePeriod  period to get modified     * @param object  the object to convert, must not be null     * @param chrono  the chronology to use, must not be null     * @throws NullPointerException if the duration or object is null     * @throws ClassCastException if the object is an invalid type     * @throws IllegalArgumentException if the object is invalid     */
/**     * Returns ReadableDuration.class.     *      * @return ReadableDuration.class     */
/**     * Gets the chronology, which is taken from the ReadableInstant.     * <p>     * If the passed in chronology is non-null, it is used.     * Otherwise the chronology from the instant is used.     *      * @param object  the ReadableInstant to convert, must not be null     * @param chrono  the chronology to use, null means use that from object     * @return the chronology, never null     */
/**     * Extracts the millis from an object of this convertor's type.     *      * @param object  the ReadableInstant to convert, must not be null     * @param chrono  the non-null result of getChronology     * @return the millisecond value     * @throws NullPointerException if the object is null     * @throws ClassCastException if the object is an invalid type     */
/**     * Returns ReadableInstant.class.     *      * @return ReadableInstant.class     */
/**     * Gets the millisecond length of the interval.     *      * @param object  the interval     */
/**     * Extracts interval endpoint values from an object of this converter's     * type, and sets them into the given ReadWritableInterval.     *     * @param writableInterval interval to get modified, not null     * @param object  the object to convert, must not be null     * @param chrono  the chronology to use, may be null     * @throws ClassCastException if the object is invalid     */
/**     * Checks if the input is a ReadableInterval.     * <p>     * If it is, then the calling code should cast and copy the fields directly.     *     * @param object  the object to convert, must not be null     * @param chrono  the chronology to use, may be null     * @return true if the input is a ReadableInterval     * @throws ClassCastException if the object is invalid     */
/**     * Returns ReadableInterval.class.     */
/**     * Gets the chronology, which is taken from the ReadableInstant.     * <p>     * If the passed in chronology is non-null, it is used.     * Otherwise the chronology from the instant is used.     *      * @param object  the ReadablePartial to convert, must not be null     * @param chrono  the chronology to use, null means use that from object     * @return the chronology, never null     */
/**     * Extracts the values of the partial from an object of this converter's type.     * The chrono parameter is a hint to the converter, should it require a     * chronology to aid in conversion.     *      * @param fieldSource  a partial that provides access to the fields.     *  This partial may be incomplete and only getFieldType(int) should be used     * @param object  the object to convert     * @param chrono  the chronology to use, which is the non-null result of getChronology()     * @return the array of field values that match the fieldSource, must be non-null valid     * @throws ClassCastException if the object is invalid     */
/**     * Returns ReadableInstant.class.     *      * @return ReadableInstant.class     */
/**     * Extracts duration values from an object of this converter's type, and     * sets them into the given ReadWritablePeriod.     *     * @param duration duration to get modified     * @param object  the object to convert, must not be null     * @param chrono  the chronology to use     * @throws NullPointerException if the duration or object is null     * @throws ClassCastException if the object is an invalid type     * @throws IllegalArgumentException if the object is invalid     */
/**     * Selects a suitable period type for the given object.     *     * @param object  the object to examine, must not be null     * @return the period type from the readable duration     * @throws NullPointerException if the object is null     * @throws ClassCastException if the object is an invalid type     */
/**     * Returns ReadablePeriod class.     *      * @return ReadablePeriod.class     */
/**     * Gets the millis, which is the ISO parsed string value.     *      * @param object  the String to convert, must not be null     * @param chrono  the chronology to use, non-null result of getChronology     * @return the millisecond value     * @throws IllegalArgumentException if the value if invalid     */
/**     * Extracts the values of the partial from an object of this converter's type.     * This method checks if the parser has a zone, and uses it if present.     * This is most useful for parsing local times with UTC.     *      * @param fieldSource  a partial that provides access to the fields.     *  This partial may be incomplete and only getFieldType(int) should be used     * @param object  the object to convert     * @param chrono  the chronology to use, which is the non-null result of getChronology()     * @param parser the parser to use, may be null     * @return the array of field values that match the fieldSource, must be non-null valid     * @throws ClassCastException if the object is invalid     * @throws IllegalArgumentException if the value if invalid     * @since 1.3     */
/**     * Gets the duration of the string using the standard type.     * This matches the toString() method of ReadableDuration.     *      * @param object  the String to convert, must not be null     * @throws ClassCastException if the object is invalid     */
/**     * Sets the value of the mutable interval from the string.     *      * @param writableInterval  the interval to set     * @param object  the String to convert, must not be null     * @param chrono  the chronology to use, may be null     */
/**     * Returns String.class.     *      * @return String.class     */
/**     * Gets the field type being used.     *      * @return the field type     */
/**     * Gets the name of the field.     *      * @return the field name     */
/**     * Gets the value of this property from the instant as a string.     * <p>     * This method returns the value converted to a <code>String</code>     * using <code>Integer.toString</code>. This method does NOT return     * textual descriptions such as 'Monday' or 'January'.     * See {@link #getAsText()} and {@link #getAsShortText()} for those.     *      * @return the current value     * @see DateTimeField#get     * @since 1.1     */
/**     * Gets the textual value of this property from the instant as a     * string in the specified locale.     * <p>     * This method returns the value converted to a <code>String</code>     * returning the appropriate textual description wherever possible.     * Thus, a day of week of 1 would return 'Monday' in English.     *      * @param locale  locale to use for selecting a text symbol, null means default     * @return the current text value     * @see DateTimeField#getAsText     */
/**     * Gets the short textual value of this property from the instant as a     * string in the specified locale.     * <p>     * This method returns the value converted to a <code>String</code>     * returning the appropriate textual description wherever possible.     * Thus, a day of week of 1 would return 'Mon' in English.     *      * @param locale  locale to use for selecting a text symbol, null means default     * @return the current text value     * @see DateTimeField#getAsShortText     */
/**     * Returns the duration per unit value of this field. For example, if this     * field represents "hour of day", then the duration is an hour.     *     * @return the duration of this field, or UnsupportedDurationField     */
/**     * Returns the range duration of this field. For example, if this field     * represents "hour of day", then the range duration is a day.     *     * @return the range duration of this field, or null if field has no range     */
/**     * Gets the minimum value for the field ignoring the current time.     *      * @return the minimum value     * @see DateTimeField#getMinimumValue     */
/**     * Gets the minimum value for this field given the current field values.     *      * @return the minimum value     * @see DateTimeField#getMinimumValue     */
/**     * Gets the maximum value for the field ignoring the current time.     *      * @return the maximum value     * @see DateTimeField#getMaximumValue     */
/**     * Gets the maximum value for this field given the current field values.     *      * @return the maximum value     * @see DateTimeField#getMaximumValue     */
/**     * Gets the maximum text length for the field.     *      * @param locale  optional locale to use for selecting a text symbol     * @return the maximum length     * @see DateTimeField#getMaximumTextLength     */
/**     * Gets the maximum short text length for the field.     *      * @param locale  optional locale to use for selecting a text symbol     * @return the maximum length     * @see DateTimeField#getMaximumShortTextLength     */
/**     * Compare this field to the same field on another partial instant.     * <p>     * The comparison is based on the value of the same field type, irrespective     * of any difference in chronology. Thus, if this property represents the     * hourOfDay field, then the hourOfDay field of the other partial will be queried     * whether in the same chronology or not.     *      * @param partial  the partial to compare to     * @return negative value if this is less, 0 if equal, or positive value if greater     * @throws IllegalArgumentException if the instant is null     * @throws IllegalArgumentException if the field of this property cannot be queried     *  on the specified instant     */
/**     * Compares this property to another.     *      * @param object  the object to compare to     * @return true if equal     */
/**     * Gets a suitable hashcode for the object.     *      * @return the hashcode     * @since 1.3     */
/**     * Output a debugging string.     *      * @return debugging string     */
/**     * Constructor.     */
/**     * Gets the chronology of the datetime that this property is linked to.     * <p>     * This implementation throws UnsupportedOperationException, and must be     * implemented by subclasses to enable the equals() and hashCode() methods.     *      * @return the chronology     * @since 1.4     */
/**     * Gets the value of this property from the instant.     * <p>     * For example, the following two lines of code are equivalent:     * <pre>     * datetime.getDayOfMonth();     * datetime.dayOfMonth().get();     * </pre>     *      * @return the current value     * @see DateTimeField#get     */
/**     * Gets the textual value of this property from the instant as a     * string in the specified locale.     * <p>     * This method returns the value converted to a <code>String</code>     * returning the appropriate textual description wherever possible.     * Thus, a day of week of 1 would return 'Monday' in English.     *      * @param locale  locale to use for selecting a text symbol, null means default     * @return the current text value     * @see DateTimeField#getAsText     */
/**     * Gets the short textual value of this property from the instant as a     * string in the specified locale.     * <p>     * This method returns the value converted to a <code>String</code>     * returning the appropriate textual description wherever possible.     * Thus, a day of week of 1 would return 'Mon' in English.     *      * @param locale  locale to use for selecting a text symbol, null means default     * @return the current text value     * @see DateTimeField#getAsShortText     */
/**     * Returns the difference between this field property instant and the one     * passed in, in the units of this field. The sign of the difference     * matches that of compareTo. In other words, this field property's instant     * is the minuend.     *     * @param instant  the subtrahend, null means now     * @return the difference in the units of this field     * @see DateTimeField#getDifference     */
/**     * Returns the difference between this field property instant and the one     * passed in, in the units of this field. The sign of the difference     * matches that of compareTo. In other words, this field property's instant     * is the minuend.     *     * @param instant  the subtrahend, null means now     * @return the difference in the units of this field     * @see DateTimeField#getDifference     */
/**     * Gets whether this field is leap.     *      * @return true if a leap field     * @see DateTimeField#isLeap     */
/**     * Gets the amount by which this field is leap.     *      * @return the amount by which the field is leap     * @see DateTimeField#getLeapAmount     */
/**     * If this field were to leap, then it would be in units described by the     * returned duration. If this field doesn't ever leap, null is returned.     */
/**     * Gets the minimum value for the field.     *      * @return the minimum value     * @see DateTimeField#getMinimumValue     */
/**     * Gets the maximum value for the field.     *      * @return the maximum value     * @see DateTimeField#getMaximumValue     */
/**     * Returns the fractional duration milliseconds of this field.     *     * @see DateTimeField#remainder     * @return remainder duration, in milliseconds     */
/**     * Returns the interval that represents the range of the minimum     * and maximum values of this field.     * <p>     * For example, <code>datetime.monthOfYear().toInterval()</code>     * will return an interval over the whole month.     *     * @return the interval of this field     * @since 1.2     */
/**     * Compare this field to the same field on another partial instant.     * <p>     * The comparison is based on the value of the same field type, irrespective     * of any difference in chronology. Thus, if this property represents the     * hourOfDay field, then the hourOfDay field of the other partial will be queried     * whether in the same chronology or not.     *      * @param partial  the partial to compare to     * @return negative value if this is less, 0 if equal, or positive value if greater     * @throws IllegalArgumentException if the partial is null     * @throws IllegalArgumentException if the partial doesn't support this field     */
/**     * Compares this property to another.     *      * @param object  the object to compare to     * @return true if equal     */
/**     * Returns a hashcode compatible with the equals method.     *      * @return the hashcode     */
/**     * @return true always     */
/**     * Get the human-readable, text value of this field from the field value.     * If the specified locale is null, the default locale is used.     * <p>     * The default implementation returns Integer.toString(get(instant)).     * <p>     * Note: subclasses that override this method should also override     * getMaximumTextLength.     *     * @param fieldValue  the numeric value to convert to text     * @param locale the locale to use for selecting a text symbol, null for default     * @return the text value of the field     */
/**     * Get the human-readable, short text value of this field from the field value.     * If the specified locale is null, the default locale is used.     * <p>     * The default implementation returns getAsText(fieldValue, locale).     * <p>     * Note: subclasses that override this method should also override     * getMaximumShortTextLength.     *     * @param fieldValue  the numeric value to convert to text     * @param locale the locale to use for selecting a text symbol, null for default     * @return the text value of the field     */
/**     * Adds a value (which may be negative) to the partial instant,     * throwing an exception if the maximum size of the instant is reached.     * <p>     * The value will be added to this field, overflowing into larger fields     * if necessary. Smaller fields should be unaffected, except where the     * result would be an invalid value for a smaller field. In this case the     * smaller field is adjusted to be in range.     * <p>     * Partial instants only contain some fields. This may result in a maximum     * possible value, such as TimeOfDay being limited to 23:59:59:999. If this     * limit is breached by the add an exception is thrown.     * <p>     * For example, in the ISO chronology:<br>     * 2000-08-20 add six months is 2000-02-20<br>     * 2000-08-20 add twenty months is 2000-04-20<br>     * 2000-08-20 add minus nine months is 2000-11-20<br>     * 2001-01-31 add one month  is 2001-02-28<br>     * 2001-01-31 add two months is 2001-03-31<br>     *      * @param instant  the partial instant     * @param fieldIndex  the index of this field in the partial     * @param values  the values of the partial instant which should be updated     * @param valueToAdd  the value to add, in the units of the field     * @return the passed in values     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached     */
/**     * Adds a value (which may be negative) to the partial instant,     * wrapping the whole partial if the maximum size of the partial is reached.     * <p>     * The value will be added to this field, overflowing into larger fields     * if necessary. Smaller fields should be unaffected, except where the     * result would be an invalid value for a smaller field. In this case the     * smaller field is adjusted to be in range.     * <p>     * Partial instants only contain some fields. This may result in a maximum     * possible value, such as TimeOfDay normally being limited to 23:59:59:999.     * If ths limit is reached by the addition, this method will wrap back to     * 00:00:00.000. In fact, you would generally only use this method for     * classes that have a limitation such as this.     * <p>     * For example, in the ISO chronology:<br>     * 10:20:30 add 20 minutes is 10:40:30<br>     * 10:20:30 add 45 minutes is 11:05:30<br>     * 10:20:30 add 16 hours is 02:20:30<br>     *      * @param instant  the partial instant     * @param fieldIndex  the index of this field in the partial     * @param values  the values of the partial instant which should be updated     * @param valueToAdd  the value to add, in the units of the field     * @return the passed in values     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached     */
/**     * Adds a value (which may be negative) to the partial instant,     * wrapping within this field.     * <p>     * The value will be added to this field. If the value is too large to be     * added solely to this field then it wraps. Larger fields are always     * unaffected. Smaller fields should be unaffected, except where the     * result would be an invalid value for a smaller field. In this case the     * smaller field is adjusted to be in range.     * <p>     * For example, in the ISO chronology:<br>     * 2000-08-20 addWrapField six months is 2000-02-20<br>     * 2000-08-20 addWrapField twenty months is 2000-04-20<br>     * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>     * 2001-01-31 addWrapField one month  is 2001-02-28<br>     * 2001-01-31 addWrapField two months is 2001-03-31<br>     * <p>     * The default implementation internally calls set. Subclasses are     * encouraged to provide a more efficient implementation.     *      * @param instant  the partial instant     * @param fieldIndex  the index of this field in the instant     * @param values  the values of the partial instant which should be updated     * @param valueToAdd  the value to add, in the units of the field     * @return the passed in values     * @throws IllegalArgumentException if the value is invalid     */
/**     * Computes the difference between two instants, as measured in the units     * of this field. Any fractional units are dropped from the result. Calling     * getDifference reverses the effect of calling add. In the following code:     *     * <pre>     * long instant = ...     * int v = ...     * int age = getDifference(add(instant, v), instant);     * </pre>     *     * The value 'age' is the same as the value 'v'.     *     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to     * subtract from     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to     * subtract off the minuend     * @return the difference in the units of this field     */
/**     * Computes the difference between two instants, as measured in the units     * of this field. Any fractional units are dropped from the result. Calling     * getDifference reverses the effect of calling add. In the following code:     *     * <pre>     * long instant = ...     * long v = ...     * long age = getDifferenceAsLong(add(instant, v), instant);     * </pre>     *     * The value 'age' is the same as the value 'v'.     *     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to     * subtract from     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to     * subtract off the minuend     * @return the difference in the units of this field     */
/**     * Sets a value in the milliseconds supplied from a human-readable, text value.     * If the specified locale is null, the default locale is used.     * <p>     * This implementation uses <code>convertText(String, Locale)</code> and     * {@link #set(ReadablePartial, int, int[], int)}.     *     * @param instant  the partial instant     * @param fieldIndex  the index of this field in the instant     * @param values  the values of the partial instant which should be updated     * @param text  the text value to set     * @param locale the locale to use for selecting a text symbol, null for default     * @return the passed in values     * @throws IllegalArgumentException if the text value is invalid     */
/**     * Convert the specified text and locale into a value.     *      * @param text  the text to convert     * @param locale  the locale to convert using     * @return the value extracted from the text     * @throws IllegalArgumentException if the text is invalid     */
/**     * Returns whether this field is 'leap' for the specified instant.     * <p>     * For example, a leap year would return true, a non leap year would return     * false.     * <p>     * This implementation returns false.     *      * @return true if the field is 'leap'     */
/**     * Gets the amount by which this field is 'leap' for the specified instant.     * <p>     * For example, a leap year would return one, a non leap year would return     * zero.     * <p>     * This implementation returns zero.     */
/**     * If this field were to leap, then it would be in units described by the     * returned duration. If this field doesn't ever leap, null is returned.     * <p>     * This implementation returns null.     */
/**     * Get the minimum value for this field using the partial instant and     * the specified values.     * <p>     * This implementation returns the same as {@link #getMinimumValue(ReadablePartial)}.     *      * @param instant  the partial instant to query     * @param values  the values to use     * @return the minimum value for this field, in the units of the field     */
/**     * Get the maximum value for this field using the partial instant and     * the specified values.     * <p>     * This implementation returns the same as {@link #getMaximumValue(ReadablePartial)}.     *      * @param instant  the partial instant to query     * @param values  the values to use     * @return the maximum value for this field, in the units of the field     */
/**     * Get the maximum text value for this field. The default implementation     * returns the equivalent of Integer.toString(getMaximumValue()).length().     *      * @param locale  the locale to use for selecting a text symbol     * @return the maximum text length     */
/**     * Get the maximum short text value for this field. The default     * implementation returns getMaximumTextLength().     *      * @param locale  the locale to use for selecting a text symbol     * @return the maximum short text length     */
/**     * Round to the highest whole unit of this field. The value of this field     * and all fields of a higher magnitude may be incremented in order to     * achieve this result. The fractional millis that cannot be expressed in     * whole increments of this field are set to minimum.     * <p>     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the     * highest whole hour is 2002-11-03T00:00:00.000.     * <p>     * The default implementation calls roundFloor, and if the instant is     * modified as a result, adds one field unit. Subclasses are encouraged to     * provide a more efficient implementation.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round     * @return rounded milliseconds     */
/**     * Round to the nearest whole unit of this field. If the given millisecond     * value is closer to the floor or is exactly halfway, this function     * behaves like roundFloor. If the millisecond value is closer to the     * ceiling, this function behaves like roundCeiling.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round     * @return rounded milliseconds     */
/**     * Round to the nearest whole unit of this field. If the given millisecond     * value is closer to the floor, this function behaves like roundFloor. If     * the millisecond value is closer to the ceiling or is exactly halfway,     * this function behaves like roundCeiling.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round     * @return rounded milliseconds     */
/**     * Round to the nearest whole unit of this field. If the given millisecond     * value is closer to the floor, this function behaves like roundFloor. If     * the millisecond value is closer to the ceiling, this function behaves     * like roundCeiling.     * <p>     * If the millisecond value is exactly halfway between the floor and     * ceiling, the ceiling is chosen over the floor only if it makes this     * field's value even.     *     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round     * @return rounded milliseconds     */
/**     * Returns the fractional duration milliseconds of this field. In other     * words, calling remainder returns the duration that roundFloor would     * subtract.     * <p>     * For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by     * hour is 34 minutes and 56.789 seconds.     * <p>     * The default implementation computes     * <code>instant - roundFloor(instant)</code>. Subclasses are encouraged to     * provide a more efficient implementation.     *     * @param instant the milliseconds from 1970-01-01T00:00:00Z to get the     * remainder     * @return remainder duration, in milliseconds     */
/**     * Get a suitable debug string.     *      * @return debug string     */
/**     * Get the value of this field from the milliseconds relative to an     * instant.     *     * <p>If the milliseconds is positive, then the instant is treated as a     * "start instant". If negative, the instant is treated as an "end     * instant".     *     * <p>The default implementation returns     * <code>Utils.safeToInt(getAsLong(millisDuration, instant))</code>.     *      * @param duration  the milliseconds to query, which may be negative     * @param instant  the start instant to calculate relative to     * @return the value of the field, in the units of the field, which may be     * negative     */
/**     * Get the value of this field from the milliseconds, which is approximate     * if this field is imprecise.     *     * @param duration  the milliseconds to query, which may be negative     * @return the value of the field, in the units of the field, which may be     * negative     */
/**     * Get the millisecond duration of this field from its value, which is     * approximate if this field is imprecise.     *      * @param value  the value of the field, which may be negative     * @return the milliseconds that the field represents, which may be     * negative     */
/**     * Gets the wrapped date time field.     *      * @return the wrapped DateTimeField     */
/**     * Constructor.     *      * @param field  the base field     * @param type  the type to actually use     */
/**     * Gets the wrapped duration field.     *      * @return the wrapped DurationField     */
/**     * Constructor.     *      * @param field  the field being decorated     */
/**     * Constructor.     *      * @param field  the field being decorated     * @param type  the field type override     */
/**     * Returns true if this field is supported.     */
/**     * Constructor.     *      * @param field  the field to wrap, like "year()".     * @param type  the field type this field will actually use     * @param divisor  divisor, such as 100 years in a century     * @throws IllegalArgumentException if divisor is less than two     */
/**     * Construct a DividedDateTimeField that compliments the given     * RemainderDateTimeField.     *     * @param remainderField  complimentary remainder field, like "yearOfCentury()".     * @param type  the field type this field will actually use     */
/**     * Get the amount of scaled units from the specified time instant.     *      * @param instant  the time instant in millis to query.     * @return the amount of scaled units extracted from the input.     */
/**     * Add the specified amount of scaled units to the specified time     * instant. The amount added may be negative.     *      * @param instant  the time instant in millis to update.     * @param amount  the amount of scaled units to add (can be negative).     * @return the updated time instant.     */
/**     * Add to the scaled component of the specified time instant,     * wrapping around within that component if necessary.     *      * @param instant  the time instant in millis to update.     * @param amount  the amount of scaled units to add (can be negative).     * @return the updated time instant.     */
/**     * Set the specified amount of scaled units to the specified time instant.     *      * @param instant  the time instant in millis to update.     * @param value  value of scaled units to set.     * @return the updated time instant.     * @throws IllegalArgumentException if value is too large or too small.     */
/**     * Returns a scaled version of the wrapped field's unit duration field.     */
/**     * Get the minimum value for the field.     *      * @return the minimum value     */
/**     * Get the maximum value for the field.     *      * @return the maximum value     */
/**     * Returns the divisor applied, in the field's units.     *      * @return the divisor     */
/**     * Negates the input throwing an exception if it can't negate it.     *      * @param value  the value to negate     * @return the negated value     * @throws ArithmeticException if the value is Integer.MIN_VALUE     * @since 1.1     */
/**     * Add two values throwing an exception if overflow occurs.     *      * @param val1  the first value     * @param val2  the second value     * @return the new total     * @throws ArithmeticException if the value is too big or too small     */
/**     * Subtracts two values throwing an exception if overflow occurs.     *      * @param val1  the first value, to be taken away from     * @param val2  the second value, the amount to take away     * @return the new total     * @throws ArithmeticException if the value is too big or too small     */
/**     * Multiply two values throwing an exception if overflow occurs.     *      * @param val1  the first value     * @param val2  the second value     * @return the new total     * @throws ArithmeticException if the value is too big or too small     */
/**     * Casts to an int throwing an exception if overflow occurs.     *      * @param value  the value     * @return the value as an int     * @throws ArithmeticException if the value is too big or too small     */
/**     * Multiply two values to return an int throwing an exception if overflow occurs.     *      * @param val1  the first value     * @param val2  the second value     * @return the new total     * @throws ArithmeticException if the value is too big or too small     */
/**     * Verify that input values are within specified bounds.     *      * @param value  the value to check     * @param lowerBound  the lower bound allowed for value     * @param upperBound  the upper bound allowed for value     * @throws IllegalFieldValueException if value is not in the specified bounds     */
/**     * Utility method that ensures the given value lies within the field's     * legal value range.     *      * @param value  the value to fit into the wrapped value range     * @param minValue the wrap range minimum value.     * @param maxValue the wrap range maximum value.  This must be     *  greater than minValue (checked by the method).     * @return the wrapped value     * @throws IllegalArgumentException if minValue is greater     *  than or equal to maxValue     */
/**     * Compares two objects as equals handling null.     *      * @param object1  the first object     * @param object2  the second object     * @return true if equal     * @since 1.4     */
/**     * Constructor.     *      * @param type  the field type     * @param unitMillis  the average duration unit milliseconds     */
/**     * Returns a lenient version of the given field. If it is already lenient,     * then it is returned as-is. Otherwise, a new LenientDateTimeField is     * returned.     */
/**     * Set values which may be out of bounds by adding the difference between     * the new value and the current value.     */
/**     * Returns true as this field is supported.     *      * @return true always     */
/**     * Returns true as this field is precise.     *      * @return true always     */
/**     * Returns the amount of milliseconds per unit value of this field.     *     * @return one always     */
/**     * Get a suitable debug string.     *      * @return debug string     */
/**     * Deserialize to the singleton.     */
/**     * Constructor.     *      * @param field  the field to wrap, like "year()".     * @param offset  offset to add to field values     * @throws IllegalArgumentException if offset is zero     */
/**     * Constructor.     *      * @param field  the field to wrap, like "year()".     * @param type  the field type this field actually uses     * @param offset  offset to add to field values     * @throws IllegalArgumentException if offset is zero     */
/**     * Constructor.     *      * @param field  the field to wrap, like "year()".     * @param type  the field type this field actually uses     * @param offset  offset to add to field values     * @throws IllegalArgumentException if offset is zero     */
/**     * Get the amount of offset units from the specified time instant.     *      * @param instant  the time instant in millis to query.     * @return the amount of units extracted from the input.     */
/**     * Add the specified amount of offset units to the specified time     * instant. The amount added may be negative.     *      * @param instant  the time instant in millis to update.     * @param amount  the amount of units to add (can be negative).     * @return the updated time instant.     */
/**     * Add to the offset component of the specified time instant,     * wrapping around within that component if necessary.     *      * @param instant  the time instant in millis to update.     * @param amount  the amount of units to add (can be negative).     * @return the updated time instant.     */
/**     * Set the specified amount of offset units to the specified time instant.     *      * @param instant  the time instant in millis to update.     * @param value  value of units to set.     * @return the updated time instant.     * @throws IllegalArgumentException if value is too large or too small.     */
/**     * Returns the offset added to the field values.     *      * @return the offset     */
/**     * Constructor.     *      * @param type  the field type this field uses     * @param unit  precise unit duration, like "seconds()".     * @param range precise range duration, preferably a multiple of the unit,     * like "minutes()".     * @throws IllegalArgumentException if either duration field is imprecise     * @throws IllegalArgumentException if unit milliseconds is less than one     * or effective value range is less than two.     */
/**     * Get the amount of fractional units from the specified time instant.     *      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query     * @return the amount of fractional units extracted from the input.     */
/**     * Add to the component of the specified time instant, wrapping around     * within that component if necessary.     *      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to     * @param amount  the amount of units to add (can be negative).     * @return the updated time instant.     */
/**     * Set the specified amount of units to the specified time instant.     *      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in     * @param value  value of units to set.     * @return the updated time instant.     * @throws IllegalArgumentException if value is too large or too small.     */
/**     * Returns the range duration of this field. For example, if this field     * represents "minute of hour", then the range duration field is an hours.     *     * @return the range duration of this field, or null if field has no range     */
/**     * Get the maximum value for the field.     *      * @return the maximum value     */
/**     * Returns the range of the field in the field's units.     * <p>     * For example, 60 for seconds per minute. The field is allowed values     * from 0 to range - 1.     *      * @return unit range     */
/**     * Constructor.     *      * @param type  the field type     * @param unit  precise unit duration, like "days()".     * @throws IllegalArgumentException if duration field is imprecise     * @throws IllegalArgumentException if unit milliseconds is less than one     */
/**     * Returns false by default.     */
/**     * Set the specified amount of units to the specified time instant.     *      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in     * @param value  value of units to set.     * @return the updated time instant.     * @throws IllegalArgumentException if value is too large or too small.     */
/**     * This method assumes that this field is properly rounded on     * 1970-01-01T00:00:00. If the rounding alignment differs, override this     * method as follows:     * <pre>     * return super.roundFloor(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;     * </pre>     */
/**     * This method assumes that this field is properly rounded on     * 1970-01-01T00:00:00. If the rounding alignment differs, override this     * method as follows:     * <pre>     * return super.roundCeiling(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;     * </pre>     */
/**     * This method assumes that this field is properly rounded on     * 1970-01-01T00:00:00. If the rounding alignment differs, override this     * method as follows:     * <pre>     * return super.remainder(instant + ALIGNMENT_MILLIS);     * </pre>     */
/**     * Returns the duration per unit value of this field. For example, if this     * field represents "minute of hour", then the duration field is minutes.     *     * @return the duration of this field, or UnsupportedDurationField if field     * has no duration     */
/**     * Get the minimum value for the field.     *      * @return the minimum value     */
/**     * Called by the set method to get the maximum allowed value. By default,     * returns getMaximumValue(instant). Override to provide a faster     * implementation.     */
/**     * Constructor.     *      * @param type  the field type     * @param unitMillis  the unit milliseconds     */
/**     * This field is precise.     *      * @return true always     */
/**     * Returns the amount of milliseconds per unit value of this field.     *     * @return the unit size of this field, in milliseconds     */
/**     * Get the value of this field from the milliseconds.     *      * @param duration  the milliseconds to query, which may be negative     * @param instant  ignored     * @return the value of the field, in the units of the field, which may be     * negative     */
/**     * Get the millisecond duration of this field from its value.     *      * @param value  the value of the field, which may be negative     * @param instant  ignored     * @return the milliseconds that the field represents, which may be     * negative     */
/**     * Compares this duration field to another.     * Two fields are equal if of the same type and duration.     *      * @param obj  the object to compare to     * @return if equal     */
/**     * Gets a hash code for this instance.     *      * @return a suitable hashcode     */
/**     * Constructor.     *      * @param field  the field to wrap, like "year()".     * @param type  the field type this field actually uses     * @param divisor  divisor, such as 100 years in a century     * @throws IllegalArgumentException if divisor is less than two     */
/**     * Construct a RemainderDateTimeField that compliments the given     * DividedDateTimeField.     *     * @param dividedField  complimentary divided field, like "century()".     */
/**     * Construct a RemainderDateTimeField that compliments the given     * DividedDateTimeField.     *     * @param dividedField  complimentary divided field, like "century()".     * @param type  the field type this field actually uses     */
/**     * Get the remainder from the specified time instant.     *      * @param instant  the time instant in millis to query.     * @return the remainder extracted from the input.     */
/**     * Add the specified amount to the specified time instant, wrapping around     * within the remainder range if necessary. The amount added may be     * negative.     *      * @param instant  the time instant in millis to update.     * @param amount  the amount to add (can be negative).     * @return the updated time instant.     */
/**     * Set the specified amount of remainder units to the specified time instant.     *      * @param instant  the time instant in millis to update.     * @param value  value of remainder units to set.     * @return the updated time instant.     * @throws IllegalArgumentException if value is too large or too small.     */
/**     * Returns a scaled version of the wrapped field's unit duration field.     */
/**     * Get the minimum value for the field, which is always zero.     *      * @return the minimum value of zero.     */
/**     * Get the maximum value for the field, which is always one less than the     * divisor.     *      * @return the maximum value     */
/**     * Constructor     *      * @param field  the field to wrap, like "year()".     * @param type  the type this field will actually use     * @param scalar  scalar, such as 100 years in a century     * @throws IllegalArgumentException if scalar is zero or one.     */
/**     * Returns the scalar applied, in the field's units.     *      * @return the scalar     */
/**     * Compares this duration field to another.     * Two fields are equal if of the same type and duration.     *      * @param obj  the object to compare to     * @return if equal     */
/**     * Gets a hash code for this instance.     *      * @return a suitable hashcode     */
/**     * Constructor that skips zero.     *      * @param chronology  the chronoogy to use     * @param field  the field to skip zero on     */
/**     * Constructor.     *      * @param chronology  the chronoogy to use     * @param field  the field to skip zero on     * @param skip  the value to skip     */
/**     * Constructor that reinserts zero.     *      * @param chronology  the chronoogy to use     * @param field  the field to skip zero on     */
/**     * Constructor.     *      * @param chronology  the chronoogy to use     * @param field  the field to skip zero on     * @param skip  the value to skip     */
/**     * Returns a strict version of the given field. If it is already strict,     * then it is returned as-is. Otherwise, a new StrictDateTimeField is     * returned.     */
/**     * Does a bounds check before setting the value.     *     * @throws IllegalArgumentException if the value is invalid     */
/**     * Gets an instance of UnsupportedDateTimeField for a specific named field.     * Names should be of standard format, such as 'monthOfYear' or 'hourOfDay'.     * The returned instance is cached.     *      * @param type  the type to obtain     * @return the instance     * @throws IllegalArgumentException if durationField is null     */
/**     * This field is not supported.     *     * @return false always     */
/**     * This field is not lenient.     *     * @return false always     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Delegates to the duration field.     *     * @throws UnsupportedOperationException if the duration is unsupported     */
/**     * Delegates to the duration field.     *     * @throws UnsupportedOperationException if the duration is unsupported     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Even though this DateTimeField is unsupported, the duration field might     * be supported.     *     * @return a possibly supported DurationField     */
/**     * Always returns null.     *     * @return null always     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always returns null.     *     * @return null always     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Ensure proper singleton serialization     */
/**     * Gets an instance of UnsupportedDurationField for a specific named field.     * The returned instance is cached.     *      * @param type  the type to obtain     * @return the instance     */
/**     * This field is precise.     *      * @return true always     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always throws UnsupportedOperationException     *     * @throws UnsupportedOperationException     */
/**     * Always returns zero.     *     * @return zero always     */
/**     * Always returns zero, indicating that sort order is not relevent.     *     * @return zero always     */
/**     * Compares this duration field to another.     *      * @param obj  the object to compare to     * @return true if equal     */
/**     * Gets a suitable hashcode.     *      * @return the hashcode     */
/**     * Ensure proper singleton serialization     */
/**     * Constructor.     *      * @param field  the base field     * @param type  the field type this field will actually use     * @throws IllegalArgumentException if wrapped field's minimum value is not zero     */
/**     * Always returns 1.     *      * @return the minimum value of 1     */
/**     * Get the maximum value for the field, which is one more than the wrapped     * field's maximum value.     *      * @return the maximum value     */
/**     * Factory to create a formatter from a pattern string.     * The pattern string is described above in the class level javadoc.     * It is very similar to SimpleDateFormat patterns.     * <p>     * The format may contain locale specific output, and this will change as     * you change the locale of the formatter.     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.     * For example:     * <pre>     * DateTimeFormat.forPattern(pattern).withLocale(Locale.FRANCE).print(dt);     * </pre>     *     * @param pattern  pattern specification     * @return the formatter     * @throws IllegalArgumentException if the pattern is invalid     */
/**     * Factory to create a format from a two character style pattern.     * <p>     * The first character is the date style, and the second character is the     * time style. Specify a character of 'S' for short style, 'M' for medium,     * 'L' for long, and 'F' for full.     * A date or time may be ommitted by specifying a style character '-'.     * <p>     * The returned formatter will dynamically adjust to the locale that     * the print/parse takes place in. Thus you just call     * {@link DateTimeFormatter#withLocale(Locale)} and the Short/Medium/Long/Full     * style for that locale will be output. For example:     * <pre>     * DateTimeFormat.forStyle(style).withLocale(Locale.FRANCE).print(dt);     * </pre>     *     * @param style  two characters from the set {"S", "M", "L", "F", "-"}     * @return the formatter     * @throws IllegalArgumentException if the style is invalid     */
/**     * Returns the pattern used by a particular style and locale.     * <p>     * The first character is the date style, and the second character is the     * time style. Specify a character of 'S' for short style, 'M' for medium,     * 'L' for long, and 'F' for full.     * A date or time may be ommitted by specifying a style character '-'.     *     * @param style  two characters from the set {"S", "M", "L", "F", "-"}     * @param locale  locale to use, null means default     * @return the formatter     * @throws IllegalArgumentException if the style is invalid     * @since 1.3     */
/**     * Creates a format that outputs a short date format.     * <p>     * The format will change as you change the locale of the formatter.     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.     *      * @return the formatter     */
/**     * Creates a format that outputs a short time format.     * <p>     * The format will change as you change the locale of the formatter.     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.     *      * @return the formatter     */
/**     * Creates a format that outputs a short datetime format.     * <p>     * The format will change as you change the locale of the formatter.     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.     *      * @return the formatter     */
/**     * Creates a format that outputs a medium date format.     * <p>     * The format will change as you change the locale of the formatter.     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.     *      * @return the formatter     */
/**     * Creates a format that outputs a medium time format.     * <p>     * The format will change as you change the locale of the formatter.     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.     *      * @return the formatter     */
/**     * Creates a format that outputs a medium datetime format.     * <p>     * The format will change as you change the locale of the formatter.     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.     *      * @return the formatter     */
/**     * Creates a format that outputs a long date format.     * <p>     * The format will change as you change the locale of the formatter.     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.     *      * @return the formatter     */
/**     * Creates a format that outputs a long time format.     * <p>     * The format will change as you change the locale of the formatter.     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.     *      * @return the formatter     */
/**     * Creates a format that outputs a long datetime format.     * <p>     * The format will change as you change the locale of the formatter.     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.     *      * @return the formatter     */
/**     * Creates a format that outputs a full date format.     * <p>     * The format will change as you change the locale of the formatter.     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.     *      * @return the formatter     */
/**     * Creates a format that outputs a full time format.     * <p>     * The format will change as you change the locale of the formatter.     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.     *      * @return the formatter     */
/**     * Creates a format that outputs a full datetime format.     * <p>     * The format will change as you change the locale of the formatter.     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.     *      * @return the formatter     */
/**     * Parses the given pattern and appends the rules to the given     * DateTimeFormatterBuilder.     *     * @param pattern  pattern specification     * @throws IllegalArgumentException if the pattern is invalid     */
/**     * Parses the given pattern and appends the rules to the given     * DateTimeFormatterBuilder.     *     * @param pattern  pattern specification     * @throws IllegalArgumentException if the pattern is invalid     * @see #forPattern     */
/**     * Parses an individual token.     *      * @param pattern  the pattern string     * @param indexRef  a single element array, where the input is the start     *  location and the output is the location after parsing the token     * @return the parsed token     */
/**     * Returns true if token should be parsed as a numeric field.     *      * @param token  the token to parse     * @return true if numeric field     */
/**     * Select a format from a custom pattern.     *     * @param pattern  pattern specification     * @throws IllegalArgumentException if the pattern is invalid     * @see #appendPatternTo     */
/**     * Select a format from a two character style pattern. The first character     * is the date style, and the second character is the time style. Specify a     * character of 'S' for short style, 'M' for medium, 'L' for long, and 'F'     * for full. A date or time may be ommitted by specifying a style character '-'.     *     * @param style  two characters from the set {"S", "M", "L", "F", "-"}     * @throws IllegalArgumentException if the style is invalid     */
/**     * Gets the formatter for the specified style.     *      * @param dateStyle  the date style     * @param timeStyle  the time style     * @return the formatter     */
/**     * Creates a formatter for the specified style.     * @param dateStyle  the date style     * @param timeStyle  the time style     * @return the formatter     */
/**     * Gets the JDK style code from the Joda code.     *      * @param ch  the Joda style code     * @return the JDK style code     */
/**     * Creates a new formatter, however you will normally use the factory     * or the builder.     *      * @param printer  the internal printer, null if cannot print     * @param parser  the internal parser, null if cannot parse     */
/**     * Returns a new formatter with a different locale that will be used     * for printing and parsing.     * <p>     * A DateTimeFormatter is immutable, so a new instance is returned,     * and the original is unaltered and still usable.     *      * @param locale the locale to use; if null, formatter uses default locale     * at invocation time     * @return the new formatter     */
/**     * Returns a new formatter that will create a datetime with a time zone     * equal to that of the offset of the parsed string.     * <p>     * After calling this method, a string '2004-06-09T10:20:30-08:00' will     * create a datetime with a zone of -08:00 (a fixed zone, with no daylight     * savings rules). If the parsed string represents a local time (no zone     * offset) the parsed datetime will be in the default zone.     * <p>     * Calling this method sets the override zone to null.     * Calling the override zone method sets this flag off.     *      * @return the new formatter     */
/**     * Returns a new formatter that will use the specified chronology in     * preference to that of the printed object, or ISO on a parse.     * <p>     * When printing, this chronolgy will be used in preference to the chronology     * from the datetime that would otherwise be used.     * <p>     * When parsing, this chronology will be set on the parsed datetime.     * <p>     * A null chronology means no-override.     * If both an override chronology and an override zone are set, the     * override zone will take precedence over the zone in the chronology.     *      * @param chrono  the chronology to use as an override     * @return the new formatter     */
/**     * Returns a new formatter that will use the UTC zone in preference     * to the zone of the printed object, or default zone on a parse.     * <p>     * When printing, UTC will be used in preference to the zone     * from the datetime that would otherwise be used.     * <p>     * When parsing, UTC will be set on the parsed datetime.     * <p>     * If both an override chronology and an override zone are set, the     * override zone will take precedence over the zone in the chronology.     *      * @return the new formatter, never null     * @since 2.0     */
/**     * Returns a new formatter that will use the specified zone in preference     * to the zone of the printed object, or default zone on a parse.     * <p>     * When printing, this zone will be used in preference to the zone     * from the datetime that would otherwise be used.     * <p>     * When parsing, this zone will be set on the parsed datetime.     * <p>     * A null zone means of no-override.     * If both an override chronology and an override zone are set, the     * override zone will take precedence over the zone in the chronology.     *      * @param zone  the zone to use as an override     * @return the new formatter     */
/**     * Returns a new formatter that will use the specified pivot year for two     * digit year parsing in preference to that stored in the parser.     * <p>     * This setting is useful for changing the pivot year of formats built     * using a pattern - {@link DateTimeFormat#forPattern(String)}.     * <p>     * When parsing, this pivot year is used. Null means no-override.     * There is no effect when printing.     * <p>     * The pivot year enables a two digit year to be converted to a four     * digit year. The pivot represents the year in the middle of the     * supported range of years. Thus the full range of years that will     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.     *     * <pre>     * pivot   supported range   00 is   20 is   40 is   60 is   80 is     * ---------------------------------------------------------------     * 1950      1900..1999      1900    1920    1940    1960    1980     * 1975      1925..2024      2000    2020    1940    1960    1980     * 2000      1950..2049      2000    2020    2040    1960    1980     * 2025      1975..2074      2000    2020    2040    2060    1980     * 2050      2000..2099      2000    2020    2040    2060    2080     * </pre>     *     * @param pivotYear  the pivot year to use as an override when parsing     * @return the new formatter     * @since 1.1     */
/**     * Returns a new formatter that will use the specified pivot year for two     * digit year parsing in preference to that stored in the parser.     * <p>     * This setting is useful for changing the pivot year of formats built     * using a pattern - {@link DateTimeFormat#forPattern(String)}.     * <p>     * When parsing, this pivot year is used.     * There is no effect when printing.     * <p>     * The pivot year enables a two digit year to be converted to a four     * digit year. The pivot represents the year in the middle of the     * supported range of years. Thus the full range of years that will     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.     *     * <pre>     * pivot   supported range   00 is   20 is   40 is   60 is   80 is     * ---------------------------------------------------------------     * 1950      1900..1999      1900    1920    1940    1960    1980     * 1975      1925..2024      2000    2020    1940    1960    1980     * 2000      1950..2049      2000    2020    2040    1960    1980     * 2025      1975..2074      2000    2020    2040    2060    1980     * 2050      2000..2099      2000    2020    2040    2060    2080     * </pre>     *     * @param pivotYear  the pivot year to use as an override when parsing     * @return the new formatter     * @since 1.1     */
/**     * Returns a new formatter that will use the specified default year.     * <p>     * The default year is used when parsing in the case where there is a     * month or a day but not a year. Specifically, it is used if there is     * a field parsed with a duration between the length of a month and the     * length of a day inclusive.     * <p>     * This value is typically used to move the year from 1970 to a leap year     * to enable February 29th to be parsed.     * Unless customised, the year 2000 is used.     * <p>     * This setting has no effect when printing.     *     * @param defaultYear  the default year to use     * @return the new formatter, not null     * @since 2.0     */
/**     * Is this formatter capable of printing.     *      * @return true if this is a printer     */
/**     * Gets the internal printer object that performs the real printing work.     *      * @return the internal printer; is null if printing not supported     */
/**     * Is this formatter capable of parsing.     *      * @return true if this is a parser     */
/**     * Gets the internal parser object that performs the real parsing work.     *      * @return the internal parser; is null if parsing not supported     */
/**     * Returns a new formatter with a different locale that will be used     * for printing and parsing.     * <p>     * A DateTimeFormatter is immutable, so a new instance is returned,     * and the original is unaltered and still usable.     *      * @param locale the locale to use; if null, formatter uses default locale     * at invocation time     * @return the new formatter     */
/**     * Gets the locale that will be used for printing and parsing.     *      * @return the locale to use; if null, formatter uses default locale at     * invocation time     */
/**     * Returns a new formatter that will create a datetime with a time zone     * equal to that of the offset of the parsed string.     * <p>     * After calling this method, a string '2004-06-09T10:20:30-08:00' will     * create a datetime with a zone of -08:00 (a fixed zone, with no daylight     * savings rules). If the parsed string represents a local time (no zone     * offset) the parsed datetime will be in the default zone.     * <p>     * Calling this method sets the override zone to null.     * Calling the override zone method sets this flag off.     *      * @return the new formatter     */
/**     * Checks whether the offset from the string is used as the zone of     * the parsed datetime.     *      * @return true if the offset from the string is used as the zone     */
/**     * Returns a new formatter that will use the specified chronology in     * preference to that of the printed object, or ISO on a parse.     * <p>     * When printing, this chronolgy will be used in preference to the chronology     * from the datetime that would otherwise be used.     * <p>     * When parsing, this chronology will be set on the parsed datetime.     * <p>     * A null chronology means no-override.     * If both an override chronology and an override zone are set, the     * override zone will take precedence over the zone in the chronology.     *      * @param chrono  the chronology to use as an override     * @return the new formatter     */
/**     * Gets the chronology to use as an override.     *      * @return the chronology to use as an override     */
/**     * Returns a new formatter that will use the UTC zone in preference     * to the zone of the printed object, or default zone on a parse.     * <p>     * When printing, UTC will be used in preference to the zone     * from the datetime that would otherwise be used.     * <p>     * When parsing, UTC will be set on the parsed datetime.     * <p>     * If both an override chronology and an override zone are set, the     * override zone will take precedence over the zone in the chronology.     *      * @return the new formatter, never null     * @since 2.0     */
/**     * Returns a new formatter that will use the specified zone in preference     * to the zone of the printed object, or default zone on a parse.     * <p>     * When printing, this zone will be used in preference to the zone     * from the datetime that would otherwise be used.     * <p>     * When parsing, this zone will be set on the parsed datetime.     * <p>     * A null zone means of no-override.     * If both an override chronology and an override zone are set, the     * override zone will take precedence over the zone in the chronology.     *      * @param zone  the zone to use as an override     * @return the new formatter     */
/**     * Gets the zone to use as an override.     *      * @return the zone to use as an override     */
/**     * Returns a new formatter that will use the specified pivot year for two     * digit year parsing in preference to that stored in the parser.     * <p>     * This setting is useful for changing the pivot year of formats built     * using a pattern - {@link DateTimeFormat#forPattern(String)}.     * <p>     * When parsing, this pivot year is used.     * There is no effect when printing.     * <p>     * The pivot year enables a two digit year to be converted to a four     * digit year. The pivot represents the year in the middle of the     * supported range of years. Thus the full range of years that will     * be built is <code>(pivot - 50) .. (pivot + 49)</code>.     *     * <pre>     * pivot   supported range   00 is   20 is   40 is   60 is   80 is     * ---------------------------------------------------------------     * 1950      1900..1999      1900    1920    1940    1960    1980     * 1975      1925..2024      2000    2020    1940    1960    1980     * 2000      1950..2049      2000    2020    2040    1960    1980     * 2025      1975..2074      2000    2020    2040    2060    1980     * 2050      2000..2099      2000    2020    2040    2060    2080     * </pre>     *     * @param pivotYear  the pivot year to use as an override when parsing     * @return the new formatter     * @since 1.1     */
/**     * Gets the pivot year to use as an override.     *     * @return the pivot year to use as an override     * @since 1.1     */
/**     * Returns a new formatter that will use the specified default year.     * <p>     * The default year is used when parsing in the case where there is a     * month or a day but not a year. Specifically, it is used if there is     * a field parsed with a duration between the length of a month and the     * length of a day inclusive.     * <p>     * This value is typically used to move the year from 1970 to a leap year     * to enable February 29th to be parsed.     * Unless customised, the year 2000 is used.     * <p>     * This setting has no effect when printing.     *     * @param defaultYear  the default year to use     * @return the new formatter, not null     * @since 2.0     */
/**     * Gets the default year for parsing months and days.     *     * @return the default year for parsing months and days     * @since 2.0     */
/**     * Prints a ReadablePartial to a new String.     * <p>     * Neither the override chronology nor the override zone are used     * by this method.     *     * @param partial  partial to format     * @return the printed result     */
/**     * Checks whether printing is supported.     *      * @throws UnsupportedOperationException if printing is not supported     */
/**     * Parses a datetime from the given text, at the given position, saving the     * result into the fields of the given ReadWritableInstant. If the parse     * succeeds, the return value is the new text position. Note that the parse     * may succeed without fully reading the text and in this case those fields     * that were read will be set.     * <p>     * Only those fields present in the string will be changed in the specified     * instant. All other fields will remain unaltered. Thus if the string only     * contains a year and a month, then the day and time will be retained from     * the input instant. If this is not the behaviour you want, then reset the     * fields before calling this method, or use {@link #parseDateTime(String)}     * or {@link #parseMutableDateTime(String)}.     * <p>     * If it fails, the return value is negative, but the instant may still be     * modified. To determine the position where the parse failed, apply the     * one's complement operator (~) on the return value.     * <p>     * This parse method ignores the {@link #getDefaultYear() default year} and     * parses using the year from the supplied instant based on the chronology     * and time-zone of the supplied instant.     * <p>     * The parse will use the chronology of the instant.     *     * @param instant  an instant that will be modified, not null     * @param text  the text to parse     * @param position  position to start parsing from     * @return new position, negative value means parse failed -     *  apply complement operator (~) to get position of failure     * @throws UnsupportedOperationException if parsing is not supported     * @throws IllegalArgumentException if the instant is null     * @throws IllegalArgumentException if any field is out of range     */
/**     * Parses a datetime from the given text, returning the number of     * milliseconds since the epoch, 1970-01-01T00:00:00Z.     * <p>     * The parse will use the ISO chronology, and the default time zone.     * If the text contains a time zone string then that will be taken into account.     *     * @param text  text to parse     * @return parsed value expressed in milliseconds since the epoch     * @throws UnsupportedOperationException if parsing is not supported     * @throws IllegalArgumentException if the text to parse is invalid     */
/**     * Parses only the local date from the given text, returning a new LocalDate.     * <p>     * This will parse the text fully according to the formatter, using the UTC zone.     * Once parsed, only the local date will be used.     * This means that any parsed time, time-zone or offset field is completely ignored.     * It also means that the zone and offset-parsed settings are ignored.     *     * @param text  the text to parse, not null     * @return the parsed date, never null     * @throws UnsupportedOperationException if parsing is not supported     * @throws IllegalArgumentException if the text to parse is invalid     * @since 2.0     */
/**     * Parses only the local time from the given text, returning a new LocalTime.     * <p>     * This will parse the text fully according to the formatter, using the UTC zone.     * Once parsed, only the local time will be used.     * This means that any parsed date, time-zone or offset field is completely ignored.     * It also means that the zone and offset-parsed settings are ignored.     *     * @param text  the text to parse, not null     * @return the parsed time, never null     * @throws UnsupportedOperationException if parsing is not supported     * @throws IllegalArgumentException if the text to parse is invalid     * @since 2.0     */
/**     * Parses only the local date-time from the given text, returning a new LocalDateTime.     * <p>     * This will parse the text fully according to the formatter, using the UTC zone.     * Once parsed, only the local date-time will be used.     * This means that any parsed time-zone or offset field is completely ignored.     * It also means that the zone and offset-parsed settings are ignored.     *     * @param text  the text to parse, not null     * @return the parsed date-time, never null     * @throws UnsupportedOperationException if parsing is not supported     * @throws IllegalArgumentException if the text to parse is invalid     * @since 2.0     */
/**     * Parses a date-time from the given text, returning a new DateTime.     * <p>     * The parse will use the zone and chronology specified on this formatter.     * <p>     * If the text contains a time zone string then that will be taken into     * account in adjusting the time of day as follows.     * If the {@link #withOffsetParsed()} has been called, then the resulting     * DateTime will have a fixed offset based on the parsed time zone.     * Otherwise the resulting DateTime will have the zone of this formatter,     * but the parsed zone may have caused the time to be adjusted.     *     * @param text  the text to parse, not null     * @return the parsed date-time, never null     * @throws UnsupportedOperationException if parsing is not supported     * @throws IllegalArgumentException if the text to parse is invalid     */
/**     * Parses a date-time from the given text, returning a new MutableDateTime.     * <p>     * The parse will use the zone and chronology specified on this formatter.     * <p>     * If the text contains a time zone string then that will be taken into     * account in adjusting the time of day as follows.     * If the {@link #withOffsetParsed()} has been called, then the resulting     * DateTime will have a fixed offset based on the parsed time zone.     * Otherwise the resulting DateTime will have the zone of this formatter,     * but the parsed zone may have caused the time to be adjusted.     *     * @param text  the text to parse, not null     * @return the parsed date-time, never null     * @throws UnsupportedOperationException if parsing is not supported     * @throws IllegalArgumentException if the text to parse is invalid     */
/**     * Checks whether parsing is supported.     *      * @throws UnsupportedOperationException if parsing is not supported     */
/**     * Determines the correct chronology to use.     *     * @param chrono  the proposed chronology     * @return the actual chronology     */
/**     * Creates a DateTimeFormatterBuilder.     */
/**     * Appends another formatter.     * <p>     * This extracts the underlying printer and parser and appends them     * The printer and parser interfaces are the low-level part of the formatting API.     * Normally, instances are extracted from another formatter.     * Note however that any formatter specific information, such as the locale,     * time-zone, chronology, offset parsing or pivot/default year, will not be     * extracted by this method.     *     * @param formatter  the formatter to add     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if formatter is null or of an invalid type     */
/**     * Appends just a printer. With no matching parser, a parser cannot be     * built from this DateTimeFormatterBuilder.     * <p>     * The printer interface is part of the low-level part of the formatting API.     * Normally, instances are extracted from another formatter.     * Note however that any formatter specific information, such as the locale,     * time-zone, chronology, offset parsing or pivot/default year, will not be     * extracted by this method.     *     * @param printer  the printer to add, not null     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if printer is null or of an invalid type     */
/**     * Appends just a parser. With no matching printer, a printer cannot be     * built from this builder.     * <p>     * The parser interface is part of the low-level part of the formatting API.     * Normally, instances are extracted from another formatter.     * Note however that any formatter specific information, such as the locale,     * time-zone, chronology, offset parsing or pivot/default year, will not be     * extracted by this method.     *     * @param parser  the parser to add, not null     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if parser is null or of an invalid type     */
/**     * Appends a printer/parser pair.     * <p>     * The printer and parser interfaces are the low-level part of the formatting API.     * Normally, instances are extracted from another formatter.     * Note however that any formatter specific information, such as the locale,     * time-zone, chronology, offset parsing or pivot/default year, will not be     * extracted by this method.     *     * @param printer  the printer to add, not null     * @param parser  the parser to add, not null     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if printer or parser is null or of an invalid type     */
/**     * Appends a printer and a set of matching parsers. When parsing, the first     * parser in the list is selected for parsing. If it fails, the next is     * chosen, and so on. If none of these parsers succeeds, then the failed     * position of the parser that made the greatest progress is returned.     * <p>     * Only the printer is optional. In addition, it is illegal for any but the     * last of the parser array elements to be null. If the last element is     * null, this represents the empty parser. The presence of an empty parser     * indicates that the entire array of parse formats is optional.     * <p>     * The printer and parser interfaces are the low-level part of the formatting API.     * Normally, instances are extracted from another formatter.     * Note however that any formatter specific information, such as the locale,     * time-zone, chronology, offset parsing or pivot/default year, will not be     * extracted by this method.     *     * @param printer  the printer to add     * @param parsers  the parsers to add     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if any printer or parser is of an invalid type     * @throws IllegalArgumentException if any parser element but the last is null     */
/**     * Appends just a parser element which is optional. With no matching     * printer, a printer cannot be built from this DateTimeFormatterBuilder.     * <p>     * The parser interface is part of the low-level part of the formatting API.     * Normally, instances are extracted from another formatter.     * Note however that any formatter specific information, such as the locale,     * time-zone, chronology, offset parsing or pivot/default year, will not be     * extracted by this method.     *     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if parser is null or of an invalid type     */
/**     * Instructs the printer to emit a specific character, and the parser to     * expect it. The parser is case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit specific text, and the parser to expect     * it. The parser is case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if text is null     */
/**     * Instructs the printer to emit a field value as a decimal number, and the     * parser to expect an unsigned decimal number.     *     * @param fieldType  type of field to append     * @param minDigits  minimum number of digits to <i>print</i>     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated     * maximum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if field type is null     */
/**     * Instructs the printer to emit a field value as a fixed-width decimal     * number (smaller numbers will be left-padded with zeros), and the parser     * to expect an unsigned decimal number with the same fixed width.     *      * @param fieldType  type of field to append     * @param numDigits  the exact number of digits to parse or print, except if     * printed value requires more digits     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>     * @since 1.5     */
/**     * Instructs the printer to emit a field value as a decimal number, and the     * parser to expect a signed decimal number.     *     * @param fieldType  type of field to append     * @param minDigits  minimum number of digits to <i>print</i>     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated     * maximum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if field type is null     */
/**     * Instructs the printer to emit a field value as a fixed-width decimal     * number (smaller numbers will be left-padded with zeros), and the parser     * to expect an signed decimal number with the same fixed width.     *      * @param fieldType  type of field to append     * @param numDigits  the exact number of digits to parse or print, except if     * printed value requires more digits     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>     * @since 1.5     */
/**     * Instructs the printer to emit a field value as text, and the     * parser to expect text.     *     * @param fieldType  type of field to append     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if field type is null     */
/**     * Instructs the printer to emit a field value as short text, and the     * parser to expect text.     *     * @param fieldType  type of field to append     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if field type is null     */
/**     * Instructs the printer to emit a remainder of time as a decimal fraction,     * without decimal point. For example, if the field is specified as     * minuteOfHour and the time is 12:30:45, the value printed is 75. A     * decimal point is implied, so the fraction is 0.75, or three-quarters of     * a minute.     *     * @param fieldType  type of field to append     * @param minDigits  minimum number of digits to print.     * @param maxDigits  maximum number of digits to print or parse.     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if field type is null     */
/**     * Appends the print/parse of a fractional second.     * <p>     * This reliably handles the case where fractional digits are being handled     * beyond a visible decimal point. The digits parsed will always be treated     * as the most significant (numerically largest) digits.     * Thus '23' will be parsed as 230 milliseconds.     * Contrast this behaviour to {@link #appendMillisOfSecond}.     * This method does not print or parse the decimal point itself.     *      * @param minDigits  minimum number of digits to print     * @param maxDigits  maximum number of digits to print or parse     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Appends the print/parse of a fractional minute.     * <p>     * This reliably handles the case where fractional digits are being handled     * beyond a visible decimal point. The digits parsed will always be treated     * as the most significant (numerically largest) digits.     * Thus '23' will be parsed as 0.23 minutes (converted to milliseconds).     * This method does not print or parse the decimal point itself.     *      * @param minDigits  minimum number of digits to print     * @param maxDigits  maximum number of digits to print or parse     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Appends the print/parse of a fractional hour.     * <p>     * This reliably handles the case where fractional digits are being handled     * beyond a visible decimal point. The digits parsed will always be treated     * as the most significant (numerically largest) digits.     * Thus '23' will be parsed as 0.23 hours (converted to milliseconds).     * This method does not print or parse the decimal point itself.     *      * @param minDigits  minimum number of digits to print     * @param maxDigits  maximum number of digits to print or parse     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Appends the print/parse of a fractional day.     * <p>     * This reliably handles the case where fractional digits are being handled     * beyond a visible decimal point. The digits parsed will always be treated     * as the most significant (numerically largest) digits.     * Thus '23' will be parsed as 0.23 days (converted to milliseconds).     * This method does not print or parse the decimal point itself.     *      * @param minDigits  minimum number of digits to print     * @param maxDigits  maximum number of digits to print or parse     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric millisOfSecond field.     * <p>     * This method will append a field that prints a three digit value.     * During parsing the value that is parsed is assumed to be three digits.     * If less than three digits are present then they will be counted as the     * smallest parts of the millisecond. This is probably not what you want     * if you are using the field as a fraction. Instead, a fractional     * millisecond should be produced using {@link #appendFractionOfSecond}.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric millisOfDay field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric secondOfMinute field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric secondOfDay field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric minuteOfHour field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric minuteOfDay field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric hourOfDay field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric clockhourOfDay field.     *     * @param minDigits minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric hourOfHalfday field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric clockhourOfHalfday field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric dayOfWeek field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric dayOfMonth field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric dayOfYear field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric weekOfWeekyear field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric weekyear field.     *     * @param minDigits  minimum number of digits to <i>print</i>     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated     * maximum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric monthOfYear field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric year field.     *     * @param minDigits  minimum number of digits to <i>print</i>     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated     * maximum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric year field which always prints     * and parses two digits. A pivot year is used during parsing to determine     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.     *     * <pre>     * pivot   supported range   00 is   20 is   40 is   60 is   80 is     * ---------------------------------------------------------------     * 1950      1900..1999      1900    1920    1940    1960    1980     * 1975      1925..2024      2000    2020    1940    1960    1980     * 2000      1950..2049      2000    2020    2040    1960    1980     * 2025      1975..2074      2000    2020    2040    2060    1980     * 2050      2000..2099      2000    2020    2040    2060    2080     * </pre>     *     * @param pivot  pivot year to use when parsing     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric year field which always prints     * two digits. A pivot year is used during parsing to determine the range     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If     * parse is instructed to be lenient and the digit count is not two, it is     * treated as an absolute year. With lenient parsing, specifying a positive     * or negative sign before the year also makes it absolute.     *     * @param pivot  pivot year to use when parsing     * @param lenientParse  when true, if digit count is not two, it is treated     * as an absolute year     * @return this DateTimeFormatterBuilder, for chaining     * @since 1.1     */
/**     * Instructs the printer to emit a numeric weekyear field which always prints     * and parses two digits. A pivot year is used during parsing to determine     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.     *     * <pre>     * pivot   supported range   00 is   20 is   40 is   60 is   80 is     * ---------------------------------------------------------------     * 1950      1900..1999      1900    1920    1940    1960    1980     * 1975      1925..2024      2000    2020    1940    1960    1980     * 2000      1950..2049      2000    2020    2040    1960    1980     * 2025      1975..2074      2000    2020    2040    2060    1980     * 2050      2000..2099      2000    2020    2040    2060    2080     * </pre>     *     * @param pivot  pivot weekyear to use when parsing     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric weekyear field which always prints     * two digits. A pivot year is used during parsing to determine the range     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If     * parse is instructed to be lenient and the digit count is not two, it is     * treated as an absolute weekyear. With lenient parsing, specifying a positive     * or negative sign before the weekyear also makes it absolute.     *     * @param pivot  pivot weekyear to use when parsing     * @param lenientParse  when true, if digit count is not two, it is treated     * as an absolute weekyear     * @return this DateTimeFormatterBuilder, for chaining     * @since 1.1     */
/**     * Instructs the printer to emit a numeric yearOfEra field.     *     * @param minDigits  minimum number of digits to <i>print</i>     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated     * maximum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric year of century field.     *     * @param minDigits  minimum number of digits to print     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated     * maximum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric century of era field.     *     * @param minDigits  minimum number of digits to print     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated     * maximum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a locale-specific AM/PM text, and the     * parser to expect it. The parser is case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a locale-specific dayOfWeek text. The     * parser will accept a long or short dayOfWeek text, case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a short locale-specific dayOfWeek     * text. The parser will accept a long or short dayOfWeek text,     * case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a short locale-specific monthOfYear     * text. The parser will accept a long or short monthOfYear text,     * case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a locale-specific monthOfYear text. The     * parser will accept a long or short monthOfYear text, case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a locale-specific era text (BC/AD), and     * the parser to expect it. The parser is case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a locale-specific time zone name.     * Using this method prevents parsing, because time zone names are not unique.     * See {@link #appendTimeZoneName(Map)}.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a locale-specific time zone name, providing a lookup for parsing.     * Time zone names are not unique, thus the API forces you to supply the lookup.     * The names are searched in the order of the map, thus it is strongly recommended     * to use a {@code LinkedHashMap} or similar.     *     * @param parseLookup  the table of names, not null     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a short locale-specific time zone name.     * Using this method prevents parsing, because time zone names are not unique.     * See {@link #appendTimeZoneShortName(Map)}.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a short locale-specific time zone     * name, providing a lookup for parsing.     * Time zone names are not unique, thus the API forces you to supply the lookup.     * The names are searched in the order of the map, thus it is strongly recommended     * to use a {@code LinkedHashMap} or similar.     *     * @param parseLookup  the table of names, null to use the {@link DateTimeUtils#getDefaultTimeZoneNames() default names}     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit the identifier of the time zone.     * From version 2.0, this field can be parsed.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit text and numbers to display time zone     * offset from UTC. A parser will use the parsed time zone offset to adjust     * the datetime.     * <p>     * If zero offset text is supplied, then it will be printed when the zone is zero.     * During parsing, either the zero offset text, or the offset will be parsed.     *     * @param zeroOffsetText  the text to use if time zone offset is zero. If     * null, offset is always shown.     * @param showSeparators  if true, prints ':' separator before minute and     * second field and prints '.' separator before fraction field.     * @param minFields  minimum number of fields to print, stopping when no     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction     * @param maxFields  maximum number of fields to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Calls upon {@link DateTimeFormat} to parse the pattern and append the     * results into this builder.     *     * @param pattern  pattern specification     * @throws IllegalArgumentException if the pattern is invalid     * @see DateTimeFormat     */
/**     * Constructs a DateTimeFormatter using all the appended elements.     * <p>     * This is the main method used by applications at the end of the build     * process to create a usable formatter.     * <p>     * Subsequent changes to this builder do not affect the returned formatter.     * <p>     * The returned formatter may not support both printing and parsing.     * The methods {@link DateTimeFormatter#isPrinter()} and     * {@link DateTimeFormatter#isParser()} will help you determine the state     * of the formatter.     *     * @throws UnsupportedOperationException if neither printing nor parsing is supported     */
/**     * Internal method to create a DateTimePrinter instance using all the     * appended elements.     * <p>     * Most applications will not use this method.     * If you want a printer in an application, call {@link #toFormatter()}     * and just use the printing API.     * <p>     * Subsequent changes to this builder do not affect the returned printer.     *     * @throws UnsupportedOperationException if printing is not supported     */
/**     * Internal method to create a DateTimeParser instance using all the     * appended elements.     * <p>     * Most applications will not use this method.     * If you want a parser in an application, call {@link #toFormatter()}     * and just use the parsing API.     * <p>     * Subsequent changes to this builder do not affect the returned parser.     *     * @throws UnsupportedOperationException if parsing is not supported     */
/**     * Returns true if toFormatter can be called without throwing an     * UnsupportedOperationException.     *      * @return true if a formatter can be built     */
/**     * Returns true if toPrinter can be called without throwing an     * UnsupportedOperationException.     *      * @return true if a printer can be built     */
/**     * Returns true if toParser can be called without throwing an     * UnsupportedOperationException.     *      * @return true if a parser can be built     */
/**     * Clears out all the appended elements, allowing this builder to be     * reused.     */
/**     * Appends a printer and a set of matching parsers. When parsing, the first     * parser in the list is selected for parsing. If it fails, the next is     * chosen, and so on. If none of these parsers succeeds, then the failed     * position of the parser that made the greatest progress is returned.     * <p>     * Only the printer is optional. In addition, it is illegal for any but the     * last of the parser array elements to be null. If the last element is     * null, this represents the empty parser. The presence of an empty parser     * indicates that the entire array of parse formats is optional.     * <p>     * The printer and parser interfaces are the low-level part of the formatting API.     * Normally, instances are extracted from another formatter.     * Note however that any formatter specific information, such as the locale,     * time-zone, chronology, offset parsing or pivot/default year, will not be     * extracted by this method.     *     * @param printer  the printer to add     * @param parsers  the parsers to add     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if any printer or parser is of an invalid type     * @throws IllegalArgumentException if any parser element but the last is null     */
/**     * Appends just a parser element which is optional. With no matching     * printer, a printer cannot be built from this DateTimeFormatterBuilder.     * <p>     * The parser interface is part of the low-level part of the formatting API.     * Normally, instances are extracted from another formatter.     * Note however that any formatter specific information, such as the locale,     * time-zone, chronology, offset parsing or pivot/default year, will not be     * extracted by this method.     *     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if parser is null or of an invalid type     */
/**     * Checks if the parser is non null and a provider.     *      * @param parser  the parser to check     */
/**     * Checks if the printer is non null and a provider.     *      * @param printer  the printer to check     */
/**     * Instructs the printer to emit specific text, and the parser to expect     * it. The parser is case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if text is null     */
/**     * Instructs the printer to emit a field value as a decimal number, and the     * parser to expect an unsigned decimal number.     *     * @param fieldType  type of field to append     * @param minDigits  minimum number of digits to <i>print</i>     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated     * maximum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if field type is null     */
/**     * Instructs the printer to emit a field value as a fixed-width decimal     * number (smaller numbers will be left-padded with zeros), and the parser     * to expect an unsigned decimal number with the same fixed width.     *      * @param fieldType  type of field to append     * @param numDigits  the exact number of digits to parse or print, except if     * printed value requires more digits     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>     * @since 1.5     */
/**     * Instructs the printer to emit a field value as a decimal number, and the     * parser to expect a signed decimal number.     *     * @param fieldType  type of field to append     * @param minDigits  minimum number of digits to <i>print</i>     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated     * maximum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if field type is null     */
/**     * Instructs the printer to emit a field value as a fixed-width decimal     * number (smaller numbers will be left-padded with zeros), and the parser     * to expect an signed decimal number with the same fixed width.     *      * @param fieldType  type of field to append     * @param numDigits  the exact number of digits to parse or print, except if     * printed value requires more digits     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>     * @since 1.5     */
/**     * Instructs the printer to emit a field value as text, and the     * parser to expect text.     *     * @param fieldType  type of field to append     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if field type is null     */
/**     * Instructs the printer to emit a field value as short text, and the     * parser to expect text.     *     * @param fieldType  type of field to append     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if field type is null     */
/**     * Instructs the printer to emit a remainder of time as a decimal fraction,     * without decimal point. For example, if the field is specified as     * minuteOfHour and the time is 12:30:45, the value printed is 75. A     * decimal point is implied, so the fraction is 0.75, or three-quarters of     * a minute.     *     * @param fieldType  type of field to append     * @param minDigits  minimum number of digits to print.     * @param maxDigits  maximum number of digits to print or parse.     * @return this DateTimeFormatterBuilder, for chaining     * @throws IllegalArgumentException if field type is null     */
/**     * Appends the print/parse of a fractional second.     * <p>     * This reliably handles the case where fractional digits are being handled     * beyond a visible decimal point. The digits parsed will always be treated     * as the most significant (numerically largest) digits.     * Thus '23' will be parsed as 230 milliseconds.     * Contrast this behaviour to {@link #appendMillisOfSecond}.     * This method does not print or parse the decimal point itself.     *      * @param minDigits  minimum number of digits to print     * @param maxDigits  maximum number of digits to print or parse     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Appends the print/parse of a fractional minute.     * <p>     * This reliably handles the case where fractional digits are being handled     * beyond a visible decimal point. The digits parsed will always be treated     * as the most significant (numerically largest) digits.     * Thus '23' will be parsed as 0.23 minutes (converted to milliseconds).     * This method does not print or parse the decimal point itself.     *      * @param minDigits  minimum number of digits to print     * @param maxDigits  maximum number of digits to print or parse     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Appends the print/parse of a fractional hour.     * <p>     * This reliably handles the case where fractional digits are being handled     * beyond a visible decimal point. The digits parsed will always be treated     * as the most significant (numerically largest) digits.     * Thus '23' will be parsed as 0.23 hours (converted to milliseconds).     * This method does not print or parse the decimal point itself.     *      * @param minDigits  minimum number of digits to print     * @param maxDigits  maximum number of digits to print or parse     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Appends the print/parse of a fractional day.     * <p>     * This reliably handles the case where fractional digits are being handled     * beyond a visible decimal point. The digits parsed will always be treated     * as the most significant (numerically largest) digits.     * Thus '23' will be parsed as 0.23 days (converted to milliseconds).     * This method does not print or parse the decimal point itself.     *      * @param minDigits  minimum number of digits to print     * @param maxDigits  maximum number of digits to print or parse     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric millisOfSecond field.     * <p>     * This method will append a field that prints a three digit value.     * During parsing the value that is parsed is assumed to be three digits.     * If less than three digits are present then they will be counted as the     * smallest parts of the millisecond. This is probably not what you want     * if you are using the field as a fraction. Instead, a fractional     * millisecond should be produced using {@link #appendFractionOfSecond}.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric millisOfDay field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric secondOfMinute field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric secondOfDay field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric minuteOfHour field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric minuteOfDay field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric hourOfDay field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric clockhourOfDay field.     *     * @param minDigits minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric hourOfHalfday field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric clockhourOfHalfday field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric dayOfWeek field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric dayOfMonth field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric dayOfYear field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric weekOfWeekyear field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric weekyear field.     *     * @param minDigits  minimum number of digits to <i>print</i>     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated     * maximum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric monthOfYear field.     *     * @param minDigits  minimum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric year field.     *     * @param minDigits  minimum number of digits to <i>print</i>     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated     * maximum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric year field which always prints     * two digits. A pivot year is used during parsing to determine the range     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If     * parse is instructed to be lenient and the digit count is not two, it is     * treated as an absolute year. With lenient parsing, specifying a positive     * or negative sign before the year also makes it absolute.     *     * @param pivot  pivot year to use when parsing     * @param lenientParse  when true, if digit count is not two, it is treated     * as an absolute year     * @return this DateTimeFormatterBuilder, for chaining     * @since 1.1     */
/**     * Instructs the printer to emit a numeric weekyear field which always prints     * two digits. A pivot year is used during parsing to determine the range     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If     * parse is instructed to be lenient and the digit count is not two, it is     * treated as an absolute weekyear. With lenient parsing, specifying a positive     * or negative sign before the weekyear also makes it absolute.     *     * @param pivot  pivot weekyear to use when parsing     * @param lenientParse  when true, if digit count is not two, it is treated     * as an absolute weekyear     * @return this DateTimeFormatterBuilder, for chaining     * @since 1.1     */
/**     * Instructs the printer to emit a numeric yearOfEra field.     *     * @param minDigits  minimum number of digits to <i>print</i>     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated     * maximum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric year of century field.     *     * @param minDigits  minimum number of digits to print     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated     * maximum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a numeric century of era field.     *     * @param minDigits  minimum number of digits to print     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated     * maximum number of digits to print     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a locale-specific AM/PM text, and the     * parser to expect it. The parser is case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a locale-specific dayOfWeek text. The     * parser will accept a long or short dayOfWeek text, case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a short locale-specific dayOfWeek     * text. The parser will accept a long or short dayOfWeek text,     * case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a short locale-specific monthOfYear     * text. The parser will accept a long or short monthOfYear text,     * case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a locale-specific monthOfYear text. The     * parser will accept a long or short monthOfYear text, case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a locale-specific era text (BC/AD), and     * the parser to expect it. The parser is case-insensitive.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a locale-specific time zone name, providing a lookup for parsing.     * Time zone names are not unique, thus the API forces you to supply the lookup.     * The names are searched in the order of the map, thus it is strongly recommended     * to use a {@code LinkedHashMap} or similar.     *     * @param parseLookup  the table of names, not null     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit a short locale-specific time zone     * name, providing a lookup for parsing.     * Time zone names are not unique, thus the API forces you to supply the lookup.     * The names are searched in the order of the map, thus it is strongly recommended     * to use a {@code LinkedHashMap} or similar.     *     * @param parseLookup  the table of names, null to use the {@link DateTimeUtils#getDefaultTimeZoneNames() default names}     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit the identifier of the time zone.     * From version 2.0, this field can be parsed.     *     * @return this DateTimeFormatterBuilder, for chaining     */
/**     * Instructs the printer to emit text and numbers to display time zone     * offset from UTC. A parser will use the parsed time zone offset to adjust     * the datetime.     * <p>     * If zero offset print text is supplied, then it will be printed when the zone is zero.     * If zero offset parse text is supplied, then either it or the offset will be parsed.     *     * @param zeroOffsetPrintText  the text to print if time zone offset is zero. If     * null, offset is always shown.     * @param zeroOffsetParseText  the text to optionally parse to indicate that the time     * zone offset is zero. If null, then always use the offset.     * @param showSeparators  if true, prints ':' separator before minute and     * second field and prints '.' separator before fraction field.     * @param minFields  minimum number of fields to print, stopping when no     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction     * @param maxFields  maximum number of fields to print     * @return this DateTimeFormatterBuilder, for chaining     * @since 2.0     */
/**     * Calls upon {@link DateTimeFormat} to parse the pattern and append the     * results into this builder.     *     * @param pattern  pattern specification     * @throws IllegalArgumentException if the pattern is invalid     * @see DateTimeFormat     */
/**         * Returns actual amount of digits to parse, but no more than original         * 'amount' parameter.         */
/**         * Processes the element pairs, putting results into the given printer         * and parser lists.         */
/**     * Gets the chronology of the bucket, which will be a local (UTC) chronology.     */
/**     * Returns the locale to be used during parsing.     *      * @return the locale to use     */
/**     * Returns the time zone used by computeMillis.     */
/**     * Set a time zone to be used when computeMillis is called.     */
/**     * Returns the time zone offset in milliseconds used by computeMillis.     */
/**     * Set a time zone offset to be used when computeMillis is called.     */
/**     * Returns the default year used when information is incomplete.     * <p>     * This is used for two-digit years and when the largest parsed field is     * months or days.     * <p>     * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.     * A null value for month/day only parsing will cause the default of 2000 to be used.     *     * @return Integer value of the pivot year, null if not set     * @since 1.1     */
/**     * Sets the pivot year to use when parsing two digit years.     * <p>     * If the value is set to null, this will indicate that default     * behaviour should be used.     *     * @param pivotYear  the pivot year to use     * @since 1.1     */
/**     * Saves the state of this bucket, returning it in an opaque object. Call     * restoreState to undo any changes that were made since the state was     * saved. Calls to saveState may be nested.     *     * @return opaque saved state, which may be passed to restoreState     */
/**     * Computes the parsed datetime by setting the saved fields.     * This method is idempotent, but it is not thread-safe.     *     * @param resetFields false by default, but when true, unsaved field values are cleared     * @param text optional text being parsed, to be included in any error message     * @return milliseconds since 1970-01-01T00:00:00Z     * @throws IllegalArgumentException if any field is out of range     * @since 1.3     */
/**     * Sorts elements [0,high). Calling java.util.Arrays isn't always the right     * choice since it always creates an internal copy of the array, even if it     * doesn't need to. If the array slice is small enough, an insertion sort     * is chosen instead, but it doesn't need a copy!     * <p>     * This method has a modified version of that insertion sort, except it     * doesn't create an unnecessary array copy. If high is over 10, then     * java.util.Arrays is called, which will perform a merge sort, which is     * faster than insertion sort on large lists.     * <p>     * The end result is much greater performance when computeMillis is called.     * Since the amount of saved fields is small, the insertion sort is a     * better choice. Additional performance is gained since there is no extra     * array allocation and copying. Also, the insertion sort here does not     * perform any casting operations. The version in java.util.Arrays performs     * casts within the insertion sort loop.     */
/**         * The field with the longer range duration is ordered first, where         * null is considered infinite. If the ranges match, then the field         * with the longer duration is ordered first.         */
/**     * Converts an integer to a string, prepended with a variable amount of '0'     * pad characters, and appends it to the given buffer.     *     * <p>This method is optimized for converting small values to strings.     *     * @param buf receives integer converted to a string     * @param value value to convert to a string     * @param size minumum amount of digits to append     */
/**     * Converts an integer to a string, prepended with a variable amount of '0'     * pad characters, and writes it to the given writer.     *     * <p>This method is optimized for converting small values to strings.     *     * @param out receives integer converted to a string     * @param value value to convert to a string     * @param size minumum amount of digits to append     */
/**     * Converts an integer to a string, and appends it to the given buffer.     *     * <p>This method is optimized for converting small values to strings.     *     * @param buf receives integer converted to a string     * @param value value to convert to a string     */
/**     * Converts an integer to a string, and writes it to the given writer.     *     * <p>This method is optimized for converting small values to strings.     *     * @param out receives integer converted to a string     * @param value value to convert to a string     */
/**     * Calculates the number of decimal digits for the given value,     * including the sign.     */
/**     * Returns a formatter that outputs only those fields specified.     * <p>     * This method examines the fields provided and returns an ISO-style     * formatter that best fits. This can be useful for outputting     * less-common ISO styles, such as YearMonth (YYYY-MM) or MonthDay (--MM-DD).     * <p>     * The list provided may have overlapping fields, such as dayOfWeek and     * dayOfMonth. In this case, the style is chosen based on the following     * list, thus in the example, the calendar style is chosen as dayOfMonth     * is higher in priority than dayOfWeek:     * <ul>     * <li>monthOfYear - calendar date style     * <li>dayOfYear - ordinal date style     * <li>weekOfWeekYear - week date style     * <li>dayOfMonth - calendar date style     * <li>dayOfWeek - week date style     * <li>year     * <li>weekyear     * </ul>     * The supported formats are:     * <pre>     * Extended      Basic       Fields     * 2005-03-25    20050325    year/monthOfYear/dayOfMonth     * 2005-03       2005-03     year/monthOfYear     * 2005--25      2005--25    year/dayOfMonth *     * 2005          2005        year     * --03-25       --0325      monthOfYear/dayOfMonth     * --03          --03        monthOfYear     * ---03         ---03       dayOfMonth     * 2005-084      2005084     year/dayOfYear     * -084          -084        dayOfYear     * 2005-W12-5    2005W125    weekyear/weekOfWeekyear/dayOfWeek     * 2005-W-5      2005W-5     weekyear/dayOfWeek *     * 2005-W12      2005W12     weekyear/weekOfWeekyear     * -W12-5        -W125       weekOfWeekyear/dayOfWeek     * -W12          -W12        weekOfWeekyear     * -W-5          -W-5        dayOfWeek     * 10:20:30.040  102030.040  hour/minute/second/milli     * 10:20:30      102030      hour/minute/second     * 10:20         1020        hour/minute     * 10            10          hour     * -20:30.040    -2030.040   minute/second/milli     * -20:30        -2030       minute/second     * -20           -20         minute     * --30.040      --30.040    second/milli     * --30          --30        second     * ---.040       ---.040     milli *     * 10-30.040     10-30.040   hour/second/milli *     * 10:20-.040    1020-.040   hour/minute/milli *     * 10-30         10-30       hour/second *     * 10--.040      10--.040    hour/milli *     * -20-.040      -20-.040    minute/milli *     *   plus datetime formats like {date}T{time}     * </pre>     * * indiates that this is not an official ISO format and can be excluded     * by passing in <code>strictISO</code> as <code>true</code>.     * <p>     * This method can side effect the input collection of fields.     * If the input collection is modifiable, then each field that was added to     * the formatter will be removed from the collection, including any duplicates.     * If the input collection is unmodifiable then no side effect occurs.     * <p>     * This side effect processing is useful if you need to know whether all     * the fields were converted into the formatter or not. To achieve this,     * pass in a modifiable list, and check that it is empty on exit.     *     * @param fields  the fields to get a formatter for, not null,     *  updated by the method call unless unmodifiable,     *  removing those fields built in the formatter     * @param extended  true to use the extended format (with separators)     * @param strictISO  true to stick exactly to ISO8601, false to include additional formats     * @return a suitable formatter     * @throws IllegalArgumentException if there is no format for the fields     * @since 1.1     */
/**     * Creates a date using the calendar date format.     * Specification reference: 5.2.1.     *     * @param bld  the builder     * @param fields  the fields     * @param extended  true to use extended format     * @param strictISO  true to only allow ISO formats     * @return true if reduced precision     * @since 1.1     */
/**     * Creates a date using the ordinal date format.     * Specification reference: 5.2.2.     *     * @param bld  the builder     * @param fields  the fields     * @param extended  true to use extended format     * @param strictISO  true to only allow ISO formats     * @since 1.1     */
/**     * Creates a date using the calendar date format.     * Specification reference: 5.2.3.     *     * @param bld  the builder     * @param fields  the fields     * @param extended  true to use extended format     * @param strictISO  true to only allow ISO formats     * @since 1.1     */
/**     * Checks that the iso only flag is not set, throwing an exception if it is.     *      * @param fields  the fields     * @param strictISO  true if only ISO formats allowed     * @since 1.1     */
/**     * Appends the separator if necessary.     *     * @param bld  the builder     * @param extended  whether to append the separator     * @param sep  the separator     * @since 1.1     */
/**     * Returns a formatter for a full date as four digit year, two digit month     * of year, and two digit day of month (yyyy-MM-dd).     *      * @return a formatter for yyyy-MM-dd     */
/**     * Returns a formatter for a full date as four digit weekyear, two digit     * week of weekyear, and one digit day of week (xxxx-'W'ww-e).     *      * @return a formatter for xxxx-'W'ww-e     */
/**     * Returns a formatter for a four digit year. (yyyy)     *      * @return a formatter for yyyy     */
/**     * Returns a formatter for a four digit weekyear. (xxxx)     *      * @return a formatter for xxxx     */
/**     * Returns a formatter for a two digit hour of day. (HH)     *      * @return a formatter for HH     */
/**     * The standard ISO format - PyYmMwWdDThHmMsS.     * Milliseconds are not output.     * Note that the ISO8601 standard actually indicates weeks should not     * be shown if any other field is present and vice versa.     *      * @return the formatter     */
/**     * The alternate ISO format, PyyyymmddThhmmss, which excludes weeks.     * <p>     * Even if weeks are present in the period, they are not output.     * Fractional seconds (milliseconds) will appear if required.     *      * @return the formatter     */
/**     * The alternate ISO format, Pyyyy-mm-ddThh:mm:ss, which excludes weeks.     * <p>     * Even if weeks are present in the period, they are not output.     * Fractional seconds (milliseconds) will appear if required.     *      * @return the formatter     */
/**     * The alternate ISO format, PyyyyWwwddThhmmss, which excludes months.     * <p>     * Even if months are present in the period, they are not output.     * Fractional seconds (milliseconds) will appear if required.     *      * @return the formatter     */
/**     * The alternate ISO format, Pyyyy-Www-ddThh:mm:ss, which excludes months.     * <p>     * Even if months are present in the period, they are not output.     * Fractional seconds (milliseconds) will appear if required.     *      * @return the formatter     */
/**     * Gets the default formatter that outputs words in English.     * <p>     * This calls {@link #wordBased(Locale)} using a locale of {@code ENGLISH}.     *      * @return the formatter, not null     */
/**     * Returns a word based formatter for the specified locale.     * <p>     * The words are configured in a resource bundle text file -     * {@code org.joda.time.format.messages}.     * This can be added to via the normal classpath resource bundle mechanisms.     * <p>     * Available languages are English, Danish, Dutch, French, German, Japanese, Portuguese, and Spanish.     *      * @return the formatter, not null     * @since 2.0     */
/**     * Returns a new formatter with a different locale that will be used     * for printing and parsing.     * <p>     * A PeriodFormatter is immutable, so a new instance is returned,     * and the original is unaltered and still usable.     *      * @param locale  the locale to use     * @return the new formatter     */
/**     * Returns a new formatter with a different PeriodType for parsing.     * <p>     * A PeriodFormatter is immutable, so a new instance is returned,     * and the original is unaltered and still usable.     *      * @param type  the type to use in parsing     * @return the new formatter     */
/**     * Gets the internal printer object that performs the real printing work.     *      * @return the internal printer     */
/**     * Gets the internal parser object that performs the real parsing work.     *      * @return the internal parser     */
/**     * Returns a new formatter with a different locale that will be used     * for printing and parsing.     * <p>     * A PeriodFormatter is immutable, so a new instance is returned,     * and the original is unaltered and still usable.     *      * @param locale  the locale to use     * @return the new formatter     */
/**     * Gets the locale that will be used for printing and parsing.     *      * @return the locale to use     */
/**     * Returns a new formatter with a different PeriodType for parsing.     * <p>     * A PeriodFormatter is immutable, so a new instance is returned,     * and the original is unaltered and still usable.     *      * @param type  the type to use in parsing     * @return the new formatter     */
/**     * Gets the PeriodType that will be used for parsing.     *      * @return the parse type to use     */
/**     * Prints a ReadablePeriod to a Writer.     *     * @param out  the formatted period is written out     * @param period  the period to format, not null     */
/**     * Prints a ReadablePeriod to a new String.     *     * @param period  the period to format, not null     * @return the printed result     */
/**     * Checks whether printing is supported.     *      * @throws UnsupportedOperationException if printing is not supported     */
/**     * Checks whether the period is non-null.     *      * @throws IllegalArgumentException if the period is null     */
/**     * Parses a period from the given text, at the given position, saving the     * result into the fields of the given ReadWritablePeriod. If the parse     * succeeds, the return value is the new text position. Note that the parse     * may succeed without fully reading the text.     * <p>     * The parse type of the formatter is not used by this method.     * <p>     * If it fails, the return value is negative, but the period may still be     * modified. To determine the position where the parse failed, apply the     * one's complement operator (~) on the return value.     *     * @param period  a period that will be modified     * @param text  text to parse     * @param position position to start parsing from     * @return new position, if negative, parse failed. Apply complement     * operator (~) to get position of failure     * @throws IllegalArgumentException if any field is out of range     */
/**     * Parses a period from the given text, returning a new Period.     *     * @param text  text to parse     * @return parsed value in a Period object     * @throws IllegalArgumentException if any field is out of range     */
/**     * Parses a period from the given text, returning a new MutablePeriod.     *     * @param text  text to parse     * @return parsed value in a MutablePeriod object     * @throws IllegalArgumentException if any field is out of range     */
/**     * Checks whether parsing is supported.     *      * @throws UnsupportedOperationException if parsing is not supported     */
/**     * Appends another formatter.     *     * @return this PeriodFormatterBuilder     */
/**     * Appends a printer parser pair.     * <p>     * Either the printer or the parser may be null, in which case the builder will     * be unable to produce a parser or printer repectively.     *     * @param printer  appends a printer to the builder, null if printing is not supported     * @param parser  appends a parser to the builder, null if parsing is not supported     * @return this PeriodFormatterBuilder     * @throws IllegalArgumentException if both the printer and parser are null     */
/**     * Instructs the printer to emit specific text, and the parser to expect it.     * The parser is case-insensitive.     *     * @return this PeriodFormatterBuilder     * @throws IllegalArgumentException if text is null     */
/**     * Set the minimum digits printed for the next and following appended     * fields. By default, the minimum digits printed is one. If the field value     * is zero, it is not printed unless a printZero rule is applied.     *     * @return this PeriodFormatterBuilder     */
/**     * Set the maximum digits parsed for the next and following appended     * fields. By default, the maximum digits parsed is ten.     *     * @return this PeriodFormatterBuilder     */
/**     * Reject signed values when parsing the next and following appended fields.     *     * @return this PeriodFormatterBuilder     */
/**     * Never print zero values for the next and following appended fields,     * unless no fields would be printed. If no fields are printed, the printer     * forces the last "printZeroRarely" field to print a zero.     * <p>     * This field setting is the default.     *     * @return this PeriodFormatterBuilder     */
/**     * Never print zero values for the next and following appended fields,     * unless no fields would be printed. If no fields are printed, the printer     * forces the first "printZeroRarely" field to print a zero.     *     * @return this PeriodFormatterBuilder     */
/**     * Print zero values for the next and following appened fields only if the     * period supports it.     *     * @return this PeriodFormatterBuilder     */
/**     * Always print zero values for the next and following appended fields,     * even if the period doesn't support it. The parser requires values for     * fields that always print zero.     *     * @return this PeriodFormatterBuilder     */
/**     * Never print zero values for the next and following appended fields,     * unless no fields would be printed. If no fields are printed, the printer     * forces the last "printZeroRarely" field to print a zero.     * <p>     * This field setting is the default.     *     * @return this PeriodFormatterBuilder     */
/**     * Append a field prefix which applies only to the next appended field. If     * the field is not printed, neither is the prefix.     *     * @param text text to print before field only if field is printed     * @return this PeriodFormatterBuilder     * @see #appendSuffix     */
/**     * Append a field prefix which applies only to the next appended field. If     * the field is not printed, neither is the prefix.     * <p>     * During parsing, the singular and plural versions are accepted whether     * or not the actual value matches plurality.     *     * @param singularText text to print if field value is one     * @param pluralText text to print if field value is not one     * @return this PeriodFormatterBuilder     * @see #appendSuffix     */
/**     * Instruct the printer to emit an integer years field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer months field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer weeks field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer days field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer hours field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer minutes field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer seconds field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit a combined seconds and millis field, if supported.     * The millis will overflow into the seconds if necessary.     * The millis are always output.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit a combined seconds and millis field, if supported.     * The millis will overflow into the seconds if necessary.     * The millis are only output if non-zero.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer millis field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer millis field, if supported.     * <p>     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Append a field suffix which applies only to the last appended field. If     * the field is not printed, neither is the suffix.     *     * @param text text to print after field only if field is printed     * @return this PeriodFormatterBuilder     * @throws IllegalStateException if no field exists to append to     * @see #appendPrefix     */
/**     * Append a field suffix which applies only to the last appended field. If     * the field is not printed, neither is the suffix.     * <p>     * During parsing, the singular and plural versions are accepted whether or     * not the actual value matches plurality.     *     * @param singularText text to print if field value is one     * @param pluralText text to print if field value is not one     * @return this PeriodFormatterBuilder     * @throws IllegalStateException if no field exists to append to     * @see #appendPrefix     */
/**     * Append a separator, which is output if fields are printed both before     * and after the separator.     * <p>     * For example, <code>builder.appendDays().appendSeparator(",").appendHours()</code>     * will only output the comma if both the days and hours fields are output.     * <p>     * The text will be parsed case-insensitively.     * <p>     * Note: appending a separator discontinues any further work on the latest     * appended field.     *     * @param text  the text to use as a separator     * @return this PeriodFormatterBuilder     * @throws IllegalStateException if this separator follows a previous one     */
/**     * Append a separator, which is output only if fields are printed after the separator.     * <p>     * For example,     * <code>builder.appendDays().appendSeparatorIfFieldsAfter(",").appendHours()</code>     * will only output the comma if the hours fields is output.     * <p>     * The text will be parsed case-insensitively.     * <p>     * Note: appending a separator discontinues any further work on the latest     * appended field.     *     * @param text  the text to use as a separator     * @return this PeriodFormatterBuilder     * @throws IllegalStateException if this separator follows a previous one     */
/**     * Append a separator, which is output only if fields are printed before the separator.     * <p>     * For example,     * <code>builder.appendDays().appendSeparatorIfFieldsBefore(",").appendHours()</code>     * will only output the comma if the days fields is output.     * <p>     * The text will be parsed case-insensitively.     * <p>     * Note: appending a separator discontinues any further work on the latest     * appended field.     *     * @param text  the text to use as a separator     * @return this PeriodFormatterBuilder     * @throws IllegalStateException if this separator follows a previous one     */
/**     * Append a separator, which is output if fields are printed both before     * and after the separator.     * <p>     * This method changes the separator depending on whether it is the last separator     * to be output.     * <p>     * For example, <code>builder.appendDays().appendSeparator(",", "&").appendHours().appendSeparator(",", "&").appendMinutes()</code>     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output     * and '1' if just one field is output.     * <p>     * The text will be parsed case-insensitively.     * <p>     * Note: appending a separator discontinues any further work on the latest     * appended field.     *     * @param text  the text to use as a separator     * @param finalText  the text used used if this is the final separator to be printed     * @return this PeriodFormatterBuilder     * @throws IllegalStateException if this separator follows a previous one     */
/**     * Append a separator, which is output if fields are printed both before     * and after the separator.     * <p>     * This method changes the separator depending on whether it is the last separator     * to be output.     * <p>     * For example, <code>builder.appendDays().appendSeparator(",", "&").appendHours().appendSeparator(",", "&").appendMinutes()</code>     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output     * and '1' if just one field is output.     * <p>     * The text will be parsed case-insensitively.     * <p>     * Note: appending a separator discontinues any further work on the latest     * appended field.     *     * @param text  the text to use as a separator     * @param finalText  the text used used if this is the final separator to be printed     * @return this PeriodFormatterBuilder     * @throws IllegalStateException if this separator follows a previous one     */
/**     * Internal method to create a PeriodPrinter instance using all the     * appended elements.     * <p>     * Most applications will not use this method.     * If you want a printer in an application, call {@link #toFormatter()}     * and just use the printing API.     * <p>     * Subsequent changes to this builder do not affect the returned printer.     *      * @return the newly created printer, null if builder cannot create a printer     */
/**     * Internal method to create a PeriodParser instance using all the     * appended elements.     * <p>     * Most applications will not use this method.     * If you want a printer in an application, call {@link #toFormatter()}     * and just use the printing API.     * <p>     * Subsequent changes to this builder do not affect the returned parser.     *      * @return the newly created parser, null if builder cannot create a parser     */
/**     * Clears out all the appended elements, allowing this builder to be reused.     */
/**     * Appends a printer parser pair.     * <p>     * Either the printer or the parser may be null, in which case the builder will     * be unable to produce a parser or printer repectively.     *     * @param printer  appends a printer to the builder, null if printing is not supported     * @param parser  appends a parser to the builder, null if parsing is not supported     * @return this PeriodFormatterBuilder     * @throws IllegalArgumentException if both the printer and parser are null     */
/**     * Instructs the printer to emit specific text, and the parser to expect it.     * The parser is case-insensitive.     *     * @return this PeriodFormatterBuilder     * @throws IllegalArgumentException if text is null     */
/**     * Set the minimum digits printed for the next and following appended     * fields. By default, the minimum digits printed is one. If the field value     * is zero, it is not printed unless a printZero rule is applied.     *     * @return this PeriodFormatterBuilder     */
/**     * Set the maximum digits parsed for the next and following appended     * fields. By default, the maximum digits parsed is ten.     *     * @return this PeriodFormatterBuilder     */
/**     * Reject signed values when parsing the next and following appended fields.     *     * @return this PeriodFormatterBuilder     */
/**     * Never print zero values for the next and following appended fields,     * unless no fields would be printed. If no fields are printed, the printer     * forces the last "printZeroRarely" field to print a zero.     * <p>     * This field setting is the default.     *     * @return this PeriodFormatterBuilder     */
/**     * Never print zero values for the next and following appended fields,     * unless no fields would be printed. If no fields are printed, the printer     * forces the first "printZeroRarely" field to print a zero.     *     * @return this PeriodFormatterBuilder     */
/**     * Print zero values for the next and following appened fields only if the     * period supports it.     *     * @return this PeriodFormatterBuilder     */
/**     * Always print zero values for the next and following appended fields,     * even if the period doesn't support it. The parser requires values for     * fields that always print zero.     *     * @return this PeriodFormatterBuilder     */
/**     * Never print zero values for the next and following appended fields,     * unless no fields would be printed. If no fields are printed, the printer     * forces the last "printZeroRarely" field to print a zero.     * <p>     * This field setting is the default.     *     * @return this PeriodFormatterBuilder     */
/**     * Append a field prefix which applies only to the next appended field. If     * the field is not printed, neither is the prefix.     *     * @param prefix custom prefix     * @return this PeriodFormatterBuilder     * @see #appendSuffix     */
/**     * Instruct the printer to emit an integer years field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer months field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer weeks field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer days field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer hours field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer minutes field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer seconds field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit a combined seconds and millis field, if supported.     * The millis will overflow into the seconds if necessary.     * The millis are always output.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit a combined seconds and millis field, if supported.     * The millis will overflow into the seconds if necessary.     * The millis are only output if non-zero.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer millis field, if supported.     * <p>     * The number of printed and parsed digits can be controlled using     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Instruct the printer to emit an integer millis field, if supported.     * <p>     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.     *     * @return this PeriodFormatterBuilder     */
/**     * Append a field suffix which applies only to the last appended field. If     * the field is not printed, neither is the suffix.     *     * @param suffix custom suffix     * @return this PeriodFormatterBuilder     * @throws IllegalStateException if no field exists to append to     * @see #appendPrefix     */
/**     * Append a separator, which is output only if fields are printed after the separator.     * <p>     * For example,     * <code>builder.appendDays().appendSeparatorIfFieldsAfter(",").appendHours()</code>     * will only output the comma if the hours fields is output.     * <p>     * The text will be parsed case-insensitively.     * <p>     * Note: appending a separator discontinues any further work on the latest     * appended field.     *     * @param text  the text to use as a separator     * @return this PeriodFormatterBuilder     * @throws IllegalStateException if this separator follows a previous one     */
/**     * Append a separator, which is output only if fields are printed before the separator.     * <p>     * For example,     * <code>builder.appendDays().appendSeparatorIfFieldsBefore(",").appendHours()</code>     * will only output the comma if the days fields is output.     * <p>     * The text will be parsed case-insensitively.     * <p>     * Note: appending a separator discontinues any further work on the latest     * appended field.     *     * @param text  the text to use as a separator     * @return this PeriodFormatterBuilder     * @throws IllegalStateException if this separator follows a previous one     */
/**         * @param text text to parse         * @param position position in text         * @param length exact count of characters to parse         * @return parsed int value         */
/**         * @return Long.MAX_VALUE if nothing to print, otherwise value         */
/**     * Returns a new CachedDateTimeZone unless given zone is already cached.     */
/**     * Returns the DateTimeZone being wrapped.     */
/**     * Adds a cutover for added rules. The standard offset at the cutover     * defaults to 0. Call setStandardOffset afterwards to change it.     *     * @param year  the year of cutover     * @param mode 'u' - cutover is measured against UTC, 'w' - against wall     *  offset, 's' - against standard offset     * @param monthOfYear  the month from 1 (January) to 12 (December)     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).     *  For example, if -1, set to last day of month     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to     *  dayOfWeek when true, retreat when false.     * @param millisOfDay  additional precision for specifying time of day of cutover     */
/**     * Sets the standard offset to use for newly added rules until the next     * cutover is added.     * @param standardOffset  the standard offset in millis     */
/**     * Set a fixed savings rule at the cutover.     */
/**     * Add a recurring daylight saving time rule.     *     * @param nameKey  the name key of new rule     * @param saveMillis  the milliseconds to add to standard offset     * @param fromYear  the first year that rule is in effect, MIN_VALUE indicates     * beginning of time     * @param toYear  the last year (inclusive) that rule is in effect, MAX_VALUE     *  indicates end of time     * @param mode  'u' - transitions are calculated against UTC, 'w' -     *  transitions are calculated against wall offset, 's' - transitions are     *  calculated against standard offset     * @param monthOfYear  the month from 1 (January) to 12 (December)     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).     *  For example, if -1, set to last day of month     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to     *  dayOfWeek when true, retreat when false.     * @param millisOfDay  additional precision for specifying time of day of transitions     */
/**     * Millisecond encoding formats:     *     * upper two bits  units       field length  approximate range     * ---------------------------------------------------------------     * 00              30 minutes  1 byte        +/- 16 hours     * 01              minutes     4 bytes       +/- 1020 years     * 10              seconds     5 bytes       +/- 4355 years     * 11              millis      9 bytes       +/- 292,000,000 years     *     * Remaining bits in field form signed offset from 1970-01-01T00:00:00Z.     */
/**     * Reads encoding generated by writeMillis.     */
/**     * Adds a cutover for added rules. The standard offset at the cutover     * defaults to 0. Call setStandardOffset afterwards to change it.     *     * @param year  the year of cutover     * @param mode 'u' - cutover is measured against UTC, 'w' - against wall     *  offset, 's' - against standard offset     * @param monthOfYear  the month from 1 (January) to 12 (December)     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).     *  For example, if -1, set to last day of month     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to     *  dayOfWeek when true, retreat when false.     * @param millisOfDay  additional precision for specifying time of day of cutover     */
/**     * Add a recurring daylight saving time rule.     *     * @param nameKey  the name key of new rule     * @param saveMillis  the milliseconds to add to standard offset     * @param fromYear  the first year that rule is in effect, MIN_VALUE indicates     * beginning of time     * @param toYear  the last year (inclusive) that rule is in effect, MAX_VALUE     *  indicates end of time     * @param mode  'u' - transitions are calculated against UTC, 'w' -     *  transitions are calculated against wall offset, 's' - transitions are     *  calculated against standard offset     * @param monthOfYear  the month from 1 (January) to 12 (December)     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).     *  For example, if -1, set to last day of month     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to     *  dayOfWeek when true, retreat when false.     * @param millisOfDay  additional precision for specifying time of day of transitions     */
/**     * Processes all the rules and builds a DateTimeZone.     *     * @param id  time zone id to assign     * @param outputID  true if the zone id should be output     */
/**         * @param standardOffset standard offset just before instant         */
/**         * @param standardOffset standard offset just before previous recurrence         */
/**         * If month-day is 02-29 and year isn't leap, advances to next leap year.         */
/**         * If month-day is 02-29 and year isn't leap, retreats to previous leap year.         */
/**         * There must be a change in the millis, wall offsets or name keys.         */
/**         * Returns a transition at firstMillis with the first name key and         * offsets for this rule set. This method may return null.         *         * @param firstMillis millis of first transition         */
/**         * @param saveMillis savings before upper limit         */
/**         * Returns null if none can be built.         */
/**         * Factory to create instance from builder.         *          * @param id  the zone id         * @param outputID  true if the zone id should be output         * @param transitions  the list of Transition objects         * @param tailZone  optional zone for getting info beyond precalculated tables         */
/**     * Override to return the correct timzone instance.     * @since 1.5     */
/**     * Constructor.     */
/**     * Returns {@link DateTimeZone#UTC UTC} for <code>"UTC"</code>, null     * otherwise.     */
/**     * Returns a singleton collection containing only <code>"UTC"</code>.     */
/**     * Gets a flag indicating that verbose logging is required.     * @return true to log verbosely     */
/**     * Launches the ZoneInfoCompiler tool.     *     * <pre>     * Usage: java org.joda.time.tz.ZoneInfoCompiler &lt;options&gt; &lt;source files&gt;     * where possible options include:     *   -src &lt;directory&gt;    Specify where to read source files     *   -dst &lt;directory&gt;    Specify where to write generated files     *   -verbose            Output verbosely (default false)     * </pre>     */
/**     * @param zimap maps string ids to DateTimeZone objects.     */
/**     * @return false if error.     */
/**     * Returns a map of ids to DateTimeZones.     *     * @param outputDir optional directory to write compiled data files to     * @param sources optional list of source files to parse     */
/**         * Adds a recurring savings rule to the builder.         */
/**         * Adds a cutover to the builder.         */
/**     * ZoneInfoProvider searches the given directory for compiled data files.     *     * @throws IOException if directory or map file cannot be read     */
/**     * ZoneInfoProvider searches the given ClassLoader resource path for     * compiled data files. Resources are loaded from the ClassLoader that     * loaded this class.     *     * @throws IOException if directory or map file cannot be read     */
/**     * ZoneInfoProvider searches the given ClassLoader resource path for     * compiled data files.     *     * @param loader ClassLoader to load compiled data files from. If null,     * use system ClassLoader.     * @throws IOException if directory or map file cannot be read     */
/**     * If an error is thrown while loading zone data, uncaughtException is     * called to log the error and null is returned for this and all future     * requests.     *      * @param id  the id to load     * @return the loaded zone     */
/**     * Gets a list of all the available zone ids.     *      * @return the zone ids     */
/**     * Called if an exception is thrown from getZone while loading zone data.     *      * @param ex  the exception     */
/**     * Loads the time zone data for one id.     *      * @param id  the id to load     * @return the zone     */
/**     * Loads the zone info map.     *      * @param in  the input stream     * @return the map     */
/**     * Reads the zone info map from file.     *      * @param din  the input stream     * @param zimap  gets filled with string id to string id mappings     */
/**     * Test now ()     */
/**     * Test now (DateTimeZone)     */
/**     * Test now (DateTimeZone=null)     */
/**     * Test now (Chronology)     */
/**     * Test now (Chronology=null)     */
/**     * Test constructor ()     */
/**     * Test constructor (DateTimeZone)     */
/**     * Test constructor (DateTimeZone=null)     */
/**     * Test constructor (Chronology)     */
/**     * Test constructor (Chronology=null)     */
/**     * Test constructor (long)     */
/**     * Test constructor (long)     */
/**     * Test constructor (long, DateTimeZone)     */
/**     * Test constructor (long, DateTimeZone)     */
/**     * Test constructor (long, DateTimeZone=null)     */
/**     * Test constructor (long, Chronology)     */
/**     * Test constructor (long, Chronology)     */
/**     * Test constructor (long, Chronology=null)     */
/**     * Test constructor (Object)     */
/**     * Test constructor (Object)     */
/**     * Test constructor (Object=null)     */
/**     * Test constructor (Object=null)     */
/**     * Test constructor (Object, DateTimeZone)     */
/**     * Test constructor (Object, DateTimeZone)     */
/**     * Test constructor (Object=null, DateTimeZone)     */
/**     * Test constructor (Object, DateTimeZone=null)     */
/**     * Test constructor (Object=null, DateTimeZone=null)     */
/**     * Test constructor (Object, DateTimeZone)     */
/**     * Test constructor (Object, Chronology)     */
/**     * Test constructor (Object, Chronology)     */
/**     * Test constructor (Object=null, Chronology)     */
/**     * Test constructor (Object, Chronology=null)     */
/**     * Test constructor (Object=null, Chronology=null)     */
/**     * Test constructor (Object, Chronology)     */
/**     * Test constructor (int, int, int)     */
/**     * Test constructor (int, int, int, DateTimeZone)     */
/**     * Test constructor (int, int, int, DateTimeZone=null)     */
/**     * Test constructor (int, int, int, Chronology)     */
/**     * Test constructor (int, int, int, Chronology=null)     */
/**     * Test all basic comparator operation with DateTime objects.     */
/**     * Test all basic comparator operation with ReadableInstant objects.     */
/**     * Test all basic comparator operation with java Date objects.     */
/**     * Test all basic comparator operation with Long objects.     */
/**     * Test all basic comparator operation with Calendar objects.     */
/**     * Test unequal comparisons with millis of second comparators.     */
/**     * Test unequal comparisons with second comparators.     */
/**     * Test unequal comparisons with minute comparators.     */
/**     * Test unequal comparisons with hour comparators.     */
/**     * Test unequal comparisons with day of week comparators.     */
/**     * Test unequal comparisons with day of month comparators.     */
/**     * Test unequal comparisons with day of year comparators.     */
/**     * Test unequal comparisons with week of weekyear comparators.     */
/**     * Test unequal comparisons with year given the week comparators.     */
/**     * Test unequal comparisons with month comparators.     */
/**     * Test unequal comparisons with year comparators.     */
/**      * Test sorting with full default comparator.      */
/**      * Test sorting with millis of second comparator.      */
/**      * Test sorting with second comparator.      */
/**      * Test sorting with minute comparator.      */
/**      * Test sorting with hour comparator.      */
/**      * Test sorting with day of week comparator.      */
/**      * Test sorting with day of month comparator.      */
/**      * Test sorting with day of year comparator.      */
/**      * Test sorting with week of weekyear comparator.      */
/**      * Test sorting with year (given week) comparator.      */
/**      * Test sorting with month comparator.      */
/**      * Test sorting with year comparator.      */
/**      * Test sorting with date only comparator.      */
/**      * Test sorting with time only comparator.      */
/**     * Test comparator operation with null object(s).     */
/**     * Test comparator operation with an invalid object type.     */
/**     * Creates a date to test with.     */
/**     * Load a string array.     */
/**     * Check if the list is sorted.     */
/**     * TestDateTimeComparator constructor.     * @param name     */
/**     * The main method for this test program.     * @param args command line arguments.     */
/**     * TestSuite is a junit required method.     */
/**     * Test now ()     */
/**     * Test now (DateTimeZone)     */
/**     * Test now (DateTimeZone=null)     */
/**     * Test now (Chronology)     */
/**     * Test now (Chronology=null)     */
/**     * Test constructor ()     */
/**     * Test constructor (DateTimeZone)     */
/**     * Test constructor (DateTimeZone=null)     */
/**     * Test constructor (Chronology)     */
/**     * Test constructor (Chronology=null)     */
/**     * Test constructor (long)     */
/**     * Test constructor (long)     */
/**     * Test constructor (long, DateTimeZone)     */
/**     * Test constructor (long, DateTimeZone)     */
/**     * Test constructor (long, DateTimeZone=null)     */
/**     * Test constructor (long, Chronology)     */
/**     * Test constructor (long, Chronology)     */
/**     * Test constructor (long, Chronology=null)     */
/**     * Test constructor (Object)     */
/**     * Test constructor (Object)     */
/**     * Test constructor (Object=null)     */
/**     * Test constructor (Object=null)     */
/**     * Test constructor (Object, DateTimeZone)     */
/**     * Test constructor (Object, DateTimeZone)     */
/**     * Test constructor (Object=null, DateTimeZone)     */
/**     * Test constructor (Object, DateTimeZone=null)     */
/**     * Test constructor (Object=null, DateTimeZone=null)     */
/**     * Test constructor (Object, DateTimeZone)     */
/**     * Test constructor (Object, Chronology)     */
/**     * Test constructor (Object, Chronology)     */
/**     * Test constructor (Object=null, Chronology)     */
/**     * Test constructor (Object, Chronology=null)     */
/**     * Test constructor (Object=null, Chronology=null)     */
/**     * Test constructor (Object, Chronology)     */
/**     * Test constructor (int, int, int, int, int)     */
/**     * Test constructor (int, int, int, int, int, DateTimeZone)     */
/**     * Test constructor (int, int, int, int, int, DateTimeZone=null)     */
/**     * Test constructor (int, int, int, int, int, Chronology)     */
/**     * Test constructor (int, int, int, int, int, Chronology=null)     */
/**     * Test constructor (int, int, int, int, int, int)     */
/**     * Test constructor (int, int, int, int, int, int, DateTimeZone)     */
/**     * Test constructor (int, int, int, int, int, int, DateTimeZone=null)     */
/**     * Test constructor (int, int, int, int, int, int, Chronology)     */
/**     * Test constructor (int, int, int, int, int, int, Chronology=null)     */
/**     * Test constructor (int, int, int)     */
/**     * Test constructor (int, int, int, DateTimeZone)     */
/**     * Test constructor (int, int, int, DateTimeZone=null)     */
/**     * Test constructor (int, int, int, Chronology)     */
/**     * Test constructor (int, int, int, Chronology=null)     */
/**     * Test constructor ()     */
/**     * Test constructor (Object)     */
/**     * Test now ()     */
/**     * Test constructor ()     */
/**     * Test constructor (long)     */
/**     * Test constructor (long)     */
/**     * Test constructor (Object)     */
/**     * Test constructor (Object)     */
/**     * Test constructor (Object=null)     */
/**     * Test constructor (Object=null)     */
/**     * Test constructor ()     */
/**     * Test constructor ()     */
/**     * Test constructor (DateTimeZone)     */
/**     * Test constructor (DateTimeZone=null)     */
/**     * Test constructor (Chronology)     */
/**     * Test constructor (Chronology=null)     */
/**     * Test constructor (long)     */
/**     * Test constructor (long)     */
/**     * Test constructor (long, Chronology)     */
/**     * Test constructor (long, Chronology)     */
/**     * Test constructor (long, Chronology=null)     */
/**     * Test constructor (Object, Chronology)     */
/**     * Test constructor (Object=null, Chronology)     */
/**     * Test constructor (Object, Chronology=null)     */
/**     * Test constructor (Object=null, Chronology=null)     */
/**     * Test constructor (int, int)     */
/**     * Test constructor (int, int, Chronology)     */
/**     * Test constructor (int, int, Chronology=null)     */
/**     * Test now ()     */
/**     * Test now (DateTimeZone)     */
/**     * Test now (DateTimeZone=null)     */
/**     * Test now (Chronology)     */
/**     * Test now (Chronology=null)     */
/**     * Test constructor ()     */
/**     * Test constructor (DateTimeZone)     */
/**     * Test constructor (DateTimeZone=null)     */
/**     * Test constructor (Chronology)     */
/**     * Test constructor (Chronology=null)     */
/**     * Test constructor (long)     */
/**     * Test constructor (long)     */
/**     * Test constructor (long, DateTimeZone)     */
/**     * Test constructor (long, DateTimeZone)     */
/**     * Test constructor (long, DateTimeZone=null)     */
/**     * Test constructor (long, Chronology)     */
/**     * Test constructor (long, Chronology)     */
/**     * Test constructor (long, Chronology=null)     */
/**     * Test constructor (Object)     */
/**     * Test constructor (Object)     */
/**     * Test constructor (Object=null)     */
/**     * Test constructor (Object=null)     */
/**     * Test constructor (Object, DateTimeZone)     */
/**     * Test constructor (Object, DateTimeZone)     */
/**     * Test constructor (Object=null, DateTimeZone)     */
/**     * Test constructor (Object, DateTimeZone=null)     */
/**     * Test constructor (Object=null, DateTimeZone=null)     */
/**     * Test constructor (Object, DateTimeZone)     */
/**     * Test constructor (Object, Chronology)     */
/**     * Test constructor (Object, Chronology)     */
/**     * Test constructor (Object=null, Chronology)     */
/**     * Test constructor (Object, Chronology=null)     */
/**     * Test constructor (Object=null, Chronology=null)     */
/**     * Test constructor (Object, Chronology)     */
/**     * Test constructor (int, int, int)     */
/**     * Test constructor (int, int, int, DateTimeZone)     */
/**     * Test constructor (int, int, int, DateTimeZone=null)     */
/**     * Test constructor (int, int, int, Chronology)     */
/**     * Test constructor (int, int, int, Chronology=null)     */
/**     * Test constructor ()     */
/**     * Test constructor (PeriodType)     */
/**     * Test constructor (4ints)     */
/**     * Test constructor (8ints)     */
/**     * Test constructor (8ints)     */
/**     * Test constructor (Object)     */
/**     * Test constructor (Object,PeriodType)     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Test constructor     */
/**     * Checks if the exception message is valid.     *      * @param ex  the exception to check     * @param str1  the string to check     * @param str2  the string to check     */
/**     * Test constructor (4ints)     */
/**     * Test constructor (8ints)     */
/**     * Test constructor (8ints)     */
/**     * Test constructor (Object)     */
/**     * Test constructor (Object)     */
/**     * Test constructor ()     */
/**     * Test factory (long)     */
/**     * Test factory (long, Chronology)     */
/**     * Test factory (long, Chronology=null)     */
/**     * Test constructor ()     */
/**     * Test constructor (DateTimeZone)     */
/**     * Test constructor (DateTimeZone=null)     */
/**     * Test constructor (Chronology)     */
/**     * Test constructor (Chronology=null)     */
/**     * Test constructor (long)     */
/**     * Test constructor (long)     */
/**     * Test constructor (long, Chronology)     */
/**     * Test constructor (long, Chronology)     */
/**     * Test constructor (long, Chronology=null)     */
/**     * Test constructor (Object)     */
/**     * Test constructor (Object)     */
/**     * Test constructor (Object=null)     */
/**     * Test constructor (Object)     */
/**     * Test constructor (Object, Chronology)     */
/**     * Test constructor (Object, Chronology)     */
/**     * Test constructor (Object=null, Chronology)     */
/**     * Test constructor (Object, Chronology=null)     */
/**     * Test constructor (Object=null, Chronology=null)     */
/**     * Test constructor (int, int)     */
/**     * Test constructor (int, int, int, Chronology)     */
/**     * Test constructor (int, int, int, Chronology=null)     */
/**     * Test constructor (int, int, int)     */
/**     * Test constructor (int, int, int, Chronology)     */
/**     * Test constructor (int, int, int, Chronology=null)     */
/**     * Test constructor (int, int, int, int)     */
/**     * Test constructor (int, int, int, int, Chronology)     */
/**     * Test constructor (int, int, int, int, Chronology=null)     */
/**     * Test constructor ()     */
/**     * Test constructor (DateTimeZone)     */
/**     * Test constructor (DateTimeZone=null)     */
/**     * Test constructor (Chronology)     */
/**     * Test constructor (Chronology=null)     */
/**     * Test constructor (long)     */
/**     * Test constructor (long)     */
/**     * Test constructor (long, Chronology)     */
/**     * Test constructor (long, Chronology)     */
/**     * Test constructor (long, Chronology=null)     */
/**     * Test constructor (Object, Chronology)     */
/**     * Test constructor (Object=null, Chronology)     */
/**     * Test constructor (Object, Chronology=null)     */
/**     * Test constructor (Object=null, Chronology=null)     */
/**     * Test constructor (int, int, int)     */
/**     * Test constructor (int, int, int, Chronology)     */
/**     * Test constructor (int, int, int, Chronology=null)     */
/**     * Test constructor ()     */
/**     * Test constructor (DateTimeZone)     */
/**     * Test constructor (DateTimeZone=null)     */
/**     * Test constructor (Chronology)     */
/**     * Test constructor (Chronology=null)     */
/**     * Test constructor (long)     */
/**     * Test constructor (long)     */
/**     * Test constructor (long, Chronology)     */
/**     * Test constructor (long, Chronology)     */
/**     * Test constructor (long, Chronology=null)     */
/**     * Test constructor (Object, Chronology)     */
/**     * Test constructor (Object=null, Chronology)     */
/**     * Test constructor (Object, Chronology=null)     */
/**     * Test constructor (Object=null, Chronology=null)     */
/**     * Test constructor (int, int)     */
/**     * Test constructor (int, int, Chronology)     */
/**     * Test constructor (int, int, Chronology=null)     */
/**     * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.     */
/**     * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.     */
/**     * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.     */
/**     * @param iterations number of test iterations to perform     * @param mode GREGORIAN_MODE or JULIAN_MODE,0=Gregorian, 1=Julian     * @param seed seed for random number generator     */
/**     * Arguments: iterations [mode [seed]]     */
/**     * Main junit test     */
/**     * Divide with round-negative behavior.     *     * @param divisor must be positive     */
/**     * Modulus with round-negative behavior, result is always positive.     *     * @param divisor must be positive     */
/**     * Unsupported.     */
/**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */
/**     * @param millis milliseconds from epoch     * @return days from 0001-01-01     */
/**     * @param fixed days from 0001-01-01     * @return milliseconds from epoch     */
/**     * @return milliseconds from epoch     */
/**     * @param millis milliseconds from epoch     * @return gj year     */
/**     * @param millis milliseconds from epoch     * @return gj year, monthOfYear, dayOfMonth     */
/**     * @return milliseconds from epoch     */
/**     * @param millis milliseconds from epoch     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */
/**     * @param date days from 0001-01-01     * @param weekday 0=Sunday, 1=Monday, 2=Tuesday ... 6=Saturday, 7=Sunday     * @param date days from 0001-01-01, on or before weekday     */
/**     * Constructs with an epoch of 1970-01-01.     */
/**     * @return days from 0001-01-01     */
/**     * @param date days from 0001-01-01     * @return gj year     */
/**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */
/**     * @param date days from 0001-01-01     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */
/**     * Constructs with an epoch of 1969-12-19.     */
/**     * @return days from 0001-01-01     */
/**     * @param date days from 0001-01-01     * @return gj year     */
/**     * @param date days from 0001-01-01     * @return gj year, monthOfYear, dayOfMonth     */
/**     * @param date days from 0001-01-01     * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)     */
/**     * Passing null values into UnsupportedDateTimeField.getInstance() should     * throw an IllegalArguementsException     */
/**     *      * This test exercises the logic in UnsupportedDateTimeField.getInstance. If     * getInstance() is invoked twice with: - the same DateTimeFieldType -     * different duration fields     *      * Then the field returned in the first invocation should not be equal to     * the field returned by the second invocation. In otherwords, the generated     * instance should be the same for a unique pairing of     * DateTimeFieldType/DurationField     */
/**     * The getName() method should return the same value as the getName() method     * of the DateTimeFieldType that was used to create the instance.     *      */
/**     * As this is an unsupported date/time field, some normal methods will     * always return false, as they are not supported. Verify that each method     * correctly returns null.     */
/**     * According to the JavaDocs, there are two methods that should always     * return null. * getRangeDurationField() * getLeapDurationField()     *      * Ensure that these are in fact null.     */
/**     * As this is an unsupported date/time field, many normal methods are     * unsupported and throw an UnsupportedOperationException. Verify that each     * method correctly throws this exception. * add(ReadablePartial instant,     * int fieldIndex, int[] values, int valueToAdd) * addWrapField(long     * instant, int value) * addWrapField(ReadablePartial instant, int     * fieldIndex, int[] values, int valueToAdd) *     * addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int     * valueToAdd) * get(long instant) * getAsShortText(int fieldValue, Locale     * locale) * getAsShortText(long instant) * getAsShortText(long instant,     * Locale locale) * getAsShortText(ReadablePartial partial, int fieldValue,     * Locale locale) * getAsShortText(ReadablePartial partial, Locale locale) *     * getAsText(int fieldValue, Locale locale) * getAsText(long instant) *     * getAsText(long instant, Locale locale) * getAsText(ReadablePartial     * partial, int fieldValue, Locale locale) * getAsText(ReadablePartial     * partial, Locale locale) * getLeapAmount(long instant) *     * getMaximumShortTextLength(Locale locale) * getMaximumTextLength(Locale     * locale) * getMaximumValue() * getMaximumValue(long instant) *     * getMaximumValue(ReadablePartial instant) *     * getMaximumValue(ReadablePartial instant, int[] values) *     * getMinimumValue() * getMinimumValue(long instant) *     * getMinimumValue(ReadablePartial instant) *     * getMinimumValue(ReadablePartial instant, int[] values) * isLeap(long     * instant) * remainder(long instant) * roundCeiling(long instant) *     * roundFloor(long instant) * roundHalfCeiling(long instant) *     * roundHalfEven(long instant) * roundHalfFloor(long instant) * set(long     * instant, int value) * set(long instant, String text) * set(long instant,     * String text, Locale locale) * set(ReadablePartial instant, int     * fieldIndex, int[] values, int newValue) * set(ReadablePartial instant,     * int fieldIndex, int[] values, String text, Locale locale)     */
/**     * As this is an unsupported date/time field, many normal methods are     * unsupported. Some delegate and can possibly throw an     * UnsupportedOperationException or have a valid return. Verify that each     * method correctly throws this exception when appropriate and delegates     * correctly based on the Duration used to get the instance.     */
/**    * The toString method should return a suitable debug message (not null).    * Ensure that the toString method returns a string with length greater than    * 0 (and not null)    *     */
/** Make test compile on JDK 1.3. */
/**     * opretter dummy accounts     */
/**     * Constructor for objects of class LoanController     */
/**     * returnere et lan og tilfojer varen til productContaineren igen     * @param bar barcode     * @param serial serialNo     * @return String      */
/**     * kalder metoden addSupplier fra modellayer     * @return String     */
/**     * kalder metoden addSupplier fra modellayer     * @return String     */
/**     * laver en AccountContainer hvis en ikke eksistere og returnere den     * @return AccountContainer     */
/**     * henter en account pa phone og returnerer den     * @param String phone     * @return account      */
/**     * se costumerRecieveable i Account     */
/**     * returnerer et item og tjekker om det er afleveret for sent, hvis det      * laegger 500 til totalprice.     */
/**     * finder et lan og saetter status til betalt     * @param id pa lan      * @return String      */
/**     * finder et lan pa id     * @param id pa loan     * @return returnerer et lan objekt      */
/**     * returnere et item og aendrer status pa objekt     * @param id pa lan og serienummer pa et item     * @return returnere et item objekt     */
/**     * constructor til objekter af class MassProduct     */
/**     * tilfojer en order til orders hashmap     * @param Order order     */
/**     * Constructor for objects of class ProductMain     */
/**     * finder et produkt ved hjaelp af barcode or returnerer den     * @param int barcode      * @return Product      */
/**     * traekker amount fra et massProduct og returnerer massProduktet      * @param barcoden pa et produkt og maengden af det onskede produkt      * @return et massproduct objekt      */
/**     * Constructor til objekter af class SimpleLine     */
/**     * tilfojer en supplier til suppliers hashmap     * @param Supplier supplier     */
/**     * constructor til objekter af class UniqueLine     */
/**     * constructor til objekter af class UniqueProduct     */
/** * Sets the title over the image * * @param textOverImage */
/** * Sets the subtitle * @param subTitle */
/** * Initialize the MaterialLargeImageCardThumbnail * @return */
/** * Returns * the title over the image * @return */
/** * Sets the Resource Id to use for the title over the image * @param textOverImageResId */
/** * Returns the Resource Drawable ID * * @return */
/** * Sets the Resource Drawable ID * * @param drawableIdCardThumbnail */
/** * Returns the Drawable URL * @return */
/** * Sets the Drawable URL * * @param urlCardThumbnail */
/** * Sets the interface to be called with the thumbnail * @param externalCardThumbnail */
/** * Returns the subtitle * @return */
/* forming th java.net.URL object */
/* forming th java.net.URL object */
/* forming th java.net.URL object */
/* forming th java.net.URL object */
/* forming th java.net.URL object */
/**     * Create the test case     *     * @param testName name of the test case     */
/**     * @return the suite of tests being tested     */
/* send the request by POST method     * @param a url path     *   for the ehelp project, must provide the url path     *        like "http://120.24.208.130:1501/account/login..."     *        a String with json format     * @return a string that the server respond with json format     *    a string "false"/null indicate some errors happened     */
/* send a file(.jpg) to server by POST method * @params a url path *    a image file * @return a String "true" if upload successfully,0 *    "false" otherwise */
/*    * Test the validation of url    * @param urlString, the path of url    * @return True if connected successfully    *         False if fails    */
/* * UPDATE author set author_desc = 'seoulsi seocogu haimidieo byeolgwan' WHERE author_id = 21; */
/* * if (rs != null) { rs.close(); } */
/**     * Du /proc/net/tcp6De Shu Ju Ge      * Gen Ju Zhi Ding De port,Ying She Zhao Dao Dui Ying De uid     */
/**     * Huo Qu payloadSizeDe Da Xiao      * @return     */
/**     * Huo Qu TCBGe      * @param ipAndPort     * @return     */
/**     * Guan Bi TCB,Yi Chu it     * @param ipAndPort     */
/**     * Yi Chu Suo You ,Bao Gua Xiang Guan De channel     */
/**     * Not yet implemented.     */
/**     * Find plants from which we can create specimens.     * This will redirect us to the Plant Search screen.     */
/**     * Save the specimen to the persistence layer.     */
/**     * Stop listening for locations.     */
/**     * Start listening for locations.     */
/**     * Default settings.     */
/**     * Returns the size of the ship. The size is the number of cells occupied.     *      * @return the size of the ship     */
/**     * Returns the number of intact "cells".     *      * @return the number of intact "cells"      */
/**     * Hits one cell of the ship     */
/**     * Checks whether a ship is floating.     *      * @return true if the ship is still floating     */
/* * savePins : sseureoteurin pinyi gaesureul jeojanghanda. */
/* * checkS : seuteuraikeu, seupeeo yeobureul hwaginhanda. */
/* * getFrameTotal : hyeonjae peureimeseo sseureoteurin pinyi cong gaesureul banhwanhanda. */
/* *  printTotalScore : gag peureimyi boneoseu jeomsureul culryeoghanda. *  - daeum peureimi jinhaengdoeji anhasseul ddae, boneoseu jeomsuneun 0jeomeuro banhwanhanda. (geimi jinhaengdoen hu gaengsin ganeung) *  - seuteuraikeureul haesseul ddaen, ihu du beonyi tuguro sseureoteurin pinyi gaesureul banhwanhanda. *  - i dubeonyi tuguneun ilbanjeogeuro daeum peureimyi ceos beonjjae, du beonjjae sidoro gyeoljeongdoena,  *  ceos beonjjae sidoe ddo dasi seuteuraikeuga balsaenghamyeon geu daeum peureimyi ceos beonjjae sidoro gyeoljeongdoenda. *  - seupeeoreul haesseul ddaen, ihu han beonyi tugu(daeum peureimyi ceos beonjjae sido)ro sseureoteurin pinyi gaesureul banhwanhanda. */
/* play a card */
/* play a card */
/** creates a card with specified suit and rank     *     * @param suit is the suit of the card (must be a string from Card.SUITS)     * @param rank is the rank of the card (must be a string from Card.RANKS)     */
/** the numerical representation of the rank of the current card     *  <p>     * ranks have the numerical values     *  2 = 2, 3 = 3, ..., 10 = 10     *  Jack = 11, Queen = 12, King = 13, Ace = 14     *     * @return the numerical rank of this card     */
/** the string representation of the rank of the current card     *     * @return the string representation of the rank of this card (must be a string from Card.RANKS)     */
/** the suit of the current card     *     * @return the suit of this card (must be a string from Card.SUITS)     */
/* create the deck */
/* play a card */
/* play a card */
/* the top card on the discard pile */
/* add a card to the discard pile */
/* play a card */
/* create the deck */
/* play a card */
/* play a card  */
/* play a card */
/* play a card */
/* create the deck */
/* create the deck */
/**     * Creates new form Login_Form     */
/**     * @param args the command line arguments     */
/**     * Creates new form Register_Form     */
/**     * @param args the command line arguments     */
/**     * Creates new form admin_ui     */
/**     * @param args the command line arguments     */
/**     * Creates new form foreLogin     */
/**     * @param args the command line arguments     */
/**     * Creates new form forereg     */
/**     * @param args the command line arguments     */
/**     * Creates new form guest_ui     */
/**     * @param args the command line arguments     */
/**     * Creates new form user_ui     */
/**     * @param args the command line arguments     */
/**     * Returns a Charset for the named charset. If the name is null, return the default Charset.     *     * @param charset     *            The name of the requested charset, may be null.     * @return a Charset for the named charset     * @throws java.nio.charset.UnsupportedCharsetException     *             If the named charset is unavailable     */
/**     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may     * subsequently be initialized by a call to {@link #initCause}.     *     * @since 1.4     */
/**     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently     * be initialized by a call to {@link #initCause}.     *     * @param message     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.     */
/**     * Constructs a new exception with the specified detail message and cause.     * <p>     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this     * exception's detail message.     *     * @param message     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.     * @param cause     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>     *            value is permitted, and indicates that the cause is nonexistent or unknown.     * @since 1.4     */
/**     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).     * This constructor is useful for exceptions that are little more than wrappers for other throwables.     *     * @param cause     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>     *            value is permitted, and indicates that the cause is nonexistent or unknown.     * @since 1.4     */
/**     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may     * subsequently be initialized by a call to {@link #initCause}.     *     * @since 1.4     */
/**     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently     * be initialized by a call to {@link #initCause}.     *     * @param message     *            a useful message relating to the encoder specific error.     */
/**     * Constructs a new exception with the specified detail message and cause.     *     * <p>     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this     * exception's detail message.     * </p>     *     * @param message     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.     * @param cause     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>     *            value is permitted, and indicates that the cause is nonexistent or unknown.     * @since 1.4     */
/**     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).     * This constructor is useful for exceptions that are little more than wrappers for other throwables.     *     * @param cause     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>     *            value is permitted, and indicates that the cause is nonexistent or unknown.     * @since 1.4     */
/**     * Constructs a new instance with the given algorithm.     *     * @param stringEncoder     *            the StringEncoder used for comparisons.     */
/**     * Creates a Base32 codec used for decoding and encoding.     * <p>     * When encoding the line length is 0 (no chunking).     * </p>     *     */
/**     * Creates a Base32 codec used for decoding and encoding.     * <p>     * When encoding the line length is 0 (no chunking).     * </p>     * @param pad byte used as padding byte.     */
/**     * Creates a Base32 codec used for decoding and encoding.     * <p>     * When encoding the line length is 0 (no chunking).     * </p>     * @param useHex if {@code true} then use Base32 Hex alphabet     */
/**     * Creates a Base32 codec used for decoding and encoding.     * <p>     * When encoding the line length is 0 (no chunking).     * </p>     * @param useHex if {@code true} then use Base32 Hex alphabet     * @param pad byte used as padding byte.     */
/**     * Creates a Base32 codec used for decoding and encoding.     * <p>     * When encoding the line length is given in the constructor, the line separator is CRLF.     * </p>     *     * @param lineLength     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when     *            decoding.     */
/**     * Creates a Base32 codec used for decoding and encoding.     * <p>     * When encoding the line length and line separator are given in the constructor.     * </p>     * <p>     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.     * </p>     *     * @param lineLength     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when     *            decoding.     * @param lineSeparator     *            Each line of encoded data will end with this sequence of bytes.     * @throws IllegalArgumentException     *             The provided lineSeparator included some Base32 characters. That's not going to work!     */
/**     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.     * <p>     * When encoding the line length and line separator are given in the constructor.     * </p>     * <p>     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.     * </p>     *     * @param lineLength     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when     *            decoding.     * @param lineSeparator     *            Each line of encoded data will end with this sequence of bytes.     * @param useHex     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet     * @throws IllegalArgumentException     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the     *             lineLength &gt; 0 and lineSeparator is null.     */
/**     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.     * <p>     * When encoding the line length and line separator are given in the constructor.     * </p>     * <p>     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.     * </p>     *     * @param lineLength     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when     *            decoding.     * @param lineSeparator     *            Each line of encoded data will end with this sequence of bytes.     * @param useHex     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet     * @param pad byte used as padding byte.     * @throws IllegalArgumentException     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the     *             lineLength &gt; 0 and lineSeparator is null.     */
/**     * Creates a Base32InputStream such that all data read is Base32-decoded from the original provided InputStream.     *     * @param in     *            InputStream to wrap.     */
/**     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original     * provided InputStream.     *     * @param in     *            InputStream to wrap.     * @param doEncode     *            true if we should encode all data read from us, false if we should decode.     */
/**     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original     * provided InputStream.     *     * @param in     *            InputStream to wrap.     * @param doEncode     *            true if we should encode all data read from us, false if we should decode.     */
/**     * Creates a Base32OutputStream such that all data written is Base32-encoded to the original provided OutputStream.     *     * @param out     *            OutputStream to wrap.     */
/**     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the     * original provided OutputStream.     *     * @param out     *            OutputStream to wrap.     * @param doEncode     *            true if we should encode all data written to us, false if we should decode.     */
/**     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the     * original provided OutputStream.     *     * @param out     *            OutputStream to wrap.     * @param doEncode     *            true if we should encode all data written to us, false if we should decode.     */
/**     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.     * <p>     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.     * </p>     *     * <p>     * When decoding all variants are supported.     * </p>     */
/**     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.     * <p>     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.     * </p>     *     * <p>     * When decoding all variants are supported.     * </p>     *     * @param urlSafe     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to     *            <code>false</code>.     * @since 1.4     */
/**     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.     * <p>     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is     * STANDARD_ENCODE_TABLE.     * </p>     * <p>     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.     * </p>     * <p>     * When decoding all variants are supported.     * </p>     *     * @param lineLength     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when     *            decoding.     * @since 1.4     */
/**     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.     * <p>     * When encoding the line length and line separator are given in the constructor, and the encoding table is     * STANDARD_ENCODE_TABLE.     * </p>     * <p>     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.     * </p>     * <p>     * When decoding all variants are supported.     * </p>     *     * @param lineLength     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when     *            decoding.     * @param lineSeparator     *            Each line of encoded data will end with this sequence of bytes.     * @throws IllegalArgumentException     *             Thrown when the provided lineSeparator included some base64 characters.     * @since 1.4     */
/**     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.     * <p>     * When encoding the line length and line separator are given in the constructor, and the encoding table is     * STANDARD_ENCODE_TABLE.     * </p>     * <p>     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.     * </p>     * <p>     * When decoding all variants are supported.     * </p>     *     * @param lineLength     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when     *            decoding.     * @param lineSeparator     *            Each line of encoded data will end with this sequence of bytes.     * @param urlSafe     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode     *            operations. Decoding seamlessly handles both modes.     *            <b>Note: no padding is added when using the URL-safe alphabet.</b>     * @throws IllegalArgumentException     *             The provided lineSeparator included some base64 characters. That's not going to work!     * @since 1.4     */
/**     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.     *     * @return true if we're in URL-SAFE mode, false otherwise.     * @since 1.4     */
/**     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the     * method treats whitespace as valid.     *     * @param arrayOctet     *            byte array to test     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;     *         <code>false</code>, otherwise     * @since 1.5     */
/**     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.     *     * @param binaryData     *            Array containing binary data to encode.     * @param isChunked     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks     * @param urlSafe     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>     * @param maxResultSize     *            The maximum result size to accept.     * @return Base64-encoded data.     * @throws IllegalArgumentException     *             Thrown when the input array needs an output array bigger than maxResultSize     * @since 1.4     */
/**     * Encodes binary data using the base64 algorithm but does not chunk the output.     *     * NOTE:  We changed the behaviour of this method from multi-line chunking (commons-codec-1.4) to     * single-line non-chunking (commons-codec-1.5).     *     * @param binaryData     *            binary data to encode     * @return String containing Base64 characters.     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).     */
/**     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The     * url-safe variation emits - and _ instead of + and / characters.     * <b>Note: no padding is added.</b>     * @param binaryData     *            binary data to encode     * @return byte[] containing Base64 characters in their UTF-8 representation.     * @since 1.4     */
/**     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The     * url-safe variation emits - and _ instead of + and / characters.     * <b>Note: no padding is added.</b>     * @param binaryData     *            binary data to encode     * @return String containing Base64 characters     * @since 1.4     */
/**     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks     *     * @param binaryData     *            binary data to encode     * @return Base64 characters chunked in 76 character blocks     */
/**     * Decodes Base64 data into octets.     * <p>     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.     * </p>     *     * @param base64Data     *            Byte array containing Base64 data     * @return Array containing decoded data.     */
/**     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.     *     * @param pArray     *            a byte array containing base64 character data     * @return A BigInteger     * @since 1.4     */
/**     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.     *     * @param bigInt     *            a BigInteger     * @return A byte array containing base64 character data     * @throws NullPointerException     *             if null is passed in     * @since 1.4     */
/**     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.     *     * @param bigInt     *            <code>BigInteger</code> to be converted     * @return a byte array representation of the BigInteger parameter     */
/**     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.     *     * @param in     *            InputStream to wrap.     */
/**     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original     * provided InputStream.     *     * @param in     *            InputStream to wrap.     * @param doEncode     *            true if we should encode all data read from us, false if we should decode.     */
/**     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original     * provided InputStream.     *     * @param in     *            InputStream to wrap.     * @param doEncode     *            true if we should encode all data read from us, false if we should decode.     */
/**     * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.     *     * @param out     *            OutputStream to wrap.     */
/**     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the     * original provided OutputStream.     *     * @param out     *            OutputStream to wrap.     * @param doEncode     *            true if we should encode all data written to us, false if we should decode.     */
/**     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the     * original provided OutputStream.     *     * @param out     *            OutputStream to wrap.     * @param doEncode     *            true if we should encode all data written to us, false if we should decode.     */
/**     * Returns true if this object has buffered data for reading.     *     * @param context the context to be used     * @return true if there is data still available for reading.     */
/**     * Returns the amount of buffered data available for reading.     *     * @param context the context to be used     * @return The amount of buffered data available for reading.     */
/**     * Get the default buffer size. Can be overridden.     *     * @return {@link #DEFAULT_BUFFER_SIZE}     */
/**     * Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.     * @param context the context to be used     */
/**     * Ensure that the buffer has room for <code>size</code> bytes     *     * @param size minimum spare space required     * @param context the context to be used     * @return the buffer     */
/**     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail     * bytes. Returns how many bytes were actually extracted.     * <p>     * Package protected for access from I/O streams.     *     * @param b     *            byte[] array to extract the buffered data into.     * @param bPos     *            position in byte[] array to start extraction at.     * @param bAvail     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).     * @param context     *            the context to be used     * @return The number of bytes successfully extracted into the provided byte[] array.     */
/**     * Checks if a byte value is whitespace or not.     * Whitespace is taken to mean: space, tab, CR, LF     * @param byteToCheck     *            the byte to check     * @return true if byte is whitespace, false otherwise     */
/**     * Encodes a byte[] containing binary data, into a String containing characters in the Base-N alphabet.     * Uses UTF8 encoding.     *     * @param pArray     *            a byte array containing binary data     * @return A String containing only Base-N character data     */
/**     * Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.     * Uses UTF8 encoding.     *     * @param pArray a byte array containing binary data     * @return String containing only character data in the appropriate alphabet.    */
/**     * Tests a given String to see if it contains only valid characters within the alphabet.     * The method treats whitespace and PAD as valid.     *     * @param basen String to test     * @return <code>true</code> if all characters in the String are valid characters in the alphabet or if     *         the String is empty; <code>false</code>, otherwise     * @see #isInAlphabet(byte[], boolean)     */
/**     * Tests a given byte array to see if it contains any characters within the alphabet or PAD.     *     * Intended for use in checking line-ending arrays     *     * @param arrayOctet     *            byte array to test     * @return <code>true</code> if any byte is a valid character in the alphabet or PAD; <code>false</code> otherwise     */
/**     * Calculates the amount of space needed to encode the supplied array.     *     * @param pArray byte[] array which will later be encoded     *     * @return amount of space needed to encoded the supplied array.     * Returns a long since a max-len array will require &gt; Integer.MAX_VALUE     */
/**     * Decodes a String where each char of the String represents an ASCII '0' or '1'.     *     * @param ascii     *                  String of '0' and '1' characters     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument     * @see org.apache.commons.codec.Decoder#decode(Object)     */
/**     * Decodes a byte array where each byte represents an ASCII '0' or '1'.     *     * @param ascii     *                  each byte represents an ASCII '0' or '1'     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument     */
/**     * Returns <code>true</code> if the given array is <code>null</code> or empty (size 0.)     *     * @param array     *            the source array     * @return <code>true</code> if the given array is <code>null</code> or empty (size 0.)     */
/**     * Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated     * char.     *     * @param raw     *                  the raw binary data to convert     * @return an array of 0 and 1 character bytes for each bit of the argument     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])     */
/**     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.     *     * @param raw     *                  the raw binary data to convert     * @return an array of 0 and 1 characters for each bit of the argument     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])     */
/**     * Converts an array of raw binary data into a String of ASCII 0 and 1 characters.     *     * @param raw     *                  the raw binary data to convert     * @return a String of 0 and 1 characters representing the binary data     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])     */
/**     * Green implementation of regionMatches.     *     * @param cs     *            the <code>CharSequence</code> to be processed     * @param ignoreCase     *            whether or not to be case insensitive     * @param thisStart     *            the index to start on the <code>cs</code> CharSequence     * @param substring     *            the <code>CharSequence</code> to be looked for     * @param start     *            the index to start on the <code>substring</code> CharSequence     * @param length     *            character length of the region     * @return whether the region matched     */
/**     * Creates a new codec with the default charset name {@link #DEFAULT_CHARSET}     */
/**     * Creates a new codec with the given Charset.     *     * @param charset     *            the charset.     * @since 1.7     */
/**     * Creates a new codec with the given charset name.     *     * @param charsetName     *            the charset name.     * @throws java.nio.charset.UnsupportedCharsetException     *             If the named charset is unavailable     * @since 1.4     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable     */
/**     * Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The     * returned array will be half the length of the passed array, as it takes two characters to represent any given     * byte. An exception is thrown if the passed char array has an odd number of elements.     *     * @param data     *            An array of characters containing hexadecimal digits     * @return A byte array containing binary data decoded from the supplied char array.     * @throws DecoderException     *             Thrown if an odd number or illegal of characters is supplied     */
/**     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.     * The returned array will be double the length of the passed array, as it takes two characters to represent any     * given byte.     *     * @param data     *            a byte[] to convert to Hex characters     * @param toDigits     *            the output alphabet     * @return A char[] containing hexadecimal characters     * @since 1.4     */
/**     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned     * String will be double the length of the passed array, as it takes two characters to represent any given byte.     *     * @param data     *            a byte[] to convert to Hex characters     * @return A String containing hexadecimal characters     * @since 1.4     */
/**     * Converts a hexadecimal character to an integer.     *     * @param ch     *            A character to convert to an integer digit     * @param index     *            The index of the character in the source     * @return An integer     * @throws DecoderException     *             Thrown if ch is an illegal hex character     */
/**     * Gets the charset.     *     * @return the charset.     * @since 1.7     */
/**     * Gets the charset name.     *     * @return the charset name.     * @since 1.4     */
/**     * <p>     * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.     * </p>     *     * <p>     * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.     * The comparison is case sensitive.     * </p>     *     * <pre>     * StringUtils.equals(null, null)   = true     * StringUtils.equals(null, "abc")  = false     * StringUtils.equals("abc", null)  = false     * StringUtils.equals("abc", "abc") = true     * StringUtils.equals("abc", "ABC") = false     * </pre>     *     * <p>     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).     * </p>     *     * @see Object#equals(Object)     * @param cs1     *            the first CharSequence, may be <code>null</code>     * @param cs2     *            the second CharSequence, may be <code>null</code>     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>     * @since 1.10     */
/**     * Calls {@link String#getBytes(Charset)}     *     * @param string     *            The string to encode (if null, return null).     * @param charset     *            The {@link Charset} to encode the <code>String</code>     * @return the encoded bytes     */
/**     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new     * byte array.     *     * @param string     *            the String to encode, may be <code>null</code>     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>     * @throws NullPointerException     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is     *             required by the Java platform specification.     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException     * @see <a href="http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html">Standard charsets</a>     * @see #getBytesUnchecked(String, String)     */
/**     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte     * array.     * <p>     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.     * </p>     *     * @param string     *            the String to encode, may be <code>null</code>     * @param charsetName     *            The name of a required {@link java.nio.charset.Charset}     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>     * @throws IllegalStateException     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a     *             required charset name.     * @see CharEncoding     * @see String#getBytes(String)     */
/**     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte     * array.     *     * @param string     *            the String to encode, may be <code>null</code>     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>     * @throws NullPointerException     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is     *             required by the Java platform specification.     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException     * @see <a href="http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html">Standard charsets</a>     * @see #getBytesUnchecked(String, String)     */
/**     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte     * array.     *     * @param string     *            the String to encode, may be <code>null</code>     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>     * @throws NullPointerException     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is     *             required by the Java platform specification.     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException     * @see <a href="http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html">Standard charsets</a>     * @see #getBytesUnchecked(String, String)     */
/**     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte     * array.     *     * @param string     *            the String to encode, may be <code>null</code>     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>     * @throws NullPointerException     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is     *             required by the Java platform specification.     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException     * @see <a href="http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html">Standard charsets</a>     * @see #getBytesUnchecked(String, String)     */
/**     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte     * array.     *     * @param string     *            the String to encode, may be <code>null</code>     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>     * @throws NullPointerException     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is     *             required by the Java platform specification.     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException     * @see <a href="http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html">Standard charsets</a>     * @see #getBytesUnchecked(String, String)     */
/**     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte     * array.     *     * @param string     *            the String to encode, may be <code>null</code>     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>     * @throws NullPointerException     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is     *             required by the Java platform specification.     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException     * @see <a href="http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html">Standard charsets</a>     * @see #getBytesUnchecked(String, String)     */
/**     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.     * <p>     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.     * </p>     *     * @param bytes     *            The bytes to be decoded into characters, may be <code>null</code>     * @param charsetName     *            The name of a required {@link java.nio.charset.Charset}     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,     *         or <code>null</code> if the input byte array was <code>null</code>.     * @throws IllegalStateException     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a     *             required charset name.     * @see CharEncoding     * @see String#String(byte[], String)     */
/**     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.     *     * @param bytes     *            The bytes to be decoded into characters, may be <code>null</code>     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or     *         <code>null</code> if the input byte array was <code>null</code>.     * @throws NullPointerException     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is     *             required by the Java platform specification.     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException     */
/**     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.     *     * @param bytes     *            The bytes to be decoded into characters     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,     *         or <code>null</code> if the input byte array was <code>null</code>.     * @throws NullPointerException     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is     *             required by the Java platform specification.     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException     */
/**     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.     *     * @param bytes     *            The bytes to be decoded into characters     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16 charset     *         or <code>null</code> if the input byte array was <code>null</code>.     * @throws NullPointerException     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is     *             required by the Java platform specification.     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException     */
/**     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.     *     * @param bytes     *            The bytes to be decoded into characters     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16BE charset,     *         or <code>null</code> if the input byte array was <code>null</code>.     * @throws NullPointerException     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is     *             required by the Java platform specification.     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException     */
/**     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.     *     * @param bytes     *            The bytes to be decoded into characters     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,     *         or <code>null</code> if the input byte array was <code>null</code>.     * @throws NullPointerException     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is     *             required by the Java platform specification.     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException     */
/**     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.     *     * @param bytes     *            The bytes to be decoded into characters     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,     *         or <code>null</code> if the input byte array was <code>null</code>.     * @throws NullPointerException     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is     *             required by the Java platform specification.     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException     */
/**     * Base64 like conversion of bytes to ASCII chars.     *     * @param b2     *            A byte from the result.     * @param b1     *            A byte from the result.     * @param b0     *            A byte from the result.     * @param outLen     *            The number of expected output chars.     * @param buffer     *            Where the output chars is appended to.     */
/**     * Generates a string of random chars from the B64T set.     *     * @param num     *            Number of chars to generate.     */
/**     * Encrypts a password in a crypt(3) compatible way.     * <p>     * The exact algorithm depends on the format of the salt string:     * <ul>     * <li>SHA-512 salts start with {@code $6$} and are up to 16 chars long.     * <li>SHA-256 salts start with {@code $5$} and are up to 16 chars long     * <li>MD5 salts start with {@code $1$} and are up to 8 chars long     * <li>DES, the traditional UnixCrypt algorithm is used with only 2 chars     * <li>Only the first 8 chars of the passwords are used in the DES algorithm!     * </ul>     * The magic strings {@code "$apr1$"} and {@code "$2a$"} are not recognized by this method as its output should be     * identical with that of the libc implementation.     * <p>     * The rest of the salt string is drawn from the set {@code [a-zA-Z0-9./]} and is cut at the maximum length of if a     * {@code "$"} sign is encountered. It is therefore valid to enter a complete hash value as salt to e.g. verify a     * password with:     *     * <pre>     * storedPwd.equals(crypt(enteredPwd, storedPwd))     * </pre>     * <p>     * The resulting string starts with the marker string ({@code $6$}), continues with the salt value and ends with a     * {@code "$"} sign followed by the actual hash value. For DES the string only contains the salt and actual hash.     * It's total length is dependent on the algorithm used:     * <ul>     * <li>SHA-512: 106 chars     * <li>SHA-256: 63 chars     * <li>MD5: 34 chars     * <li>DES: 13 chars     * </ul>     * <p>     * Example:     *     * <pre>     *      crypt("secret", "$1$xxxx") =&gt; "$1$xxxx$aMkevjfEIpa35Bh3G4bAc."     *      crypt("secret", "xx") =&gt; "xxWAum7tHdIUw"     * </pre>     * <p>     * This method comes in a variation that accepts a byte[] array to support input strings that are not encoded in     * UTF-8 but e.g. in ISO-8859-1 where equal characters result in different byte values.     *     * @see "The man page of the libc crypt (3) function."     * @param key     *            plaintext password as entered by the used     * @param salt     *            salt value     * @return hash value, i.e. encrypted password including the salt string     * @throws IllegalArgumentException     *             if the salt does not match the allowed pattern     * @throws RuntimeException     *             when a {@link java.security.NoSuchAlgorithmException} is caught. *     */
/**     * Read through an InputStream and returns the digest for the data     *     * @param digest     *            The MessageDigest to use (e.g. MD5)     * @param data     *            Data to digest     * @return the digest     * @throws IOException     *             On error reading from the stream     */
/**     * Returns a <code>MessageDigest</code> for the given <code>algorithm</code>.     *     * @param algorithm     *            the name of the algorithm requested. See <a     *            href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA"     *            >Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard     *            algorithm names.     * @return A digest instance.     * @see MessageDigest#getInstance(String)     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught.     */
/**     * Returns an MD2 MessageDigest.     *     * @return An MD2 digest instance.     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD2 is a     *             built-in algorithm     * @see MessageDigestAlgorithms#MD2     * @since 1.7     */
/**     * Returns an MD5 MessageDigest.     *     * @return An MD5 digest instance.     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD5 is a     *             built-in algorithm     * @see MessageDigestAlgorithms#MD5     */
/**     * Returns an SHA-1 digest.     *     * @return An SHA-1 digest instance.     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-1 is a     *             built-in algorithm     * @see MessageDigestAlgorithms#SHA_1     * @since 1.7     */
/**     * Returns an SHA-256 digest.     * <p>     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.     * </p>     *     * @return An SHA-256 digest instance.     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-256 is a     *             built-in algorithm     * @see MessageDigestAlgorithms#SHA_256     */
/**     * Returns an SHA-384 digest.     * <p>     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.     * </p>     *     * @return An SHA-384 digest instance.     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-384 is a     *             built-in algorithm     * @see MessageDigestAlgorithms#SHA_384     */
/**     * Returns an SHA-512 digest.     * <p>     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.     * </p>     *     * @return An SHA-512 digest instance.     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-512 is a     *             built-in algorithm     * @see MessageDigestAlgorithms#SHA_512     */
/**     * Calculates the MD2 digest and returns the value as a 16 element <code>byte[]</code>.     *     * @param data     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}     * @return MD2 digest     * @since 1.7     */
/**     * Calculates the MD2 digest and returns the value as a 32 character hex string.     *     * @param data     *            Data to digest     * @return MD2 digest as a hex string     * @since 1.7     */
/**     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.     *     * @param data     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}     * @return MD5 digest     */
/**     * Calculates the MD5 digest and returns the value as a 32 character hex string.     *     * @param data     *            Data to digest     * @return MD5 digest as a hex string     */
/**     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.     *     * @param data     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}     * @return SHA-1 digest     */
/**     * Calculates the SHA-1 digest and returns the value as a hex string.     *     * @param data     *            Data to digest     * @return SHA-1 digest as a hex string     * @since 1.7     */
/**     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.     * <p>     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.     * </p>     *     * @param data     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}     * @return SHA-256 digest     * @since 1.4     */
/**     * Calculates the SHA-256 digest and returns the value as a hex string.     * <p>     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.     * </p>     *     * @param data     *            Data to digest     * @return SHA-256 digest as a hex string     * @since 1.4     */
/**     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.     * <p>     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.     * </p>     *     * @param data     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}     * @return SHA-384 digest     * @since 1.4     */
/**     * Calculates the SHA-384 digest and returns the value as a hex string.     * <p>     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.     * </p>     *     * @param data     *            Data to digest     * @return SHA-384 digest as a hex string     * @since 1.4     */
/**     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.     * <p>     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.     * </p>     *     * @param data     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}     * @return SHA-512 digest     * @since 1.4     */
/**     * Calculates the SHA-512 digest and returns the value as a hex string.     * <p>     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.     * </p>     *     * @param data     *            Data to digest     * @return SHA-512 digest as a hex string     * @since 1.4     */
/**     * Updates the given {@link MessageDigest}.     *     * @param messageDigest     *            the {@link MessageDigest} to update     * @param valueToDigest     *            the value to update the {@link MessageDigest} with;     *            converted to bytes using {@link StringUtils#getBytesUtf8(String)}     * @return the updated {@link MessageDigest}     * @since 1.7     */
/**     * Returns an initialized <code>Mac</code> for the HmacMD5 algorithm.     * <p>     * Every implementation of the Java platform is required to support this standard Mac algorithm.     * </p>     *     * @param key     *            They key for the keyed digest (must not be null)     * @return A Mac instance initialized with the given key.     * @see Mac#getInstance(String)     * @see Mac#init(Key)     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns an initialized <code>Mac</code> for the HmacSHA1 algorithm.     * <p>     * Every implementation of the Java platform is required to support this standard Mac algorithm.     * </p>     *     * @param key     *            They key for the keyed digest (must not be null)     * @return A Mac instance initialized with the given key.     * @see Mac#getInstance(String)     * @see Mac#init(Key)     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns an initialized <code>Mac</code> for the HmacSHA256 algorithm.     * <p>     * Every implementation of the Java platform is required to support this standard Mac algorithm.     * </p>     *     * @param key     *            They key for the keyed digest (must not be null)     * @return A Mac instance initialized with the given key.     * @see Mac#getInstance(String)     * @see Mac#init(Key)     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns an initialized <code>Mac</code> for the HmacSHA384 algorithm.     * <p>     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.     * </p>     *     * @param key     *            They key for the keyed digest (must not be null)     * @return A Mac instance initialized with the given key.     * @see Mac#getInstance(String)     * @see Mac#init(Key)     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns an initialized <code>Mac</code> for the HmacSHA512 algorithm.     * <p>     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.     * </p>     *     * @param key     *            They key for the keyed digest (must not be null)     * @return A Mac instance initialized with the given key.     * @see Mac#getInstance(String)     * @see Mac#init(Key)     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns an initialized <code>Mac</code> for the given <code>algorithm</code>.     *     * @param algorithm     *            the name of the algorithm requested. See <a href=     *            "http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA" >Appendix     *            A in the Java Cryptography Architecture Reference Guide</a> for information about standard algorithm     *            names.     * @param key     *            They key for the keyed digest (must not be null)     * @return A Mac instance initialized with the given key.     * @see Mac#getInstance(String)     * @see Mac#init(Key)     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.     *     * @param key     *            They key for the keyed digest (must not be null)     * @param valueToDigest     *            The value (data) which should to digest (maybe empty or null)     * @return HmacMD5 MAC for the given key and value     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns a HmacMD5 Message Authentication Code (MAC) as a hex string (lowercase) for the given key and value.     *     * @param key     *            They key for the keyed digest (must not be null)     * @param valueToDigest     *            The value (data) which should to digest (maybe empty or null)     * @return HmacMD5 MAC for the given key and value as a hex string (lowercase)     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.     *     * @param key     *            They key for the keyed digest (must not be null)     * @param valueToDigest     *            The value (data) which should to digest (maybe empty or null)     * @return HmacSHA1 MAC for the given key and value     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns a HmacSHA1 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.     *     * @param key     *            They key for the keyed digest (must not be null)     * @param valueToDigest     *            The value (data) which should to digest (maybe empty or null)     * @return HmacSHA1 MAC for the given key and value as hex string (lowercase)     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.     *     * @param key     *            They key for the keyed digest (must not be null)     * @param valueToDigest     *            The value (data) which should to digest (maybe empty or null)     * @return HmacSHA256 MAC for the given key and value     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns a HmacSHA256 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.     *     * @param key     *            They key for the keyed digest (must not be null)     * @param valueToDigest     *            The value (data) which should to digest (maybe empty or null)     * @return HmacSHA256 MAC for the given key and value as hex string (lowercase)     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.     *     * @param key     *            They key for the keyed digest (must not be null)     * @param valueToDigest     *            The value (data) which should to digest (maybe empty or null)     * @return HmacSHA384 MAC for the given key and value     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns a HmacSHA384 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.     *     * @param key     *            They key for the keyed digest (must not be null)     * @param valueToDigest     *            The value (data) which should to digest (maybe empty or null)     * @return HmacSHA384 MAC for the given key and value as hex string (lowercase)     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.     *     * @param key     *            They key for the keyed digest (must not be null)     * @param valueToDigest     *            The value (data) which should to digest (maybe empty or null)     * @return HmacSHA512 MAC for the given key and value     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Returns a HmacSHA512 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.     *     * @param key     *            They key for the keyed digest (must not be null)     * @param valueToDigest     *            The value (data) which should to digest (maybe empty or null)     * @return HmacSHA512 MAC for the given key and value as hex string (lowercase)     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.     */
/**     * Updates the given {@link Mac}. This generates a digest for valueToDigest and the key the Mac was initialized     *     * @param mac     *            the initialized {@link Mac} to update     * @param valueToDigest     *            the value to update the {@link Mac} with (maybe null or empty)     * @return the updated {@link Mac}     * @throws IllegalStateException     *             if the Mac was not initialized     * @since 1.x     */
/**     * Generates an Apache htpasswd compatible "$apr1$" MD5 based hash value.     * <p>     * The algorithm is identical to the crypt(3) "$1$" one but produces different outputs due to the different salt     * prefix.     *     * @param keyBytes     *            plaintext string to hash.     * @param salt     *            salt string including the prefix and optionally garbage at the end. Will be generated randomly if     *            null.     * @return the hash value     * @throws IllegalArgumentException     *             if the salt does not match the allowed pattern     * @throws RuntimeException     *             when a {@link java.security.NoSuchAlgorithmException} is caught.     */
/**     * Generates a libc6 crypt() "$1$" or Apache htpasswd "$apr1$" hash value.     * <p>     * See {@link Crypt#crypt(String, String)} or {@link #apr1Crypt(String, String)} for details.     *     * @param keyBytes     *            plaintext string to hash.     * @param salt May be null.     * @param prefix salt prefix     * @return the hash value     * @throws IllegalArgumentException     *             if the salt does not match the allowed pattern     * @throws RuntimeException     *             when a {@link java.security.NoSuchAlgorithmException} is caught.     */
/**     * Generates a libc6 crypt() compatible "$5$" hash value.     * <p>     * See {@link Crypt#crypt(String, String)} for details.     *     * @param keyBytes     *            plaintext to hash     * @param salt     *            real salt value without prefix or "rounds="     * @return complete hash value including salt     * @throws IllegalArgumentException     *             if the salt does not match the allowed pattern     * @throws RuntimeException     *             when a {@link java.security.NoSuchAlgorithmException} is caught.     */
/**     * Generates a libc6 crypt() compatible "$5$" or "$6$" SHA2 based hash value.     * <p>     * This is a nearly line by line conversion of the original C function. The numbered comments are from the algorithm     * description, the short C-style ones from the original C code and the ones with "Remark" from me.     * <p>     * See {@link Crypt#crypt(String, String)} for details.     *     * @param keyBytes     *            plaintext to hash     * @param salt     *            real salt value without prefix or "rounds="     * @param saltPrefix     *            either $5$ or $6$     * @param blocksize     *            a value that differs between $5$ and $6$     * @param algorithm     *            {@link MessageDigest} algorithm identifier string     * @return complete hash value including prefix and salt     * @throws IllegalArgumentException     *             if the given salt is <code>null</code> or does not match the allowed pattern     * @throws IllegalArgumentException     *             when a {@link NoSuchAlgorithmException} is caught     * @see MessageDigestAlgorithms     */
/**     * Generates a libc6 crypt() compatible "$6$" hash value.     * <p>     * See {@link Crypt#crypt(String, String)} for details.     *     * @param keyBytes     *            plaintext to hash     * @param salt     *            real salt value without prefix or "rounds="     * @return complete hash value including salt     * @throws IllegalArgumentException     *             if the salt does not match the allowed pattern     * @throws RuntimeException     *             when a {@link java.security.NoSuchAlgorithmException} is caught.     */
/**     * Generates a crypt(3) compatible hash using the DES algorithm.     *     * @param original     *            plaintext password     * @param salt     *            a two character string drawn from [a-zA-Z0-9./] or null for a random one     * @return a 13 character string starting with the salt string     * @throws IllegalArgumentException     *             if the salt does not match the allowed pattern     */
/**     * Creates an instance of the Caverphone encoder     */
/**     * Tests if the encodings of two strings are equal.     *     * This method might be promoted to a new AbstractStringEncoder superclass.     *     * @param str1     *            First of two strings to compare     * @param str2     *            Second of two strings to compare     * @return <code>true</code> if the encodings of these strings are identical, <code>false</code> otherwise.     * @throws EncoderException     *             thrown if there is an error condition during the encoding process.     */
/**     * Creates an instance of the Caverphone encoder     */
/**     * Encodes the given String into a Caverphone value.     *     * @param source     *            String the source string     * @return A caverphone code for the given String     */
/**     * Tests if the caverphones of two strings are identical.     *     * @param str1     *            First of two strings to compare     * @param str2     *            Second of two strings to compare     * @return <code>true</code> if the caverphones of these strings are identical, <code>false</code> otherwise.     */
/*     * Returns whether the array contains the key, or not.     */
/**     * <p>     * Implements the <i>K&ouml;lner Phonetik</i> algorithm.     * </p>     * <p>     * In contrast to the initial description of the algorithm, this implementation does the encoding in one pass.     * </p>     *     * @param text The source text to encode     * @return the corresponding encoding according to the <i>K&ouml;lner Phonetik</i> algorithm     */
/**     * Converts the string to upper case and replaces germanic characters as defined in {@link #PREPROCESS_MAP}.     */
/**     * Creates a new instance with ASCII-folding enabled.     */
/**     * Creates a new instance.     * <p>     * With ASCII-folding enabled, certain accented characters will be transformed to equivalent ASCII characters, e.g.     * e -&gt; e.     * </p>     *     * @param folding     *            if ASCII-folding shall be performed before encoding     */
/**         * Creates a new branch, identical to this branch.         *         * @return a new, identical branch         */
/**         * Finish this branch by appending '0's until the maximum code length has been reached.         */
/**         * Process the next replacement to be added to this branch.         *         * @param replacement         *            the next replacement to append         * @param forceAppend         *            indicates if the default processing shall be overridden         */
/**     * Performs a cleanup of the input string before the actual soundex transformation.     * <p>     * Removes all whitespace characters and performs ASCII folding if enabled.     * </p>     *     * @param input     *            the input string to cleanup     * @return a cleaned up string     */
/**     * Perform the actual DM Soundex algorithm on the input string.     *     * @param source     *            A String object to encode     * @param branching     *            If branching shall be performed     * @return A string array containing all DM Soundex codes corresponding to the String supplied depending on the     *         selected branching mode     */
/**     * Creates an instance of this DoubleMetaphone encoder     */
/**     * Encode a value with Double Metaphone, optionally using the alternate encoding.     *     * @param value String to encode     * @param alternate use alternate encode     * @return an encoded string     */
/**     * Check if the Double Metaphone values of two <code>String</code> values     * are equal, optionally using the alternate value.     *     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.     * @param alternate use the alternate value if <code>true</code>.     * @return <code>true</code> if the encoded <code>String</code>s are equal;     *          <code>false</code> otherwise.     */
/**     * Returns the maxCodeLen.     * @return int     */
/**     * Sets the maxCodeLen.     * @param maxCodeLen The maxCodeLen to set     */
/**     * Handles 'C' cases.     */
/**     * Handles 'CC' cases.     */
/**     * Handles 'CH' cases.     */
/**     * Handles 'D' cases.     */
/**     * Handles 'G' cases.     */
/**     * Handles 'GH' cases.     */
/**     * Handles 'H' cases.     */
/**     * Handles 'J' cases.     */
/**     * Handles 'L' cases.     */
/**     * Handles 'P' cases.     */
/**     * Handles 'R' cases.     */
/**     * Handles 'S' cases.     */
/**     * Handles 'SC' cases.     */
/**     * Handles 'T' cases.     */
/**     * Handles 'W' cases.     */
/**     * Handles 'X' cases.     */
/**     * Handles 'Z' cases.     */
/**     * Complex condition 0 for 'C'.     */
/**     * Complex condition 0 for 'CH'.     */
/**     * Complex condition 1 for 'CH'.     */
/**     * Complex condition 0 for 'L'.     */
/**     * Complex condition 0 for 'M'.     */
/**     * Determines whether or not a value is of slavo-germanic origin. A value is     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.     */
/**     * Determines whether or not a character is a vowel or not     */
/**     * Determines whether or not the value starts with a silent letter.  It will     * return <code>true</code> if the value starts with any of 'GN', 'KN',     * 'PN', 'WR' or 'PS'.     */
/**     * Cleans the input.     */
/*     * Gets the character at index <code>index</code> if available, otherwise     * it returns <code>Character.MIN_VALUE</code> so that there is some sort     * of a default.     */
/*     * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and     * matching up to length <code>length</code>.     */
/**     * Cleans up a name: 1. Upper-cases everything 2. Removes some common punctuation 3. Removes accents 4. Removes any     * spaces.     *     * <h2>API Usage</h2>     * <p>     * Consider this method private, it is package protected for unit testing only.     * </p>     *     * @param name     *            The name to be cleaned     * @return The cleaned name     */
/**     * Gets the first and last 3 letters of a name (if &gt; 6 characters) Else just returns the name.     *     * <h2>API Usage</h2>     * <p>     * Consider this method private, it is package protected for unit testing only.     * </p>     *     * @param name     *            The string to get the substrings from     * @return Annexed first and last 3 letters of input word.     */
/**     * Obtains the min rating of the length sum of the 2 names. In essence the larger the sum length the smaller the     * min rating. Values strictly from documentation.     *     * <h2>API Usage</h2>     * <p>     * Consider this method private, it is package protected for unit testing only.     * </p>     *     * @param sumLength     *            The length of 2 strings sent down     * @return The min rating value     */
/**     * Determines if two names are homophonous via Match Rating Approach (MRA) algorithm. It should be noted that the     * strings are cleaned in the same way as {@link #encode(String)}.     *     * @param name1     *            First of the 2 strings (names) to compare     * @param name2     *            Second of the 2 names to compare     * @return <code>true</code> if the encodings are identical <code>false</code> otherwise.     */
/**     * Determines if a letter is a vowel.     *     * <h2>API Usage</h2>     * <p>     * Consider this method private, it is package protected for unit testing only.     * </p>     *     * @param letter     *            The letter under investiagtion     * @return True if a vowel, else false     */
/**     * Processes the names from left to right (first) then right to left removing identical letters in same positions.     * Then subtracts the longer string that remains from 6 and returns this.     *     * <h2>API Usage</h2>     * <p>     * Consider this method private, it is package protected for unit testing only.     * </p>     *     * @param name1     *            name2     * @return     */
/**     * Removes accented letters and replaces with non-accented ascii equivalent Case is preserved.     * http://www.codecodex.com/wiki/Remove_accent_from_letters_%28ex_.%C3%A9_to_e%29     *     * @param accentedWord     *            The word that may have accents in it.     * @return De-accented word     */
/**     * Replaces any double consonant pair with the single letter equivalent.     *     * <h2>API Usage</h2>     * <p>     * Consider this method private, it is package protected for unit testing only.     * </p>     *     * @param name     *            String to have double consonants removed     * @return Single consonant word     */
/**     * Deletes all vowels unless the vowel begins the word.     *     * <h2>API Usage</h2>     * <p>     * Consider this method private, it is package protected for unit testing only.     * </p>     *     * @param name     *            The name to have vowels removed     * @return De-voweled word     */
/**     * Creates an instance of the Metaphone encoder     */
/**     * Find the metaphone value of a String. This is similar to the     * soundex algorithm, but better at finding similar sounding words.     * All input is converted to upper case.     * Limitations: Input format is expected to be a single ASCII word     * with only characters in the A - Z range, no punctuation or numbers.     *     * @param txt String to find the metaphone code for     * @return A metaphone code corresponding to the String supplied     */
/**     * Tests is the metaphones of two strings are identical.     *     * @param str1 First of two strings to compare     * @param str2 Second of two strings to compare     * @return <code>true</code> if the metaphones of these strings are identical,     *        <code>false</code> otherwise.     */
/**     * Returns the maxCodeLen.     * @return int     */
/**     * Sets the maxCodeLen.     * @param maxCodeLen The maxCodeLen to set     */
/**     * Creates an instance of the {@link Nysiis} encoder with strict mode (original form),     * i.e. encoded strings have a maximum length of 6.     */
/**     * Create an instance of the {@link Nysiis} encoder with the specified strict mode:     *     * <ul>     *  <li><code>true</code>: encoded strings have a maximum length of 6</li>     *  <li><code>false</code>: encoded strings may have arbitrary length</li>     * </ul>     *     * @param strict     *            the strict mode     */
/**     * Tests if the given character is a vowel.     *     * @param c     *            the character to test     * @return <code>true</code> if the character is a vowel, <code>false</code> otherwise     */
/**     * Transcodes the remaining parts of the String. The method operates on a sliding window, looking at 4 characters at     * a time: [i-1, i, i+1, i+2].     *     * @param prev     *            the previous character     * @param curr     *            the current character     * @param next     *            the next character     * @param aNext     *            the after next character     * @return a transcoded array of characters, starting from the current position     */
/**     * Indicates the strict mode for this {@link Nysiis} encoder.     *     * @return <code>true</code> if the encoder is configured for strict mode, <code>false</code> otherwise     */
/**     * Retrieves the NYSIIS code for a given String object.     *     * @param str     *            String to encode using the NYSIIS algorithm     * @return A NYSIIS code for the String supplied     */
/**     * Creates an instance of the RefinedSoundex object using the default US     * English mapping.     */
/**     * Creates a refined soundex instance using a custom mapping. This     * constructor can be used to customize the mapping, and/or possibly     * provide an internationalized mapping for a non-Western character set.     *     * @param mapping     *                  Mapping array to use when finding the corresponding code for     *                  a given character     */
/**     * Creates a refined Soundex instance using a custom mapping. This constructor can be used to customize the mapping,     * and/or possibly provide an internationalized mapping for a non-Western character set.     *     * @param mapping     *            Mapping string to use when finding the corresponding code for a given character     * @since 1.4     */
/**     * Returns the number of characters in the two encoded Strings that are the     * same. This return value ranges from 0 to the length of the shortest     * encoded String: 0 indicates little or no similarity, and 4 out of 4 (for     * example) indicates strong similarity or identical values. For refined     * Soundex, the return value can be greater than 4.     *     * @param s1     *                  A String that will be encoded and compared.     * @param s2     *                  A String that will be encoded and compared.     * @return The number of characters in the two encoded Strings that are the     *             same from 0 to to the length of the shortest encoded String.     *     * @see SoundexUtils#difference(StringEncoder,String,String)     * @see <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp">     *          MS T-SQL DIFFERENCE</a>     *     * @throws EncoderException     *                  if an error occurs encoding one of the strings     * @since 1.3     */
/**     * Returns the mapping code for a given character. The mapping codes are     * maintained in an internal char array named soundexMapping, and the     * default values of these mappings are US English.     *     * @param c     *                  char to get mapping for     * @return A character (really a numeral) to return for the given char     */
/**     * Retrieves the Refined Soundex code for a given String object.     *     * @param str     *                  String to encode using the Refined Soundex algorithm     * @return A soundex code for the String supplied     */
/**     * Creates an instance using US_ENGLISH_MAPPING     *     * @see Soundex#Soundex(char[])     * @see Soundex#US_ENGLISH_MAPPING     */
/**     * Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized     * mapping for a non-Western character set.     *     * Every letter of the alphabet is "mapped" to a numerical value. This char array holds the values to which each     * letter is mapped. This implementation contains a default map for US_ENGLISH     *     * @param mapping     *                  Mapping array to use when finding the corresponding code for a given character     */
/**     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,     * and/or possibly provide an internationalized mapping for a non-Western character set.     *     * @param mapping     *            Mapping string to use when finding the corresponding code for a given character     * @since 1.4     */
/**     * Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or     * identical values.     *     * @param s1     *                  A String that will be encoded and compared.     * @param s2     *                  A String that will be encoded and compared.     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.     *     * @see SoundexUtils#difference(StringEncoder,String,String)     * @see <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp"> MS     *          T-SQL DIFFERENCE </a>     *     * @throws EncoderException     *                  if an error occurs encoding one of the strings     * @since 1.3     */
/**     * Used internally by the SoundEx algorithm.     *     * Consonants from the same code group separated by W or H are treated as one.     *     * @param str     *                  the cleaned working string to encode (in upper case).     * @param index     *                  the character position to encode     * @return Mapping code for a particular character     * @throws IllegalArgumentException     *                  if the character is not mapped     */
/**     * Returns the soundex mapping.     *     * @return soundexMapping.     */
/**     * Maps the given upper-case character to its Soundex code.     *     * @param ch     *                  An upper-case character.     * @return A Soundex code.     * @throws IllegalArgumentException     *                  Thrown if <code>ch</code> is not mapped.     */
/**     * Retrieves the Soundex code for a given String object.     *     * @param str     *                  String to encode using the Soundex algorithm     * @return A soundex code for the String supplied     * @throws IllegalArgumentException     *                  if a character is not mapped     */
/**     * Cleans up the input string before Soundex processing by only returning     * upper case letters.     *     * @param str     *                  The String to clean.     * @return A clean String.     */
/**     * Encodes the Strings and returns the number of characters in the two     * encoded Strings that are the same.     * <ul>     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates     * little or no similarity, and 4 indicates strong similarity or identical     * values.</li>     * <li>For refined Soundex, the return value can be greater than 4.</li>     * </ul>     *     * @param encoder     *                  The encoder to use to encode the Strings.     * @param s1     *                  A String that will be encoded and compared.     * @param s2     *                  A String that will be encoded and compared.     * @return The number of characters in the two Soundex encoded Strings that     *             are the same.     *     * @see #differenceEncoded(String,String)     * @see <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp">     *          MS T-SQL DIFFERENCE</a>     *     * @throws EncoderException     *                  if an error occurs encoding one of the strings     */
/**     * Returns the number of characters in the two Soundex encoded Strings that     * are the same.     * <ul>     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates     * little or no similarity, and 4 indicates strong similarity or identical     * values.</li>     * <li>For refined Soundex, the return value can be greater than 4.</li>     * </ul>     *     * @param es1     *                  An encoded String.     * @param es2     *                  An encoded String.     * @return The number of characters in the two Soundex encoded Strings that     *             are the same.     *     * @see <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp">     *          MS T-SQL DIFFERENCE</a>     */
/**     * Gets the name type currently in operation.     *     * @return the NameType currently being used     */
/**     * Gets the rule type currently in operation.     *     * @return the RuleType currently being used     */
/**     * Discovers if multiple possible encodings are concatenated.     *     * @return true if multiple encodings are concatenated, false if just the first one is returned     */
/**     * Sets how multiple possible phonetic encodings are combined.     *     * @param concat     *            true if multiple encodings are to be combined with a '|', false if just the first one is     *            to be considered     */
/**     * Sets the type of name. Use {@link NameType#GENERIC} unless you specifically want phonetic encodings     * optimized for Ashkenazi or Sephardic Jewish family names.     *     * @param nameType     *            the NameType in use     */
/**     * Sets the rule type to apply. This will widen or narrow the range of phonetic encodings considered.     *     * @param ruleType     *            {@link RuleType#APPROX} or {@link RuleType#EXACT} for approximate or exact phonetic matches     */
/**     * Sets the number of maximum of phonemes that shall be considered by the engine.     *     * @param maxPhonemes     *            the maximum number of phonemes returned by the engine     * @since 1.7     */
/**     * Guesses the languages of a word.     *     * @param input     *            the word     * @return a Set of Strings of language names that are potential matches for the input word     */
/**     * Gets a Lang instance for one of the supported NameTypes.     *     * @param nameType     *            the NameType to look up     * @return a Lang encapsulating the language guessing rules for that name type     */
/**     * Loads language rules from a resource.     * <p>     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method.     * You will only need to call this yourself if you are developing custom language mapping rules.     *     * @param languageRulesResourceName     *            the fully-qualified resource name to load     * @param languages     *            the languages that these rules will support     * @return a Lang encapsulating the loaded language-guessing rules.     */
/**     * Guesses the language of a word.     *     * @param text     *            the word     * @return the language that the word originates from or {@link Languages#ANY} if there was no unique match     */
/**     * Guesses the languages of a word.     *     * @param input     *            the word     * @return a Set of Strings of language names that are potential matches for the input word     */
/**     * Gets the short version of the name type.     *     * @return the NameType short string     */
/**     * Generates a new, fully-configured phonetic engine.     *     * @param nameType     *            the type of names it will use     * @param ruleType     *            the type of rules it will apply     * @param concat     *            if it will concatenate multiple encodings     */
/**     * Generates a new, fully-configured phonetic engine.     *     * @param nameType     *            the type of names it will use     * @param ruleType     *            the type of rules it will apply     * @param concat     *            if it will concatenate multiple encodings     */
/**         * An empty builder where all phonemes must come from some set of languages. This will contain a single         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new         * phoneme from scratch.         *         * @param languages the set of languages         * @return  a new, empty phoneme builder         */
/**         * Creates a new phoneme builder containing all phonemes in this one extended by <code>str</code>.         *         * @param str   the characters to append to the phonemes         */
/**         * Applies the given phoneme expression to all phonemes in this phoneme builder.         * <p>         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are         * incompatible.         *         * @param phonemeExpr   the expression to apply         * @param maxPhonemes   the maximum number of phonemes to build up         */
/**         * Gets underlying phoneme set. Please don't mutate.         *         * @return  the phoneme set         */
/**         * Stringifies the phoneme set. This produces a single string of the strings of each phoneme,         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially         * expensive operation, which should be avoided when debugging.         *         * @return  the stringified phoneme set         */
/**         * Invokes the rules. Loops over the rules list, stopping at the first one that has a matching context         * and pattern. Then applies this rule to the phoneme builder to produce updated phonemes. If there was no         * match, <code>i</code> is advanced one and the character is silently dropped from the phonetic spelling.         *         * @return <code>this</code>         */
/**     * Joins some strings with an internal separator.     * @param strings   Strings to join     * @param sep       String to separate them with     * @return a single String consisting of each element of <code>strings</code> interleaved by <code>sep</code>     */
/**     * Applies the final rules to convert from a language-specific phonetic representation to a     * language-independent representation.     *     * @param phonemeBuilder the current phonemes     * @param finalRules the final rules to apply     * @return the resulting phonemes     */
/**     * Encodes an input string into an output phonetic representation, given a set of possible origin languages.     *     * @param input     *            String to phoneticise; a String with dashes or spaces separating each word     * @param languageSet     *            set of possible origin languages     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations of the     *         input     */
/**     * Gets the Lang language guessing rules being used.     *     * @return the Lang in use     */
/**     * Gets the NameType being used.     *     * @return the NameType in use     */
/**     * Gets the RuleType being used.     *     * @return the RuleType in use     */
/**     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.     *     * @return true if multiple phonetic encodings are returned, false if just the first is     */
/**     * Gets the maximum number of phonemes the engine will calculate for a given input.     *     * @return the maximum number of phonemes     * @since 1.7     */
/**     * Creates a new rule.     *     * @param pattern     *            the pattern     * @param lContext     *            the left context     * @param rContext     *            the right context     * @param phoneme     *            the resulting phoneme     */
/**         * Returns a new Phoneme with the same text but a union of its         * current language set and the given one.         *         * @param lang the language set to merge         * @return a new Phoneme         */
/**     * Gets rules for a combination of name type, rule type and a single language.     *     * @param nameType     *            the NameType to consider     * @param rt     *            the RuleType to consider     * @param lang     *            the language to consider     * @return a list of Rules that apply     */
/**     * Gets rules for a combination of name type, rule type and a single language.     *     * @param nameType     *            the NameType to consider     * @param rt     *            the RuleType to consider     * @param lang     *            the language to consider     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern     * @since 1.9     */
/**     * Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.     *     * @param regex     *            the regular expression to compile     * @return an RPattern that will match this regex     */
/**     * Gets the left context. This is a regular expression that must match to the left of the pattern.     *     * @return the left context Pattern     */
/**     * Gets the pattern. This is a string-literal that must exactly match.     *     * @return the pattern     */
/**     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.     *     * @return the phoneme     */
/**     * Gets the right context. This is a regular expression that must match to the right of the pattern.     *     * @return the right context Pattern     */
/**     * Decides if the pattern and context match the input starting at a position. It is a match if the     * <code>lContext</code> matches <code>input</code> up to <code>i</code>, <code>pattern</code> matches at i and     * <code>rContext</code> matches from the end of the match of <code>pattern</code> to the end of <code>input</code>.     *     * @param input     *            the input String     * @param i     *            the int position within the input     * @return true if the pattern and left/right context match, false otherwise     */
/**     * Gets the rule name.     *     * @return the rule name.     */
/**     * Default constructor.     */
/**     * Constructor which allows for the selection of a default charset     *     * @param charset     *            the default string charset to use.     *     * @see <a href="http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html">Standard charsets</a>     * @since 1.7     */
/**     * Constructor which allows for the selection of a default charset     *     * @param charsetName     *            the default charset to use.     * @throws java.nio.charset.UnsupportedCharsetException     *             If the named charset is unavailable     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable     * @see <a href="http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html">Standard charsets</a>     */
/**     * Gets the default charset name used for string decoding and encoding.     *     * @return the default charset name     * @since 1.7     */
/**     * Gets the default charset name used for string decoding and encoding.     *     * @return the default charset name     */
/**     * Default constructor.     */
/**     * Constructor which allows for the selection of a default charset.     *     * @param charset     *            the default string charset to use.     *     * @see <a href="http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html">Standard charsets</a>     * @since 1.7     */
/**     * Constructor which allows for the selection of a default charset.     *     * @param charsetName     *            the charset to use.     * @throws java.nio.charset.UnsupportedCharsetException     *             If the named charset is unavailable     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable     * @see <a href="http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html">Standard charsets</a>     */
/**     * Tests if optional transformation of SPACE characters is to be used     *     * @return <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise     */
/**     * Defines whether optional transformation of SPACE characters is to be used     *     * @param b     *            <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise     */
/**     * Default constructor, assumes default charset of {@link Charsets#UTF_8}     */
/**     * Constructor which allows for the selection of the strict mode.     *     * @param strict     *            if {@code true}, soft line breaks will be used     * @since 1.10     */
/**     * Constructor which allows for the selection of a default charset.     *     * @param charset     *            the default string charset to use.     * @since 1.7     */
/**     * Constructor which allows for the selection of a default charset and strict mode.     *     * @param charset     *            the default string charset to use.     * @param strict     *            if {@code true}, soft line breaks will be used     * @since 1.10     */
/**     * Constructor which allows for the selection of a default charset.     *     * @param charsetName     *            the default string charset to use.     * @throws UnsupportedCharsetException     *             If no support for the named charset is available     *             in this instance of the Java virtual machine     * @throws IllegalArgumentException     *             If the given charsetName is null     * @throws IllegalCharsetNameException     *             If the given charset name is illegal     *     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable     */
/**     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.     * <p>     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in     * RFC 1521 and is suitable for encoding binary data and unformatted text.     *     * @param printable     *            bitset of characters deemed quoted-printable     * @param bytes     *            array of bytes to be encoded     * @param strict     *            if {@code true} the full ruleset is used, otherwise only rule #1 and rule #2     * @return array of bytes containing quoted-printable data     * @since 1.10     */
/**     * Return the byte at position <code>index</code> of the byte array and     * make sure it is unsigned.     *     * @param index     *            position in the array     * @param bytes     *            the byte array     * @return the unsigned octet at position <code>index</code> from the array     */
/**     * Write a byte to the buffer.     *     * @param b     *            byte to write     * @param encode     *            indicates whether the octet shall be encoded     * @param buffer     *            the buffer to write to     * @return the number of bytes that have been written to the buffer     */
/**     * Checks whether the given byte is whitespace.     *     * @param b     *            byte to be checked     * @return <code>true</code> if the byte is either a space or tab character     */
/**     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are converted     * back to their original representation.     * <p>     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as     * defined in RFC 1521.     *     * @param bytes     *            array of quoted-printable characters     * @return array of original bytes     * @throws DecoderException     *             Thrown if quoted-printable decoding is unsuccessful     */
/**     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.     * <p>     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in     * RFC 1521 and is suitable for encoding binary data and unformatted text.     *     * @param str     *            string to convert to quoted-printable form     * @param charset     *            the charset for str     * @return quoted-printable string     * @throws UnsupportedEncodingException     *             Thrown if the charset is not supported     */
/**     * Applies an RFC 1522 compliant encoding scheme to the given string of text with the given charset.     * <p>     * This method constructs the "encoded-word" header common to all the RFC 1522 codecs and then invokes     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific encoding.     *     * @param text     *            a string to encode     * @param charsetName     *            the charset to use     * @return RFC 1522 compliant "encoded-word"     * @throws EncoderException     *             thrown if there is an error condition during the Encoding process.     * @throws UnsupportedEncodingException     *             if charset is not available     *     * @see <a href="http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html">Standard charsets</a>     */
/**     * Applies an RFC 1522 compliant decoding scheme to the given string of text.     * <p>     * This method processes the "encoded-word" header common to all the RFC 1522 codecs and then invokes     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific decoding.     *     * @param text     *            a string to decode     * @return A new decoded String or <code>null</code> if the input is <code>null</code>.     * @throws DecoderException     *             thrown if there is an error condition during the decoding process.     * @throws UnsupportedEncodingException     *             thrown if charset specified in the "encoded-word" header is not supported     */
/**     * Default constructor.     */
/**     * Constructor which allows for the selection of a default charset.     *     * @param charset the default string charset to use.     */
/**     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.     *     * @param urlsafe     *            bitset of characters deemed URL safe     * @param bytes     *            array of bytes to convert to URL safe characters     * @return array of bytes containing URL safe characters     */
/**     * Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted     * back to their original representation.     *     * @param bytes     *            array of URL safe characters     * @return array of original bytes     * @throws DecoderException     *             Thrown if URL decoding is unsuccessful     */
/**     * The default charset used for string decoding and encoding.     *     * @return the default string charset.     */
/**     * Returns the numeric value of the character <code>b</code> in radix 16.     *     * @param b     *            The byte to be converted.     * @return The numeric value represented by the character in radix 16.     *     * @throws DecoderException     *             Thrown when the byte is not valid per {@link Character#digit(char,int)}     */
/**     * Close this input stream and release any associated system resources.     */
/**     * Returns true if standard input is empty.     * @return true if and only if standard input is empty     */
/**     * Reads the next bit of data from standard input and return as a boolean.     *     * @return the next bit of data from standard input as a {@code boolean}     * @throws NoSuchElementException if standard input is empty     */
/**     * Reads the next r bits from standard input and return as an r-bit character.     *     * @param  r number of bits to read.     * @return the next r bits of data from standard input as a {@code char}     * @throws NoSuchElementException if there are fewer than {@code r} bits available on standard input     * @throws IllegalArgumentException unless {@code 1 <= r <= 16}     */
/**     * Reads the remaining bytes of data from standard input and return as a string.      *     * @return the remaining bytes of data from standard input as a {@code String}     * @throws NoSuchElementException if standard input is empty or if the number of bits     *         available on standard input is not a multiple of 8 (byte-aligned)     */
/**     * Reads the next 16 bits from standard input and return as a 16-bit short.     *     * @return the next 16 bits of data from standard input as a {@code short}     * @throws NoSuchElementException if there are fewer than 16 bits available on standard input     */
/**     * Reads the next r bits from standard input and return as an r-bit int.     *     * @param  r number of bits to read.     * @return the next r bits of data from standard input as a {@code int}     * @throws NoSuchElementException if there are fewer than {@code r} bits available on standard input     * @throws IllegalArgumentException unless {@code 1 <= r <= 32}     */
/**     * Reads the next 64 bits from standard input and return as a 64-bit long.     *     * @return the next 64 bits of data from standard input as a {@code long}     * @throws NoSuchElementException if there are fewer than 64 bits available on standard input     */
/**     * Reads the next 64 bits from standard input and return as a 64-bit double.     *     * @return the next 64 bits of data from standard input as a {@code double}     * @throws NoSuchElementException if there are fewer than 64 bits available on standard input     */
/**     * Reads the next 32 bits from standard input and return as a 32-bit float.     *     * @return the next 32 bits of data from standard input as a {@code float}     * @throws NoSuchElementException if there are fewer than 32 bits available on standard input     */
/**     * Reads the next 8 bits from standard input and return as an 8-bit byte.     *     * @return the next 8 bits of data from standard input as a {@code byte}     * @throws NoSuchElementException if there are fewer than 8 bits available on standard input     */
/**     * Test client. Reads in a binary input file from standard input and writes     * it to standard output.     *     * @param args the command-line arguments     */
/**     * Writes the specified bit to standard output.     */
/**     * Writes the 8-bit byte to standard output.     */
/**     * Flushes standard output, padding 0s if number of bits written so far     * is not a multiple of 8.     */
/**     * Flushes and closes standard output. Once standard output is closed, you can no     * longer write bits to it.     */
/**     * Writes the string of r-bit characters to standard output.     * @param s the {@code String} to write.     * @param r the number of relevants bits in each character.     * @throws IllegalArgumentException if r is not between 1 and 16.     * @throws IllegalArgumentException if any character in the string is not     * between 0 and 2<sup>r</sup> - 1.     */
/**     * Tests the methods in this class.     *     * @param args the command-line arguments     */
/**     * Initializes an empty queue.     */
/**     * Returns true if this queue is empty.     *     * @return {@code true} if this queue is empty; {@code false} otherwise     */
/**     * Returns the number of items in this queue.     *     * @return the number of items in this queue     */
/**     * Returns the item least recently added to this queue.     *     * @return the item least recently added to this queue     * @throws NoSuchElementException if this queue is empty     */
/**     * Adds the item to this queue.     *     * @param  item the item to add     */
/**     * Removes and returns the item on this queue that was least recently added.     *     * @return the item on this queue that was least recently added     * @throws NoSuchElementException if this queue is empty     */
/**     * Returns a string representation of this queue.     *     * @return the sequence of items in FIFO order, separated by spaces     */
/**     * Returns an iterator that iterates over the items in this queue in FIFO order.     *     * @return an iterator that iterates over the items in this queue in FIFO order     */
/**     * Unit tests the {@code Queue} data type.     *     * @param args the command-line arguments     */
/**     * Returns true if standard input is empty (except possibly for whitespace).     * Use this method to know whether the next call to {@link #readString()},      * {@link #readDouble()}, etc will succeed.     *     * @return {@code true} if standard input is empty (except possibly     *         for whitespace); {@code false} otherwise     */
/**     * Returns true if standard input has a next line.     * Use this method to know whether the     * next call to {@link #readLine()} will succeed.     * This method is functionally equivalent to {@link #hasNextChar()}.     *     * @return {@code true} if standard input has more input (including whitespace);     *         {@code false} otherwise     */
/**     * Returns true if standard input has more input (including whitespace).     * Use this method to know whether the next call to {@link #readChar()} will succeed.     * This method is functionally equivalent to {@link #hasNextLine()}.     *     * @return {@code true} if standard input has more input (including whitespace);     *         {@code false} otherwise     */
/**     * Reads and returns the next line, excluding the line separator if present.     *     * @return the next line, excluding the line separator if present;     *         {@code null} if no such line     */
/**     * Reads and returns the next character.     *     * @return the next {@code char}     * @throws NoSuchElementException if standard input is empty     */
/**     * Reads and returns the remainder of the input, as a string.     *     * @return the remainder of the input, as a string     * @throws NoSuchElementException if standard input is empty     */
/**     * Reads the next token  and returns the {@code String}.     *     * @return the next {@code String}     * @throws NoSuchElementException if standard input is empty     */
/**     * Reads the next token from standard input, parses it as an integer, and returns the integer.     *     * @return the next integer on standard input     * @throws NoSuchElementException if standard input is empty     * @throws InputMismatchException if the next token cannot be parsed as an {@code int}     */
/**     * Reads the next token from standard input, parses it as a double, and returns the double.     *     * @return the next double on standard input     * @throws NoSuchElementException if standard input is empty     * @throws InputMismatchException if the next token cannot be parsed as a {@code double}     */
/**     * Reads the next token from standard input, parses it as a float, and returns the float.     *     * @return the next float on standard input     * @throws NoSuchElementException if standard input is empty     * @throws InputMismatchException if the next token cannot be parsed as a {@code float}     */
/**     * Reads the next token from standard input, parses it as a long integer, and returns the long integer.     *     * @return the next long integer on standard input     * @throws NoSuchElementException if standard input is empty     * @throws InputMismatchException if the next token cannot be parsed as a {@code long}     */
/**     * Reads the next token from standard input, parses it as a short integer, and returns the short integer.     *     * @return the next short integer on standard input     * @throws NoSuchElementException if standard input is empty     * @throws InputMismatchException if the next token cannot be parsed as a {@code short}     */
/**     * Reads the next token from standard input, parses it as a byte, and returns the byte.     *     * @return the next byte on standard input     * @throws NoSuchElementException if standard input is empty     * @throws InputMismatchException if the next token cannot be parsed as a {@code byte}     */
/**     * Reads the next token from standard input, parses it as a boolean,     * and returns the boolean.     *     * @return the next boolean on standard input     * @throws NoSuchElementException if standard input is empty     * @throws InputMismatchException if the next token cannot be parsed as a {@code boolean}:     *    {@code true} or {@code 1} for true, and {@code false} or {@code 0} for false,     *    ignoring case     */
/**     * Reads all remaining tokens from standard input and returns them as an array of strings.     *     * @return all remaining tokens on standard input, as an array of strings     */
/**     * Reads all remaining lines from standard input and returns them as an array of strings.     * @return all remaining lines on standard input, as an array of strings     */
/**     * Reads all remaining tokens from standard input, parses them as integers, and returns     * them as an array of integers.     * @return all remaining integers on standard input, as an array     * @throws InputMismatchException if any token cannot be parsed as an {@code int}     */
/**     * Reads all remaining tokens from standard input, parses them as longs, and returns     * them as an array of longs.     * @return all remaining longs on standard input, as an array     * @throws InputMismatchException if any token cannot be parsed as a {@code long}     */
/**     * Reads all remaining tokens from standard input, parses them as doubles, and returns     * them as an array of doubles.     * @return all remaining doubles on standard input, as an array     * @throws InputMismatchException if any token cannot be parsed as a {@code double}     */
/**     * If StdIn changes, use this to reinitialize the scanner.     */
/**     * Interactive test of basic functionality.     *     * @param args the command-line arguments     */
/**     * Prints a byte to standard output and then terminates the line.     * <p>     * To write binary data, see {@link BinaryStdOut}.     *     * @param x the byte to print     */
/**     * Prints a byte to standard output and flushes standard output.     *     * @param x the byte to print     */
/**     * Prints a formatted string to standard output, using the locale and     * the specified format string and arguments; then flushes standard output.     *     * @param locale the locale     * @param format the <a href = "http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax">format string</a>     * @param args   the arguments accompanying the format string     */
/**     * Returns the number of key-value pairs in this symbol table.     * @return the number of key-value pairs in this symbol table     */
/**     * Does this symbol table contain the given key?     * @param key the key     * @return {@code true} if this symbol table contains {@code key} and     *     {@code false} otherwise     * @throws IllegalArgumentException if {@code key} is {@code null}     */
/**     * Returns the string in the symbol table that is the longest prefix of {@code query},     * or {@code null}, if no such string.     * @param query the query string     * @return the string in the symbol table that is the longest prefix of {@code query},     *     or {@code null} if no such string     * @throws IllegalArgumentException if {@code query} is {@code null}     */
/**     * Returns all keys in the symbol table as an {@code Iterable}.     * To iterate over all of the keys in the symbol table named {@code st},     * use the foreach notation: {@code for (Key key : st.keys())}.     * @return all keys in the symbol table as an {@code Iterable}     */
/**     * Returns all of the keys in the set that start with {@code prefix}.     * @param prefix the prefix     * @return all of the keys in the set that start with {@code prefix},     *     as an iterable     * @throws IllegalArgumentException if {@code prefix} is {@code null}     */
/**     * Returns all of the keys in the symbol table that match {@code pattern},     * where . symbol is treated as a wildcard character.     * @param pattern the pattern     * @return all of the keys in the symbol table that match {@code pattern},     *     as an iterable, where . is treated as a wildcard character.     */
/**     * Unit tests the {@code TST} data type.     *     * @param args the command-line arguments     */
/**     * Writes the specified bit to standard output.     */
