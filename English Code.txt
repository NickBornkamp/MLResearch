        public void addObject(DrawableObject d){            drawableObjects.add(d);        }
        public void removeObject(DrawableObject d){            drawableObjects.remove(d);        }
        public void keyPressed(KeyEvent e){            Iterator<DrawableObject> iterator = drawableObjects.iterator();            while (iterator.hasNext()){                DrawableObject tempDO = iterator.next();                if (tempDO instanceof InteractableObject){                    ((InteractableObject)tempDO).keyPressed(e.getKeyCode());                }            }        }
        public void keyReleased(KeyEvent e){            Iterator<DrawableObject> iterator = drawableObjects.iterator();            while (iterator.hasNext()){                DrawableObject tempDO = iterator.next();                if (tempDO instanceof InteractableObject){                    ((InteractableObject)tempDO).keyReleased(e.getKeyCode());                }            }        }
        public void mousePressed(MouseEvent e) {        }
        public void mouseReleased(MouseEvent e) {            Iterator<DrawableObject> iterator = drawableObjects.iterator();            while (iterator.hasNext()){                DrawableObject tempDO = iterator.next();                if (tempDO instanceof InteractableObject){                    ((InteractableObject)tempDO).mouseReleased(e);                }            }        }
        public void mouseEntered(MouseEvent e) {        }
        public void mouseExited(MouseEvent e) {        }
        public void mouseClicked(MouseEvent e) {        }
public MainFrame(String name, int x, int y, int width, int height) {        panels = new ArrayList<>();        activePanel = new DrawingPanel();        panels.add(activePanel);        add(activePanel);        addKeyListener(activePanel);        setLocation(x,y);        setSize(width,height);        setTitle(name);        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        setVisible(true);    }
    public static ServerResponse createServerResponseByError(Integer status,String msg){        return new ServerResponse(status,msg);    }
    public Integer getId() {        return id;    }
    public void setId(Integer id) {        this.id = id;    }
    public Integer getChecked() {        return checked;    }
    public void setChecked(Integer checked) {        this.checked = checked;    }
    public Date getCreateTime() {        return createTime;    }
    public void setCreateTime(Date createTime) {        this.createTime = createTime;    }
    public Date getUpdateTime() {        return updateTime;    }
    public void setUpdateTime(Date updateTime) {        this.updateTime = updateTime;    }
    public Integer getId() {        return id;    }
    public void setId(Integer id) {        this.id = id;    }
    public Integer getParentId() {        return parentId;    }
    public void setParentId(Integer parentId) {        this.parentId = parentId;    }
    public String getName() {        return name;    }
    public void setName(String name) {        this.name = name == null ? null : name.trim();    }
    public Integer getStatus() {        return status;    }
    public void setStatus(Integer status) {        this.status = status;    }
    public Integer getSortOrder() {        return sortOrder;    }
    public void setSortOrder(Integer sortOrder) {        this.sortOrder = sortOrder;    }
    public Date getCreateTime() {        return createTime;    }
    public Date getUpdateTime() {        return updateTime;    }
    public void setUpdateTime(Date updateTime) {        this.updateTime = updateTime;    }
    public Integer getId() {        return id;    }
    public void setId(Integer id) {        this.id = id;    }
    public Integer getUserId() {        return userId;    }
    public void setUserId(Integer userId) {        this.userId = userId;    }
    public Long getOrderNo() {        return orderNo;    }
    public void setOrderNo(Long orderNo) {        this.orderNo = orderNo;    }
    public Integer getShippingId() {        return shippingId;    }
    public void setShippingId(Integer shippingId) {        this.shippingId = shippingId;    }
    public BigDecimal getPayment() {        return payment;    }
    public void setPayment(BigDecimal payment) {        this.payment = payment;    }
    public Integer getPaymentType() {        return paymentType;    }
    public void setPaymentType(Integer paymentType) {        this.paymentType = paymentType;    }
    public Integer getPostage() {        return postage;    }
    public void setPostage(Integer postage) {        this.postage = postage;    }
    public Integer getStatus() {        return status;    }
    public void setStatus(Integer status) {        this.status = status;    }
    public Date getPaymentTime() {        return paymentTime;    }
    public void setPaymentTime(Date paymentTime) {        this.paymentTime = paymentTime;    }
    public Date getSendTime() {        return sendTime;    }
    public void setSendTime(Date sendTime) {        this.sendTime = sendTime;    }
    public Date getEndTime() {        return endTime;    }
    public void setEndTime(Date endTime) {        this.endTime = endTime;    }
    public Date getCloseTime() {        return closeTime;    }
    public void setCloseTime(Date closeTime) {        this.closeTime = closeTime;    }
    public Date getCreateTime() {        return createTime;    }
    public void setCreateTime(Date createTime) {        this.createTime = createTime;    }
    public Date getUpdateTime() {        return updateTime;    }
    public void setUpdateTime(Date updateTime) {        this.updateTime = updateTime;    }
    public Integer getId() {        return id;    }
    public void setId(Integer id) {        this.id = id;    }
    public Integer getUserId() {        return userId;    }
    public void setUserId(Integer userId) {        this.userId = userId;    }
    public Long getOrderNo() {        return orderNo;    }
    public void setOrderNo(Long orderNo) {        this.orderNo = orderNo;    }
    public Integer getProductId() {        return productId;    }
    public void setProductId(Integer productId) {        this.productId = productId;    }
    public String getProductName() {        return productName;    }
    public void setProductName(String productName) {        this.productName = productName == null ? null : productName.trim();    }
    public String getProductImage() {        return productImage;    }
    public void setProductImage(String productImage) {        this.productImage = productImage == null ? null : productImage.trim();    }
    public BigDecimal getCurrentUnitPrice() {        return currentUnitPrice;    }
    public void setCurrentUnitPrice(BigDecimal currentUnitPrice) {        this.currentUnitPrice = currentUnitPrice;    }
    public Integer getQuantity() {        return quantity;    }
    public void setTotalPrice(BigDecimal totalPrice) {        this.totalPrice = totalPrice;    }
    public void setPlatformNumber(String platformNumber) {        this.platformNumber = platformNumber == null ? null : platformNumber.trim();    }
    public String getPlatformStatus() {        return platformStatus;    }
    public void setPlatformStatus(String platformStatus) {        this.platformStatus = platformStatus == null ? null : platformStatus.trim();    }
    public Date getCreateTime() {        return createTime;    }
    public void setCreateTime(Date createTime) {        this.createTime = createTime;    }
    public Date getUpdateTime() {        return updateTime;    }
    public void setUpdateTime(Date updateTime) {        this.updateTime = updateTime;    }
    public Integer getId() {        return id;    }
    public void setId(Integer id) {        this.id = id;    }
    public Integer getCategoryId() {        return categoryId;    }
    public void setCategoryId(Integer categoryId) {        this.categoryId = categoryId;    }
    public String getName() {        return name;    }
    public void setName(String name) {        this.name = name == null ? null : name.trim();    }
    public String getSubtitle() {        return subtitle;    }
    public void setSubtitle(String subtitle) {        this.subtitle = subtitle == null ? null : subtitle.trim();    }
    public String getMainImage() {        return mainImage;    }
    public void setMainImage(String mainImage) {        this.mainImage = mainImage == null ? null : mainImage.trim();    }
    public BigDecimal getPrice() {        return price;    }
    public void setPrice(BigDecimal price) {        this.price = price;    }
    public Integer getStock() {        return stock;    }
    public void setStock(Integer stock) {        this.stock = stock;    }
    public Integer getStatus() {        return status;    }
    public void setStatus(Integer status) {        this.status = status;    }
    public Date getCreateTime() {        return createTime;    }
    public void setCreateTime(Date createTime) {        this.createTime = createTime;    }
    public Date getUpdateTime() {        return updateTime;    }
    public void setUpdateTime(Date updateTime) {        this.updateTime = updateTime;    }
    public String getSubImages() {        return subImages;    }
    public void setSubImages(String subImages) {        this.subImages = subImages == null ? null : subImages.trim();    }
    public String getDetail() {        return detail;    }
    public void setDetail(String detail) {        this.detail = detail == null ? null : detail.trim();    }
    public String getReceiverName() {        return receiverName;    }
    public String getReceiverPhone() {        return receiverPhone;    }
    public void setReceiverPhone(String receiverPhone) {        this.receiverPhone = receiverPhone == null ? null : receiverPhone.trim();    }
    public void setReceiverMobile(String receiverMobile) {        this.receiverMobile = receiverMobile == null ? null : receiverMobile.trim();    }
    public void setReceiverProvince(String receiverProvince) {        this.receiverProvince = receiverProvince == null ? null : receiverProvince.trim();    }
    public String getReceiverCity() {        return receiverCity;    }
    public String getReceiverDistrict() {        return receiverDistrict;    }
    public void setReceiverDistrict(String receiverDistrict) {        this.receiverDistrict = receiverDistrict == null ? null : receiverDistrict.trim();    }
    public String getReceiverAddress() {        return receiverAddress;    }
    public void setReceiverAddress(String receiverAddress) {        this.receiverAddress = receiverAddress == null ? null : receiverAddress.trim();    }
    public String getReceiverZip() {        return receiverZip;    }
    public void setReceiverZip(String receiverZip) {        this.receiverZip = receiverZip == null ? null : receiverZip.trim();    }
    public Date getCreateTime() {        return createTime;    }
    public void setCreateTime(Date createTime) {        this.createTime = createTime;    }
    public Date getUpdateTime() {        return updateTime;    }
    public void setUpdateTime(Date updateTime) {        this.updateTime = updateTime;    }
    public Integer getId() {        return id;    }
    public void setId(Integer id) {        this.id = id;    }
    public String getUsername() {        return username;    }
    public void setUsername(String username) {        this.username = username == null ? null : username.trim();    }
    public String getPassword() {        return password;    }
    public void setPassword(String password) {        this.password = password == null ? null : password.trim();    }
    public String getEmail() {        return email;    }
    public void setEmail(String email) {        this.email = email == null ? null : email.trim();    }
    public String getPhone() {        return phone;    }
    public void setPhone(String phone) {        this.phone = phone == null ? null : phone.trim();    }
    public String getQuestion() {        return question;    }
    public void setQuestion(String question) {        this.question = question == null ? null : question.trim();    }
    public String getAnswer() {        return answer;    }
    public void setAnswer(String answer) {        this.answer = answer == null ? null : answer.trim();    }
    public Integer getRole() {        return role;    }
    public void setRole(Integer role) {        this.role = role;    }
    public Date getCreateTime() {        return createTime;    }
    public void setCreateTime(Date createTime) {        this.createTime = createTime;    }
    public Date getUpdateTime() {        return updateTime;    }
    public void setUpdateTime(Date updateTime) {        this.updateTime = updateTime;    }
    public String getIp() {        return ip;    }
    public void setIp(String ip) {        this.ip = ip == null ? null : ip.trim();    }
    private CartVO getCartVOLimit(Integer userId){        CartVO cartVO = new CartVO();                List<Cart> cartList = cartMapper.selectCartByUserId(userId);                List<CartProductVO> cartProductVOList = Lists.newArrayList();                BigDecimal carttotalprice=new BigDecimal("");        if (cartList!=null||cartList.size()>0){            for (Cart cart:cartList){                CartProductVO cartProductVO = new CartProductVO();                cartProductVO.setId(cart.getId());                cartProductVO.setQuantity(cart.getQuantity());                cartProductVO.setUserId(cart.getUserId());                cartProductVO.setProductChecked(cart.getChecked());                                Product product = productMapper.selectByPrimaryKey(cart.getProductId());                if (product!=null){                    cartProductVO.setProductId(cart.getProductId());                    cartProductVO.setProductMainImage(product.getMainImage());                    cartProductVO.setProductName(product.getName());                    cartProductVO.setProductPrice(product.getPrice());                    cartProductVO.setProductStatus(product.getStatus());                    cartProductVO.setProductStock(product.getStock());                    cartProductVO.setProductSubtitle(product.getSubtitle());                    int stock = product.getStock();                    int limitProductCount=0;                    if (stock>=cart.getQuantity()){                        limitProductCount=cart.getQuantity();                        cartProductVO.setLimitQuantity("");                    }else {                                                limitProductCount=stock;                                                Cart cart1 = new Cart();                        cart1.setId(cart.getId());                        cart1.setQuantity(stock);                        cart1.setProductId(cart.getProductId());                        cart1.setChecked(cart.getChecked());                        cart1.setUserId(userId);                        cartMapper.updateByPrimaryKey(cart1);                        cartProductVO.setLimitQuantity("");                    }                    cartProductVO.setQuantity(limitProductCount);                    cartProductVO.setProductTotalPrice(BigDecimalUtils.mul(product.getPrice().doubleValue(),                            Double.valueOf(cartProductVO.getQuantity())));                }                                if (cartProductVO.getProductChecked()==Const.CartCheckedEnum.PRODUCT_CHECKED.getCode()){                                       carttotalprice = BigDecimalUtils.add(carttotalprice.doubleValue(), cartProductVO.getProductTotalPrice().doubleValue());                }                cartProductVOList.add(cartProductVO);            }        }        cartVO.setCartProductVOList(cartProductVOList);                cartVO.setCarttotalprice(carttotalprice);                int count = cartMapper.isCheckedAll(userId);        if (count>0){            cartVO.setIsallchecked(false);        }else {            cartVO.setIsallchecked(true);        }                return cartVO;    }
    private Order createOrder(Integer userId, Integer shippingId, BigDecimal orderTotalPrice) {        Order order = new Order();        order.setOrderNo(generateOrderNo());        order.setUserId(userId);        order.setShippingId(shippingId);        order.setStatus(Const.OrderStatusEnum.ORDER_UN_PAY.getCode());                order.setPayment(orderTotalPrice);        order.setPostage(0);         order.setPaymentType(Const.PaymentEnum.ONLINE.getCode());                int insert = orderMapper.insert(order);        if (insert > 0) {            return order;        }        return null;    }
    private OrderVO assembleOrderVO(Order order, List<OrderItem> orderItemList, Integer shippingId) {        OrderVO orderVO = new OrderVO();        List<OrderItemVO> orderItemVOList = Lists.newArrayList();        for (OrderItem orderItem : orderItemList) {            OrderItemVO orderItemVO = assembleOrderItemVO(orderItem);            orderItemVOList.add(orderItemVO);        }        orderVO.setOrderItemVOList(orderItemVOList);        orderVO.setImageHost(PropertiesUtils.readByKey(""));        Shipping shipping = shippingMapper.selectByPrimaryKey(shippingId);        if (shipping != null) {            orderVO.setShippingId(shippingId);            ShippingVO shippingVO = assembleShippingVO(shipping);            orderVO.setShippingVO(shippingVO);            orderVO.setReceiverName(shipping.getReceiverName());        }        orderVO.setStatus(order.getStatus());        Const.OrderStatusEnum orderStatusEnum = Const.OrderStatusEnum.codeof(order.getStatus());        if (orderStatusEnum != null) {            orderVO.setStatusDesc(orderStatusEnum.getDesc());            orderVO.setPostage(0);            orderVO.setPayment(order.getPayment());            orderVO.setPaymentType(order.getPaymentType());            Const.PaymentEnum paymentEnum = Const.PaymentEnum.codeof(order.getPaymentType());            if (paymentEnum != null) {                orderVO.setPaymentTypeDesc(paymentEnum.getDesc());            }            orderVO.setOrderNo(order.getOrderNo());        }        return orderVO;    }
    private void cleanCart(List<Cart> cartList) {        if (cartList != null && cartList.size() > 0) {            cartMapper.batchDelete(cartList);        }    }
    private void reduceProductStock(List<OrderItem> orderItemList) {        if (orderItemList != null && orderItemList.size() > 0) {            for (OrderItem orderItem : orderItemList) {                Integer productId = orderItem.getProductId();                Integer quantity = orderItem.getQuantity();                Product product = productMapper.selectByPrimaryKey(productId);                product.setStock(product.getStock() - quantity);                productMapper.updateByPrimaryKey(product);            }        }    }
    private BigDecimal getOrderPrice(List<OrderItem> orderItemList) {        BigDecimal bigDecimal = new BigDecimal("");        for (OrderItem orderItem : orderItemList) {            bigDecimal = BigDecimalUtils.add(bigDecimal.doubleValue(), orderItem.getTotalPrice().doubleValue());        }        return bigDecimal;    }
    private Long generateOrderNo() {                return System.currentTimeMillis() + new Random().nextInt(100);            }
    private ServerResponse getCartOrderItem(Integer userId, List<Cart> cartList) {        if (cartList == null || cartList.size() == 0) {            return ServerResponse.createServerResponseByError("");        }        List<OrderItem> orderItemList = Lists.newArrayList();        for (Cart cart : cartList) {            OrderItem orderItem = new OrderItem();            orderItem.setUserId(userId);            Product product = productMapper.selectByPrimaryKey(cart.getProductId());            if (product == null) {                return ServerResponse.createServerResponseByError("" + cart.getProductId() + "");            }            if (product.getStatus() != Const.ProductStatusEnum.PRODUCT_ONLINE.getCode()) {                                return ServerResponse.createServerResponseByError("" + product.getId() + "");            }            if (product.getStock() < cart.getQuantity()) {                                return ServerResponse.createServerResponseByError("" + product.getId() + "");            }            orderItem.setQuantity(cart.getQuantity());            orderItem.setCurrentUnitPrice(product.getPrice());            orderItem.setProductId(product.getId());            orderItem.setProductImage(product.getMainImage());            orderItem.setProductName(product.getName());            orderItem.setTotalPrice(BigDecimalUtils.mul(product.getPrice().doubleValue(), cart.getQuantity().doubleValue()));            orderItemList.add(orderItem);        }        return ServerResponse.createServerResponseBySuccess(null, orderItemList);    }
    public ServerResponse login(String username, String password) {                if(username==null||username.equals("")){            return ServerResponse.createServerResponseByError("");        }        if(password==null||password.equals("")){            return ServerResponse.createServerResponseByError("");        }                int result = userInfoMapper.checkUsername(username);        if (result <= 0){            return ServerResponse.createServerResponseByError("");        }                UserInfo userInfo = userInfoMapper.selectUserInfoByUsernameAndPassword(username,MD5Utils.getMD5Code(password));        if(userInfo==null){            return ServerResponse.createServerResponseByError("");        }                userInfo.setPassword("");        return ServerResponse.createServerResponseBySuccess(null,userInfo);    }
    public ServerResponse register(UserInfo userInfo) {                if (userInfo==null){            return ServerResponse.createServerResponseByError("");        }                int result = userInfoMapper.checkUsername(userInfo.getUsername());        if (result >0){            return ServerResponse.createServerResponseByError("");        }                int result_email = userInfoMapper.checkEmail(userInfo.getEmail());        if (result_email>0){             return ServerResponse.createServerResponseByError("");    }                userInfo.setRole(Const.RoleEnum.ROLE_CUSTOMER.getCode());        userInfo.setPassword(MD5Utils.getMD5Code(userInfo.getPassword()));        int count = userInfoMapper.insert(userInfo);        if (count>0){            return ServerResponse.createServerResponseBySuccess("");        }                return ServerResponse.createServerResponseByError("");    }
    public ServerResponse forget_get_question(String username) {                if (username==null||username.equals("")){            return ServerResponse.createServerResponseByError("");        }                int result = userInfoMapper.checkUsername(username);        if (result==0){                        return ServerResponse.createServerResponseByError("");        }                String question = userInfoMapper.selectQuestionByUsername(username);        if (question==null||question.equals("")){            return ServerResponse.createServerResponseByError("");        }        return ServerResponse.createServerResponseBySuccess(question);    }
    public static BigDecimal add(double d1,double d2){        BigDecimal bigDecimal = new BigDecimal(String.valueOf(d1));        BigDecimal bigDecimal1 = new BigDecimal(String.valueOf(d2));        return bigDecimal.add(bigDecimal1);    }
    public static BigDecimal sub(double d1,double d2){        BigDecimal bigDecimal = new BigDecimal(String.valueOf(d1));        BigDecimal bigDecimal1 = new BigDecimal(String.valueOf(d2));        return bigDecimal.subtract(bigDecimal1);    }
    public static BigDecimal mul(double d1,double d2){        BigDecimal bigDecimal = new BigDecimal(String.valueOf(d1));        BigDecimal bigDecimal1 = new BigDecimal(String.valueOf(d2));        return bigDecimal.multiply(bigDecimal1);    }
    public static BigDecimal div(double d1,double d2){        BigDecimal bigDecimal = new BigDecimal(String.valueOf(d1));        BigDecimal bigDecimal1 = new BigDecimal(String.valueOf(d2));        return bigDecimal.divide(bigDecimal1,2,BigDecimal.ROUND_HALF_UP);    }
    public boolean uploadFile(String remotePath,List<File> fileList,FTPUtils ftpUtils) throws IOException {        InputStream inputStream =null;                if(connectFTPServer(ftpUtils)){            try {                ftpClient.changeWorkingDirectory(remotePath);                ftpClient.setBufferSize(1024);                ftpClient.setControlEncoding("");                ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);                ftpClient.enterLocalPassiveMode();                for (File file:fileList) {                    inputStream = new FileInputStream(file);                    ftpClient.storeFile(file.getName(),inputStream);                }                System.out.println("");                return true;            } catch (IOException e) {                e.printStackTrace();                System.out.println("");            }finally {                if(null != inputStream){                    inputStream.close();                }                if(null != ftpClient){                    ftpClient.disconnect();                }            }        }        return false;    }
  public static String getMD5Code(String strObj) {    String resultString = null;    try {            resultString = new String(strObj+"");      MessageDigest md = MessageDigest.getInstance("");            resultString = byteToString(md.digest(strObj.getBytes()));    } catch (NoSuchAlgorithmException ex) {      ex.printStackTrace();    }    return resultString;  }
    public static String readByKey(String key){        return properties.getProperty(key);    }
public static ArrayList<InsuranceScore> memberScoreAsessor(ArrayList<Health> memberData){ArrayList<InsuranceScore> assessment = new ArrayList<InsuranceScore>();for (Health h: memberData) {InsuranceScore assess = new InsuranceScore(h.getFname().trim(),h.getLname().trim(),addScoreForMembers(h)); assessment.add(assess);}return assessment;}
public static int addScoreForMembers(Health h) {int riskLevel =0; double bmi=0;bmi = ((double)(h.getWeight())/ (h.getHeight()* h.getHeight()))*703;{if (bmi>=18.5 && bmi <= 24.9)  {riskLevel = riskLevel +0;  }else if (bmi>=25.0 && bmi <= 29.9)   {riskLevel = riskLevel +30;  }else   {riskLevel = riskLevel + 75;  }}         {   if (h.getBpSystolic() < 120 && h.getBpDiastolic() <80)  {riskLevel = riskLevel + 0;  }else if ((h.getBpSystolic() >= 120 && h.getBpSystolic() <=129) && h.getBpDiastolic() < 80)  {riskLevel = riskLevel + 15;  }else if (h.getBpSystolic() >= 130 && h.getBpSystolic() <=139 || (h.getBpDiastolic() >=80 && h.getBpDiastolic() <=89))  {riskLevel = riskLevel+ 30;  }else if (h.getBpSystolic() >= 140 || h.getBpDiastolic() >=90)   {riskLevel = riskLevel+ 75;  }else if (h.getBpSystolic() >= 180 || h.getBpDiastolic() >=120){riskLevel = riskLevel+100;}     }     {      if(h.getAge() >= 30 && h.getAge() < 45)     {riskLevel = riskLevel+10;    } else if (h.getAge() >= 45&& h.getAge() < 60)     { riskLevel = riskLevel+20;    } else if (h.getAge()>=60)    { riskLevel = riskLevel+30;     }     }     {  if (h.getCancer().contentEquals(""))      {     riskLevel = riskLevel+10;     }   if (h.getDiabetes().contentEquals(""))      {     riskLevel = riskLevel + 10;     }   if (h.getAlzheimers().contentEquals(""))      {     riskLevel = riskLevel + 10;     }      }     return riskLevel;}
public Health () {fname ="";lname ="";age =0;height=0;weight=0;bpSystolic=0;bpDiastolic=0;cancer="";diabetes="";alzheimers="";}
public Health(String fname, String lname, String age, String height, String weight, String bpSystolic, String bpDiastolic, String cancer, 
    public String getFname() {return fname;}
public InsuranceScore(String fname, String lname, int score) {setFname(fname);setLname(lname);setScore(score);    if (score <= 20)     { riskLevel = "";    }    else if (score > 20 && score <=50)    {riskLevel = "";    }    else if (getScore() > 50 && score <=75)    {riskLevel = "";    }    else {riskLevel = "";    }}
public InsuranceScore() {fname="";lname="";score=0;riskLevel ="";}
public String toString() {String str = "";String firstLast = lname + ""+ fname;String scoreString = "" + score;return String.format(""+"" +"",firstLast, scoreString, riskLevel);}
public static void writeRiskInformation(ArrayList<InsuranceScore> assess) {for (InsuranceScore ins: assess){System.out.println(ins);}}
public static boolean writeMembersToJSON(String fname, ArrayList<InsuranceScore> assessment) {    try {            PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(fname)));        JSONObject memObj;    JSONArray jray= new JSONArray();         for (InsuranceScore ins :assessment) {        memObj = new JSONObject();            memObj.put("",ins.getFname());    memObj.put("", ins.getLname());    memObj.put("", ins.getScore());    memObj.put("", ins.getRiskLevel());        jray.add(memObj);    }              JSONObject out = new JSONObject();    out.put("", jray);         pw.println(out.toJSONString());      pw.close();    return true;    }catch(Exception ex) {    return false;    }}
public static ArrayList<Health> insuranceFileReader(String fname) {     try {      ArrayList<Health> memberData = new ArrayList<Health>();             Scanner fsc = new Scanner(new File(fname));                String line;                while (fsc.hasNextLine())          {            line = fsc.nextLine().trim();             String[] lineparts = line.split("");                       Health member = new Health( lineparts[0],lineparts[1],lineparts[2],lineparts[3],lineparts[4],lineparts[5],           lineparts[6],lineparts[7],lineparts[8], lineparts[9]);                      memberData.add(member);         }         fsc.close();         return memberData;                 } catch (Exception ex)     {        return null;     }}
public static ArrayList<Health> readMemberDataFromBinary(String fname){try {ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fname));ArrayList <Health> result = (ArrayList<Health>)ois.readObject();ois.close();return result;}catch (Exception ex) {return null;}}
public static ArrayList<Health> readMemberDataFromXml(String fname){try {XMLDecoder xml = new XMLDecoder(new BufferedInputStream(new FileInputStream(fname)));ArrayList <Health> result = (ArrayList<Health>)xml.readObject();xml.close();return result;} catch (Exception ex) {return null;}}
public static void printMembers(ArrayList<Health> memberData) {for (Health h: memberData) {System.out.println(h);}}
public static boolean saveMembertoText(String fname, ArrayList<Health> memberData) {    try {PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(new File(fname))));for (Health m:memberData) {pw.println(m.getFname()+""+ m.getLname()+"" + m.getAge()+ ""+ m.getHeight()+ ""+m.getWeight()+"" +m.getBpSystolic() +""+ m.getBpDiastolic() + ""+ m.getCancer()+"" +m.getDiabetes() +""+m.getAlzheimers());}pw.close();  return true;        } catch (Exception ex) {      return false;        }}
public static boolean saveMembertoBinary(String fname, ArrayList<Health> memberData)     {    try {              ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(fname)));            oos.writeObject(memberData);              oos.close();            return true;                 } catch (Exception ex)     {              return false;             }    }
    public static boolean saveStudentsToXML(String fname, ArrayList<Health> memberData )     {            try {                XMLEncoder xml = new XMLEncoder(new BufferedOutputStream(new FileOutputStream(fname)));                xml.writeObject(memberData);                xml.close();                           return true;                       } catch (Exception ex)             {                return false;            }        }
public static void welcome() {System.out.println("");System.out.println("");System.out.println("");System.out.println("");System.out.println("");System.out.println("");System.out.println("");System.out.println("");System.out.println("");System.out.println("");}
public static void showMenu() {System.out.println("");System.out.println("");System.out.println("");System.out.println("");System.out.println("");System.out.println("");System.out.println("");System.out.println("");System.out.print("");}
public static void addMember(ArrayList<Health> memberData) {Scanner sc = new Scanner(System.in);String fname,lname,age,weight,height,bpSys,bpDias,cancer, diabetes, alzheimers;Health hlt;System.out.print("");fname = sc.nextLine().trim();System.out.print("");lname = sc.nextLine().trim();System.out.print("");age= sc.nextLine().trim();System.out.print("");height = sc.nextLine().trim();System.out.print("");weight = sc.nextLine().trim();System.out.print("");bpSys= sc.nextLine();String [] lineparts = bpSys.split("");bpSys = lineparts[0];bpDias= lineparts[1];System.out.println("");    System.out.print("");    cancer = sc.nextLine().trim();        System.out.print("");    diabetes = sc.nextLine().trim();        System.out.print("");    alzheimers = sc.nextLine().trim();hlt = new Health(fname,lname,age,height, weight,bpSys, bpDias, cancer, diabetes, alzheimers );memberData.add(hlt);System.out.println("");}
public static void main (String[] args) {String fname;int choice;String type;try {Scanner sc = new Scanner(System.in);welcome();  System.out.print("");   fname = sc.next();ArrayList<Health> memberData = MemberReader.insuranceFileReader(fname);  ArrayList<InsuranceScore> assessment = Assessor.memberScoreAsessor(memberData);if (memberData==null)  {System.out.println("");}else {do {showMenu(); choice = sc.nextInt();if (choice==1) {MemberWriter.printMembers(memberData); }else if (choice ==2 ) {addMember(memberData); }else if (choice==3){System.out.print("");type = sc.next();if (type.equals("") || type.equals("")) {System.out.print("");fname = sc.next();if (MemberWriter.saveMembertoText(fname, memberData)) {System.out.println("");}else System.out.println("");}else if (type.contentEquals("") || type.contentEquals("")){System.out.print("");fname = sc.next();if (MemberWriter.saveMembertoBinary(fname, memberData)){System.out.println("");}else System.out.println("");}else if (type.contentEquals("") || type.contentEquals("")){System.out.print("");fname = sc.next();if (MemberWriter.saveStudentsToXML(fname, memberData)) {System.out.println("");}else {System.out.println("");}}}else if (choice==4) {System.out.print("");type = sc.next();if (type.contentEquals("") || type.contentEquals("")) {System.out.print("");fname = sc.next();ArrayList<Health> readBackBinary = MemberReader.readMemberDataFromBinary(fname);if (readBackBinary == null) {System.out.println("");}else {System.out.println(readBackBinary.size()+"");}}else if (type.contentEquals("") || type.contentEquals("")){System.out.print("");fname = sc.next();ArrayList<Health> readBackXml = MemberReader.readMemberDataFromXml(fname);if (readBackXml==null) {System.out.println("");}else {System.out.println(readBackXml.size() +"");}}else if (type.equals("") || type.equals("")){System.out.print("");fname = sc.next();ArrayList<Health> readBackText = MemberReader.insuranceFileReader(fname);if (readBackText== null) {System.out.println("");}else {System.out.println(readBackText.size() + "");}}}else if (choice==5) {System.out.println("");for (InsuranceScore ins: Assessor.memberScoreAsessor(memberData)) {System.out.print(ins);}}else if (choice==6) {System.out.print("");fname = sc.next();      if (InsuranceScoreWriter.writeMembersToJSON(fname, assessment)) {System.out.println("");}else {System.out.println("");}}} while(choice!= 7 ); {System.out.println("");System.out.println("");System.out.println("");System.out.println("");System.out.println("");System.out.println("");}}} catch (Exception ex)       {System.out.println("");      }}
    public static void geneseegame() {    Playgame(hole_g, yardage_g, par_g);}
public static void oldCoursegame() {Playgame(hole_o, yardage_o, par_o);}
    public static void mastergame() {    Playgame(hole_m, yardage_m, par_m);}
public static void lovegame() {Scanner scnr = new Scanner(System.in);Course play1 = new Course();System.out.print(""+""+""+"" +""+""         +"");System.out.print("");int courseNum = scnr.nextInt();if (courseNum == 1) {System.out.println("");play1.geneseegame();  }else if (courseNum == 2) {System.out.println("");play1.oldCoursegame();  }else if (courseNum == 3) {System.out.println("");play1.mastergame();  }else {System.out.print("");}}
public Controller(Model model) {this.model = model;this.vue1 = new Map(this, model.getStations());addListenersToModel();}
private void addListenersToModel() {this.model.addListener(vue1);}
public void notifyWayChanged(String origin, String destination)throws Exception {model.ok(origin, destination);}
public AlgoA(int[][] distances) {this.distances = distances;this.openedList = new ArrayList<>();this.closedList = new ArrayList<>();this.way = new ArrayList<>();this.sf = null;}
public ArrayList<Station> findWay(Station si, Station sf) {this.sf = sf;this.openedList.clear();this.closedList.clear();this.way.clear();this.openedList.add(si);find(si);if (si.equals(sf)) {ArrayList<Station> a = new ArrayList<>();a.add(sf);return a;}return this.way;}
private void find(Station padre) {for (int i = 0; i < padre.getNeighbours().size(); i++) {int gPH = this.distances[padre.getId()][padre.getNeighbours().get(i).getId()];int g = gPH + padre.getG();int f = g+ this.distances[padre.getNeighbours().get(i).getId()][this.sf.getId()];if ((f < padre.getNeighbours().get(i).getF() && padre.getNeighbours().get(i).getF() != 0)|| padre.getNeighbours().get(i).getF() == 0) {padre.getNeighbours().get(i).setG(g);padre.getNeighbours().get(i).setF(f);padre.getNeighbours().get(i).addWayToHere(padre.getWayToHere());padre.getNeighbours().get(i).addWayToHere(padre);}}almacenar(padre.getNeighbours());ArrayList<Station> stationClone = (ArrayList<Station>) this.openedList.clone();this.openedList.clear();reordenar(stationClone);this.closedList.add(this.openedList.get(0));this.openedList.remove(0);Station padre1 = this.closedList.get(this.closedList.size() - 1);if (!padre1.equals(sf)) {find(padre1);} else {this.way.addAll(padre1.getWayToHere());this.way.add(sf);}}
public void almacenar(ArrayList<Station> s) {for (int i = 0; i < s.size(); i++) {if (!this.openedList.contains(s.get(i))&& !this.closedList.contains(s.get(i))) {this.openedList.add(s.get(i));}}}
public void reordenar(ArrayList<Station> stationClone) {if (stationClone.size() > 0) {for (int i = 0; i < stationClone.size(); i++) {int j = findMin(stationClone);this.openedList.add(stationClone.get(j));stationClone.remove(j);reordenar(stationClone);}}}
public int findMin(ArrayList<Station> s) {int j = 0;int min = s.get(0).getF();for (int i = 1; i < s.size(); i++) {if (min > s.get(i).getF()) {min = s.get(i).getF();j = i;}}return j;}
public Model() {this.parser = new ParserData();this.distance = this.parser.getDistances();this.stations = this.parser.getStation();this.way = new ArrayList<>();this.algo = new AlgoA(this.distance);this.ecouteurs = new EventListenerList();}
public void ok(String origin, String destination) {clearAllStation();Station si = null, sf = null;for (int i = 0; i < stations.length; i++) {if (stations[i].getName().equals(origin)) {si = stations[i];}if (stations[i].getName().equals(destination)) {sf = stations[i];}if (sf != null && si != null)break;}if (sf == null || si == null) {System.out.println("");System.out.println("" + si + "" + sf);}this.way = algo.findWay(si, sf);fireWayChanged();}
private void clearAllStation() {for (int i = 0; i < this.stations.length; i++) {this.stations[i].clear();}}
public void addListener(FindWayListener ecouteur) {ecouteurs.add(FindWayListener.class, ecouteur);}
public ParserData() {read();}
private void read() {try {Class c = Class.forName("");InputStream ips = c.getResourceAsStream(FILENAME);            InputStreamReader ipsr = new InputStreamReader(ips);            BufferedReader br = new BufferedReader(ipsr);String s;while ((s = br.readLine()) != null) {switch (s) {case "":break;case "":s = br.readLine();parseStations(s);break;case "":int i = 0;while ((s = br.readLine()) != null) {if (s.charAt(0) == '') {} else {parseLinks(s, i);i++;}}break;default:break;}}} catch (IOException e) {e.printStackTrace();}catch (ClassNotFoundException e){e.printStackTrace();} }
private void parseStations(String s) {String[] station = s.split("");int n = station.length;this.distances = new int[n][n];this.stations = new Station[n];for (int i = 0; i < n; i++) {stations[i] = new Station(station[i], i);}}
private void parseLinks(String s, int stationTreat) {String[] block = s.split("");parseDistance(block[0], stationTreat);parseNeighbours(block[1], stationTreat);}
private void parseDistance(String s, int stationTreat) {String[] block = s.split("");for (int i = 0; i < this.distances.length; i++) {this.distances[stationTreat][i] = Integer.parseInt(block[i]);}}
private void parseNeighbours(String s, int stationTreat) {String[] block = s.split("");for (int i = 0; i < block.length; i++) {this.stations[stationTreat].addStationNeighbours(this.stations[Integer.parseInt(block[i])]);}}
public Map(Controller controleur, Station[] stations){this.controleur = controleur;this.stations = stations;this.positionStation = new HashMap<>();for (int i = 0; i < stations.length; i++) {this.positionStation.put(stations[i], POSITIONS.get(i));}try {this.drawCombo();this.draw(new ArrayList<Station>(), 0, 0);} catch (IOException e) {e.printStackTrace();}}
private void drawCombo() {this.comboOrigin = new JComboBox<String>();this.comboDestination = new JComboBox<String>();for (int i = 0; i < stations.length; i++) {this.comboOrigin.addItem(stations[i].getName());this.comboDestination.addItem(stations[i].getName());}this.buttonOk = new JButton("");buttonOk.addActionListener(this);}
private void drawCamino(ArrayList<Station> stations) {for (Station s : stations) {g.setColor(Color.RED);g.fillOval(positionStation.get(s).getX() - 5, positionStation.get(s).getY() - 5, RADIUS, RADIUS);}}
public void wayChanged(FindWayEvent event) {ArrayList<Station> s = event.getStationsWay();try {this.draw(s, s.get(0).getId(), s.get(s.size() - 1).getId());} catch (IOException e) {e.printStackTrace();}}
public AppRevJPATest(String testName )
    public static Test suite()    {        return new TestSuite( AppRevJPATest.class );    }
    public void testApp()    {        assertTrue( true );    }
public AdminServlet() {        super();            }
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {}
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {}
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {doPost(request,response);}
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {request.setCharacterEncoding("");        response.setContentType("");        response.setCharacterEncoding("");        String method=request.getParameter("");if(method.endsWith("")){login(request, response);}else if(method.endsWith("")){addT(request,response);}else if(method.endsWith("")){addS(request,response);}else if(method.endsWith("")){modifyT(request, response);}else if(method.endsWith("")){modifyS1(request, response);}else if(method.endsWith("")){modifyS2(request, response);}else if(method.endsWith("")){deleteS(request, response);}else if(method.endsWith("")){deleteT(request, response);}}
public static List<Student> selectStu_All()throws SQLException{Connection conn = null;PreparedStatement ps = null;ResultSet rs = null;List<Student> stu = new ArrayList<Student>();try {conn = DBcon.getConnection();String sql = "";ps = conn.prepareStatement(sql);rs = ps.executeQuery();while(rs.next()) {String sno = rs.getString("");String spasswd = rs.getString("");String sname = rs.getString("");String course = rs.getString("");int grade = rs.getInt("");Student st = new Student(sno,sname,spasswd,course,grade);stu.add(st);}}catch(SQLException e) {e.printStackTrace();}finally {if(rs != null) {try {rs.close();} catch (SQLException e) {e.printStackTrace();}}if(ps != null) {try {ps.close();} catch (SQLException e) {e.printStackTrace();}}if(conn != null) {try {conn.close();} catch (SQLException e) {e.printStackTrace();}}}return stu;}
public static Student selectStu_Sno(String sno) throws SQLException{Connection conn = null;PreparedStatement ps = null;ResultSet rs = null;Student st = null;try {conn = DBcon.getConnection();String sql = "";ps = conn.prepareStatement(sql);ps.setNString(1, sno);rs = ps.executeQuery();while(rs.next()) {String sno1 = rs.getString("");String sname = rs.getString("");String spasswd = rs.getString("");String course = rs.getString("");int grade = rs.getInt("");st = new Student(sno1,sname,spasswd,course,grade);}}catch(SQLException e) {e.printStackTrace();}finally {if(rs != null) {try {rs.close();} catch (SQLException e) {e.printStackTrace();}}if(ps!= null) {try {ps.close();} catch (SQLException e) {e.printStackTrace();}}if(conn != null) {try {conn.close();} catch (SQLException e) {e.printStackTrace();}}}return st;}
public static String insertStu(Student stu)throws SQLException {Connection conn = null;PreparedStatement ps = null;try {conn = DBcon.getConnection();String sql = "";ps = conn.prepareStatement(sql);ps.setString(1, stu.getSno());ps.setString(2, stu.getSpasswd());ps.setString(3, stu.getSname());ps.setString(4, stu.getCourse());ps.setInt(5, stu.getGrade());int insertCount = ps.executeUpdate();System.out.println(isSuccess(insertCount));return isSuccess(insertCount);}catch(SQLException e) {return ""+e;}finally {if(ps != null) {try {ps.close();} catch (SQLException e) {return ""+e;}}if(conn != null) {try {conn.close();} catch (SQLException e) {return ""+e;}}}}
public static String deleteStu(String sno)throws SQLException {Connection conn = null;PreparedStatement ps = null;try {conn = DBcon.getConnection();String sql = "";ps = conn.prepareStatement(sql);ps.setString(1, sno);int deleteCount = ps.executeUpdate();System.out.println(isSuccess(deleteCount));return isSuccess(deleteCount);}catch(SQLException e) {return ""+e;}finally {if(ps != null) {try {ps.close();} catch (SQLException e) {e.printStackTrace();return ""+e;}}if(conn != null) {try {conn.close();} catch (SQLException e) {e.printStackTrace();return ""+e;}}}}
public static String modifyStu(Student stu) throws SQLException{Connection conn = null;PreparedStatement ps = null;try {conn = DBcon.getConnection();String sql = "";ps = conn.prepareStatement(sql);ps.setString(1, stu.getSpasswd());ps.setString(2, stu.getSname());ps.setString(3, stu.getCourse());ps.setInt(4, stu.getGrade());ps.setString(5, stu.getSno());int count = ps.executeUpdate();System.out.println(isSuccess(count));return isSuccess(count);}catch(SQLException e) {e.printStackTrace();return ""+e;}finally {if(ps != null) {try {ps.close();} catch (SQLException e) {e.printStackTrace();return ""+e;}}if(conn != null) {conn.close();}}}
public static String resetPasswd(String sno) throws SQLException{Connection conn = null;PreparedStatement ps = null;try {conn = DBcon.getConnection();String sql = "";ps = conn.prepareStatement(sql);ps.setString(1, "");ps.setString(2,sno);int count = ps.executeUpdate();System.out.println(isSuccess(count));return isSuccess(count);}catch(SQLException e) {e.printStackTrace();return ""+e;}finally {if(ps != null) {try {ps.close();} catch (SQLException e) {e.printStackTrace();return ""+e;}}if(conn != null) {conn.close();}}}
public static String isSuccess(int count){if(count > 0) {return "";}else {return "";}}
public static List<Teacher> selectTea_All(){Connection conn = null;PreparedStatement ps = null;ResultSet rs = null;List<Teacher> tea = new ArrayList<Teacher>();try {conn = DBcon.getConnection();String sql = "";ps = conn.prepareStatement(sql);rs = ps.executeQuery();while(rs.next()) {String tno = rs.getString("");String tpasswd = rs.getString("");String tname = rs.getString("");String course = rs.getString("");Teacher st = new Teacher(tno,tname,tpasswd,course);tea.add(st);}}catch(Exception e) {e.printStackTrace();}finally {if(rs != null) {try {rs.close();} catch (SQLException e) {e.printStackTrace();}}if(ps != null) {try {ps.close();} catch (SQLException e) {e.printStackTrace();}}if(conn != null) {try {conn.close();} catch (SQLException e) {e.printStackTrace();}}}return tea;}
public static Teacher selectTea_Tno(String tno) {Connection conn = null;PreparedStatement ps = null;ResultSet rs = null;Teacher st = null;try {conn = DBcon.getConnection();String sql = "";ps = conn.prepareStatement(sql);ps.setNString(1, tno);rs = ps.executeQuery();while(rs.next()) {String tno1 = rs.getString("");String tname = rs.getString("");String tpasswd = rs.getString("");String course = rs.getString("");st = new Teacher(tno1,tname,tpasswd,course);}}catch(Exception e) {e.printStackTrace();}finally {if(rs != null) {try {rs.close();} catch (SQLException e) {e.printStackTrace();}}if(ps!= null) {try {ps.close();} catch (SQLException e) {e.printStackTrace();}}if(conn != null) {try {conn.close();} catch (SQLException e) {e.printStackTrace();}}}return st;}
public static String insertTea(Teacher tea) {Connection conn = null;PreparedStatement ps = null;try {conn = DBcon.getConnection();String sql = "";ps = conn.prepareStatement(sql);ps.setString(1, tea.getTno());ps.setString(2, tea.getTpasswd());ps.setString(3, tea.getTname());ps.setString(4, tea.getCourse());int insertCount = ps.executeUpdate();System.out.println(isSuccess(insertCount));return isSuccess(insertCount);}catch(Exception e) {e.printStackTrace();return ""+e;}finally {if(ps != null) {try {ps.close();} catch (SQLException e) {e.printStackTrace();return ""+e;}}if(conn != null) {try {conn.close();} catch (SQLException e) {e.printStackTrace();return ""+e;}}}}
public static String deleteTea(String tno) {Connection conn = null;PreparedStatement ps = null;try {conn = DBcon.getConnection();String sql = "";ps = conn.prepareStatement(sql);ps.setString(1, tno);int deleteCount = ps.executeUpdate();System.out.println(isSuccess(deleteCount));return isSuccess(deleteCount);}catch(Exception e) {e.printStackTrace();return ""+e;}finally {if(ps != null) {try {ps.close();} catch (SQLException e) {e.printStackTrace();return ""+e;}}if(conn != null) {try {conn.close();} catch (SQLException e) {e.printStackTrace();return ""+e;}}}}
public static String modifyTea(Teacher tea) throws SQLException {Connection conn = null;PreparedStatement ps = null;try {conn = DBcon.getConnection();String sql = "";ps = conn.prepareStatement(sql);ps.setString(1, tea.getTpasswd());ps.setString(2, tea.getTname());ps.setString(3, tea.getCourse());ps.setString(4, tea.getTno());int count = ps.executeUpdate();System.out.println(isSuccess(count));return isSuccess(count);}catch(Exception e) {e.printStackTrace();return ""+e;}finally {if(ps != null) {try {ps.close();} catch (SQLException e) {e.printStackTrace();return ""+e;}}if(conn != null) {conn.close();}}}
public static String resetPasswd(String tno) throws SQLException{Connection conn = null;PreparedStatement ps = null;try {conn = DBcon.getConnection();String sql = "";ps = conn.prepareStatement(sql);ps.setString(1, "");ps.setString(2,tno);int count = ps.executeUpdate();System.out.println(isSuccess(count));return isSuccess(count);}catch(SQLException e) {e.printStackTrace();return ""+e;}finally {if(ps != null) {try {ps.close();} catch (SQLException e) {e.printStackTrace();return ""+e;}}if(conn != null) {conn.close();}}}
public static String isSuccess(int count) {if(count > 0) {return "";}else {return "";}}
    public Optional<Client> get(long id) {        return Optional.ofNullable(clients.get((int)id));    }
    public List<Client> getAll() {        return clients;    }
    public void save(Client client) {        clients.add(client);    }
    public void update(Client client, String[] params) {            }
    public Optional<Compte> get(long id) {        return Optional.ofNullable(comptes.get((int)id));    }
    public List<Compte> getAll() {        return comptes;    }
    public void save(Compte compte) {        comptes.add(compte);    }
    public void update(Compte compte, String[] params) {            }
public Banque() {super();listeClient.add(new Client( "", "",""));listeClient.add(new Client( "", "",""));Compte compte1 = new Compte();Compte compte2= new Compte();}
public ArrayList getListeClient(){return listeClient;}
public static Image loadImage(String path) {URL imgUrl = Utils.class.getClassLoader().getResource(path);return Toolkit.getDefaultToolkit().createImage(imgUrl);}
public static String extractMatch(String pattern, String source) {Matcher m = Pattern.compile(pattern).matcher(source);if (m.find()) {return m.group(1);} else {throw new IllegalArgumentException("" + pattern + "" + source);}}
public static Iterator<Color> colorsGenerator() {Iterator<Color> i = new Iterator<Color>() {private Random r = new Random(314159265);@Overridepublic Color next() {return new Color(r.nextInt(256), r.nextInt(256), r.nextInt(256));}@Overridepublic boolean hasNext() {return true;}@Overridepublic void remove() {throw new UnsupportedOperationException("");}};return i;}
public GameError(String msg) {super(msg);}
public GameError(String msg, Throwable cause) {super(msg, cause);}
public int getPlayerCount() {return playerCount;}
public String getGameDescreption() {return this.getClass().getName();}
public double evaluate(int playerNumber) {return isFinished() ? (playerNumber == getWinner() ? 1 : -1) :0;}
public void save(File file) throws IOException {FileOutputStream fout = new FileOutputStream(file);try (ObjectOutputStream oos = new ObjectOutputStream(fout)) {oos.writeObject(this);} catch (IOException ioe) {throw new IOException("" + file.getAbsolutePath() + "", ioe);}}
public static GameState<?, ?> load(File file) throws IOException {FileInputStream fin = new FileInputStream(file);try (ObjectInputStream ois = new ObjectInputStream(fin)) {return (GameState<?, ?>) ois.readObject();} catch (ClassNotFoundException cnfe) {throw new IOException("" + file.getAbsolutePath() + "", cnfe);}}
public ConcurrentDeepeningMinMax(int threads) {        this.threads = threads;    }
    public int getEvaluationCount() {        return evaluationCount.get();    }
public ChessAction(int player, int srcRow, int srcCol,
public ChessBoard() {        board = new byte[DIM_WITH_BORDERS * DIM_WITH_BORDERS];                for (int i=0; i<DIM_WITH_BORDERS; i++) {            for (int j=0; j<DIM_WITH_BORDERS; j++) {                board[i*DIM_WITH_BORDERS + j] =                        (i<BORDER || i>=DIM+BORDER || j<BORDER || j>=DIM+BORDER) ?                                OUTSIDE : EMPTY;            }        }                for (int i=0; i<DIM; i++) {            set(1, i, Piece.Pawn.black());            set(6, i, Piece.Pawn.white());        }        set(0, 0, Piece.Rook.black());        set(0, 7, Piece.Rook.black());        set(7, 0, Piece.Rook.white());        set(7, 7, Piece.Rook.white());        set(0, 1, Piece.Knight.black());        set(0, 6, Piece.Knight.black());        set(7, 1, Piece.Knight.white());        set(7, 6, Piece.Knight.white());        set(0, 2, Piece.Bishop.black());        set(0, 5, Piece.Bishop.black());        set(7, 2, Piece.Bishop.white());        set(7, 5, Piece.Bishop.white());        set(0, 3, Piece.Queen.black());        set(7, 3, Piece.Queen.white());        set(0, 4, Piece.King.black());        set(7, 4, Piece.King.white());    }
    public static boolean sameTurn(byte p, int turn) {        return (p & NON_PIECE_MASK) == (turn << 3);    }
        public static String iconName(byte p) {            return "" + valueOf(p).getSymbol(false) + ""                    + (ChessBoard.black(p)  ? "" : "") + "";        }
public ChessState() {        super(2);        turn = WHITE;        winner = -1;        finished = false;        board = new ChessBoard();        canCastle = new int[]{                CASTLE_SHORT | CASTLE_LONG, CASTLE_SHORT | CASTLE_LONG};        enPassant = -1;        inCheck = false;        valid = null;        updateValid();    }
public ChessState(ChessState previous, ChessBoard board,
    public static int otherPlayer(int player) {        return player == BLACK ? WHITE : BLACK;    }
    protected static boolean findKing(ChessBoard board, int turn, Point kingPos) {        for (int i = 0; i < DIM; i++) {            for (int j = 0; j < DIM; j++) {                byte p = board.get(i, j);                if (sameTurn(p, turn) && Piece.valueOf(p) == Piece.King) {                    kingPos.setLocation(j, i);                    return true;                }            }        }        return false;    }
    private void updateValid() {        if (valid != null) {            return;        }        int otherTurn = otherPlayer(turn);        valid = new ArrayList<>();        ArrayList<ChessAction> candidates = new ArrayList<>();                for (int i = 0; i < DIM; i++) {            for (int j = 0; j < DIM; j++) {                byte p = board.get(i, j);                if (sameTurn(p, turn)) {                    generateActions(p, turn, i, j, candidates);                }            }        }                Point myKing = new Point();        Point kingPos = new Point();        Point otherKing = new Point();        if ( ! findKing(board, turn, myKing)) {            throw new IllegalStateException("" + turn + "" + board);        }        if ( ! findKing(board, otherTurn, otherKing)) {            throw new IllegalStateException("" + otherTurn + "" + board);        }        for (ChessAction a : candidates) {            ChessBoard next = new ChessBoard(board);            a.applyTo(next);            if (myKing.y == a.getSrcRow() && myKing.x == a.getSrcCol()) {                kingPos.setLocation(a.getDstCol(), a.getDstRow());            } else {                kingPos.setLocation(myKing);            }            if ( ! threatenedBy(next, otherTurn, kingPos.y, kingPos.x)) {                a.setCheck(threatenedBy(next, turn, otherKing.y, otherKing.x));                valid.add(a);            }        }    }
    public List<ChessAction> validActions(int playerNumber) {        return valid;    }
    public int at(int row, int col) {        return board.get(row, col);    }
    public ChessBoard getBoard() {        return new ChessBoard(board);    }
    protected void deltaActions(byte p, int turn,                                int row, int col, int dy, int dx, ArrayList<ChessAction> as,                                boolean multiple) {        int dRow = row, dCol = col;        byte target;        do {            dRow += dy;            dCol += dx;            target = board.get(dRow, dCol);            if (empty(target) || enemy(p, target)) {                as.add(new ChessAction(turn, row, col, dRow, dCol));            }        } while (multiple && empty(target));    }
    protected static boolean threatenedBy(ChessBoard b, int turn, int row, int col) {        for (int i = 0; i < DIM; i++) {            for (int j = 0; j < DIM; j++) {                byte p = b.get(i, j);                if (sameTurn(p, turn) && canCapture(b, p, i, j, row, col)) {                    log.fine("" + row +""+col+"" + i+""+j + "" + Piece.valueOf(p));                    return true;                }            }        }        return false;    }
    public boolean isInCheck() {        return inCheck;    }
public static void match(GameState<?, ?> initialState, GamePlayer a, GamePlayer b, int times) {int va = 0, vb = 0;List<GamePlayer> players = new ArrayList<GamePlayer>();players.add(a);players.add(b);for (int i = 0; i < times; i++) {switch (playGame(initialState, players)) {case 0:va++;break;case 1:vb++;break;}}System.out.println("" + va + "" + a.getName() + "" + vb + "" + b.getName());}
public static void testTtt() {try (Scanner s = new Scanner(System.in)) {List<GamePlayer> players = new ArrayList<GamePlayer>();GameState<?, ?> game = new TttState(3);players.add(new ConsolePlayer("", s));players.add(new SmartPlayer("", 5));playGame(game, players);} }
public static void main(String... args) {testLobo();testTtt();}
private static GameTable<?, ?> createGame(String juego) {GameState<?, ?> initialState;GameTable<?, ?> gameTable;if(juego.equalsIgnoreCase("")) {initialState = new TttState(3);gameTable = new GameTable(initialState);}else if (juego.equalsIgnoreCase("")){initialState = new WolfAndSheepState();gameTable = new GameTable(initialState);}else return null;return gameTable;}
public static GameState<?,?> createInitialState(String juego) {GameState<?, ?> initialState;if(juego.equalsIgnoreCase("")) {System.out.println("");int dim = in.nextInt();initialState = new TttState(dim);}else if (juego.equalsIgnoreCase("")) initialState = new WolfAndSheepState();else return null;return initialState;}
public static GamePlayer createPlayer(String gameName, String playerType, String playerName) {GamePlayer jugador;if(playerType.equalsIgnoreCase("")) jugador = new ConsolePlayer(playerName, in);else if (playerType.equalsIgnoreCase(""))jugador = new SmartPlayer(playerName, 5);else if (playerType.equalsIgnoreCase("")) jugador = new RandomPlayer(playerName);else return null;return jugador;}
public static void main(String[] args) {if (args.length < 2) {usage();System.exit(1);}GameTable<?, ?> game = createGame(args[0]);if (game == null) {System.err.println("");usage();System.exit(1);}String[] otherArgs = Arrays.copyOfRange(args, 2, args.length);switch (args[1]) { case "":startConsoleMode(args[0], game, otherArgs);break; case "":startGuiMode(args[0],game);break; default:System.err.println(""+args[1]);usage();System.exit(1);}}
private static GameTable<?, ?> createGame(String juego) {GameState<?, ?> initialState;GameTable<?, ?> gameTable;if(juego.equalsIgnoreCase("")) {initialState = new TttState(3);gameTable = new GameTable(initialState);}else if (juego.equalsIgnoreCase("")){initialState = new WolfAndSheepState();gameTable = new GameTable(initialState);}else if (juego.equalsIgnoreCase("")){initialState = new ChessState();gameTable = new GameTable(initialState);}else return null;return gameTable;}
public GameEvent(EventType type, A action, S state, GameError error, String description) {        this.type = type;        this.action = action;        this.state = state;        this.error = error;        this.description = description;    }
    public int[][] getBoard() {        int[][] copy = new int[board.length][];        for (int i=0; i<board.length; i++) copy[i] = board[i].clone();        return copy;    }
public WolfAndSheepAction(int player2, int originRow2, int originCol2, int finalRow2, int finalCol2) {this.player = player2;this.originRow = originRow2;this.originCol = originCol2;this.finalRow = finalRow2;this.finalCol = finalCol2;}
    public String toString() {        return "" + player + "" + originRow + "" + originCol + "" + "" + finalRow + "" + finalCol + "";    }
public WolfAndSheepState() {super(2);board = new int[DIM][];        for (int i=0; i<DIM; i++) {            board[i] = new int[DIM];            for (int j=0; j<DIM; j++) board[i][j] = EMPTY;        }        for(int i = 1; i < DIM; i =i+2) {        board[0][i] = OVEJA;        }        board[DIM - 1][0] = LOBO;        this.turn = 0;        this.winner = -1;        this.finished = false;}
public WolfAndSheepState(WolfAndSheepState prev, int[][] board, boolean finished, int winner) {    super(2);        this.board = board;        this.turn = (prev.turn + 1) % 2;        this.finished = finished;        this.winner = winner;    }
public static boolean isWinner(int[][] board2, int player) {boolean encontrado = false, posible = false;         if(player == OVEJA) {        int i = 0, j = 0;        while(i < DIM && !encontrado) {        j = 0;while(j <DIM && !encontrado) { if(board2[i][j] == LOBO){ if(i - 1 >= 0 && j - 1  >= 0 && board2[i-1][j-1] == EMPTY) posible = true; else if (i - 1 >= 0 && j + 1 < DIM && board2 [i-1][j+1] == EMPTY) posible = true; else if (i + 1 < DIM && j - 1 >= 0 && board2[i+1][j - 1] == EMPTY) posible = true; else if( i + 1 < DIM && j + 1 < DIM && board2[i + 1][j + 1] == EMPTY) posible = true; encontrado = true; } else j++; } i++; }         if(!posible) return true;          else return false;        }        else {        for(int j = 0; j < DIM && !encontrado; j++) {        if(board2[0][j] == LOBO) encontrado = true;        }        if (!encontrado){        int i = 0, j = 0, count = 0;         while(i < DIM && count < DIM/2 && !posible) {    j = 0;    while(j <DIM && count < DIM/2 && !posible) {    if(board2[i][j] == OVEJA){    if (i + 1 < DIM && j - 1 >= 0 && board2[i+1][j - 1] == EMPTY) posible = true;    else if( i + 1 < DIM && j + 1 < DIM && board2[i + 1][j + 1] == EMPTY) posible = true;    count++;    }    j++;    }    i++;        }        return !posible;        }        else return encontrado;        }    }
public int[][] getBoard() {int[][] copy = new int[board.length][];        for (int i=0; i<board.length; i++) copy[i] = board[i].clone();        return copy;}
    public String toString() {        StringBuilder sb = new StringBuilder();        sb.append("" + 0);        for (int i=1; i<board.length; i++) {        if(i <= 10) sb.append("" + i);        else sb.append("" + i);        }        sb.append("");        for (int i=0; i<board.length; i++) {            if (i < 10) sb.append(i + "");            else sb.append(i + "");            for (int j=0; j<board.length; j++) {            if (board[i][j] == EMPTY) {            if ((i % 2 == 0 && j % 2 == 1) || (i % 2 == 1 && j % 2 == 0)) sb.append("");            else sb.append("");            }            else if (board[i][j] == LOBO) sb.append("");            else sb.append("");            }            sb.append("");        }        return sb.toString();    }
public static String printArray(int[] arr){if(arr==null){System.out.println("");return null;}StringBuffer sb = new StringBuffer();for(int i=0;i<arr.length;i++){sb.append(arr[i]+"");}return sb.toString();}
public Stack(int maxSize){if(maxSize<=0){System.out.println("");return;}this.maxSize = maxSize;dataArray = (T[]) new Object[maxSize];}
public boolean push(T obj){if(obj==null){System.out.println("");return false;}if(curSize>=maxSize){System.out.println("");return false;}dataArray[curSize++] = obj;return true;}
public T pop(){if(curSize==0){System.out.println("");return null;}return dataArray[--curSize];}
public T top(){if(curSize==0){System.out.println("");return null;}return dataArray[curSize-1];}
public int getMaxSize() {return maxSize;}
public int getCurSize() {return curSize;}
public static void main(String[] args){Stack<Integer> stack = new Stack<Integer>(10);stack.push(1);stack.push(2);stack.push(3);stack.push(4);stack.push(5);stack.push(6);stack.push(7);stack.push(8);stack.push(9);stack.push(10);stack.pop();stack.pop();stack.pop();stack.pop();stack.pop();stack.pop();stack.pop();stack.pop();stack.pop();stack.pop();stack.pop();stack.pop();stack.pop();stack.pop();stack.toString();}
public static int countBitOne_1(int n){int count = 0;while(n!=0){if((n&1)==1)count++;n = n >> 1;}return count;}
public static int countBitOne_2(int n){int count = 0;int flag = 1;while(flag!=0){if((n&flag) != 0)count++;flag = flag << 1;}return count;}
public static int countBitOne_3(int n){int count = 0;while(n!=0){n = n & (n-1);count++;}return count;}
public static double power(double a,int b){if(Power.equal(a,0.0))return 0;if(b==0)return 1;double c = a;for(int i=0; i<(b<0?-b:b)-1; i++){c *= a;}if(b<0)return 1/c;elsereturn c;}
public static boolean equal(double a, double b){if(a-b<=0.0001 && a-b >=-0.0001)return true;elsereturn false;}
public static int getMaxN_2(int n){if(n<=0){System.out.println("");result = false;return 0;}short[] a = new short[n];for(int i=0;i<n;i++){a[i] = 0;}a[n-1] = 1;int index = n-1;return 0;}
public static boolean isLower(int i,char[] a){if(a==null || a.length<=0){System.out.println("");result = false;return false;}return true;}
public static <T> boolean deleteNode(Node<T> first, Node<T> p){if(first==null){System.out.println("");return false;}if(p.next == null){Node<T> q = p;while(p.next != null){q = p;p = p.next;}q.next = p.next;p = null;}if(p.next != null){p.data = p.next.data;p.next = p.next.next;}return true;}
public static boolean reorder(int[] a){if(a==null || a.length==0){System.out.println("");return false;}if(a.length==1){System.out.println("");return true;}int i=0,j=a.length-1;while(i<j){while(a[i]%2==1)i++;while(a[j]%2==0)j--;if(i<j){int temp = a[i];a[i] = a[j];a[j] = temp;}}return true;}
public static boolean reorder_modify(int[] a){if(a==null || a.length==0){System.out.println("");return false;}if(a.length==1){System.out.println("");return true;}int i=0,j=a.length-1;while(i<j){while(i<a.length-1 && a[i]%2==1)i++;while(j>0 && a[j]%2==0)j--;if(i<j){int temp = a[i];a[i] = a[j];a[j] = temp;}}return true;}
public static int getTailK(Node<Integer> first,int k){if(first==null){System.out.println("");result = false;return 0;}if(k<1){System.out.println("");result = false;return 0;}int length = 1;Node<Integer> p = first;while(p.next!=null){length++;p = p.next;}if(length<k){System.out.println(""+k+"");result = false;return 0;}Node<Integer> q = first;for(int i=0;i<length-k;i++)q = q.next;return q.data;}
public static int getTailK_modify(Node<Integer> first,int k){if(first==null){System.out.println("");result = false;return 0;}if(k<1){System.out.println("");result = false;return 0;}Node<Integer> p = first;Node<Integer> q = first;for(int i=0;i<k-1;i++){if(q.next==null){System.out.println(""+k+"");result = false;return 0;}q = q.next;}while(q.next!=null){p = p.next;q = q.next;}return p.data;}
public static void main(String[] args){Node<Integer> node1 = new Node<Integer>();Node<Integer> node2 = new Node<Integer>();Node<Integer> node3 = new Node<Integer>();Node<Integer> node4 = new Node<Integer>();node1.data = 1;node2.data = 2;node3.data = 3;node4.data = 4;node1.next = node2;node2.next = node3;node3.next = node4;System.out.println(getTailK_modify(node1,11));}
public static <T> Node<T> revertLink(Node<T> first){if(first==null){System.out.println("");return null;}if(first.next==null){return first;}if(first.next.next==null){Node<T> end = first.next;first.next.next = first;first.next = null;return end;}{Node<T> a1 = first;Node<T> a2 = first.next;Node<T> a3 = first.next.next;first.next = null;while(a3!=null){a2.next = a1;a1 = a2;a2 = a3;a3 = a3.next;}a2.next = a1;return a2;}}
public static Node<Integer> mergeLink(Node<Integer> first1, Node<Integer> first2){if(first1==null && first2==null){System.out.println("");return null;}if(first1==null && first2!=null)return first2;if(first1!=null && first2==null)return first1;while(first2!=null){Node<Integer> p = first1;if(first2.data < p.data){Node<Integer> q = first2;first2 = first2.next;q.next = p;first1 = q;}Node<Integer> p_pre = p;while(p.data<=first2.data && p!=null){p_pre = p;p = p.next;}Node<Integer> q = first2;first2 = first2.next;q.next = p;p_pre.next = q;}return first1;}
public static <T> void binaryTreeMirror(BinaryTreeNode<T> root){if(root==null)return;if(root.left==null && root.right==null)return;{BinaryTreeNode<T> temp = root.left;root.left = root.right;root.right = temp;}{if(root.left!=null)binaryTreeMirror(root.left);if(root.right!=null)binaryTreeMirror(root.right);}}
public static <T> void preOrder(BinaryTreeNode<T> root){if(root==null)return;{preOrder(root.left);System.out.print(root.data+"");preOrder(root.right);}}
public Stack(int max){this.max = max;stack_a = new int[max];stack_b = new int[max];}
public boolean push(int t){if(top_a==max-1){System.out.println("");return false;}{stack_a[++top_a] = t;if(top_b==-1 || t<stack_b[top_b])stack_b[++top_b]=t;else{stack_b[top_b+1]=stack_b[top_b];top_b++;}}return true;}
public int pop(){if(top_a==-1){System.out.println("");return -1;}{top_b--;return stack_a[top_a--];}}
public int min(){if(top_a==-1){System.out.println("");return -1;}return stack_b[top_b];}
public static void main(String[] args){Stack stack = new Stack(10);System.out.println("");stack.pop();System.out.println("");stack.push(5);stack.push(4);stack.push(3);stack.push(2);stack.push(1);System.out.println(""+stack.min());System.out.println(""+stack.pop());System.out.println(""+stack.min());}
public static boolean isStackSequence(int[] a,int[] b){if(a==null || b==null || a.length<=0 || b.length<=0){System.out.println("");return false;}if(a.length != b.length){System.out.println("");return false;}{Stack<Integer> stack = new Stack<Integer>();int i=0,j=0;while(i<a.length){stack.add(a[i++]);if(stack.peek()==b[j]){stack.pop();j++;}}while(!stack.isEmpty()){if(stack.pop()!=b[j])return false;elsej++;}if(!stack.isEmpty())return false; }return true;}
public static void main(String[] args){int[] a = {1,2,3,4,5};int[] b = {4,3,5,1,2};System.out.println(isStackSequence(a,b));}
public static boolean printBinaryTree(BinaryTreeNode<Integer> root){if(root==null){System.out.println("");return false;}Queue<BinaryTreeNode<Integer>> queue = new LinkedBlockingQueue<BinaryTreeNode<Integer>>();queue.add(root);while(!queue.isEmpty()){BinaryTreeNode<Integer> first_node = queue.poll();System.out.println(first_node.data);if(first_node.left!=null)queue.add(first_node.left);if(first_node.right!=null)queue.add(first_node.right);}return true;}
public static void main(String[] args){BinaryTreeNode<Integer> root = new BinaryTreeNode<Integer>();BinaryTreeNode<Integer> node1 = new BinaryTreeNode<Integer>();BinaryTreeNode<Integer> node2 = new BinaryTreeNode<Integer>();BinaryTreeNode<Integer> node3 = new BinaryTreeNode<Integer>();BinaryTreeNode<Integer> node4 = new BinaryTreeNode<Integer>();BinaryTreeNode<Integer> node5 = new BinaryTreeNode<Integer>();root.data = 1;node1.data = 2;node2.data = 3;node3.data = 4;node4.data = 5;node5.data = 6;root.left = node1;root.right = node2;node1.left = node3;node1.right = node4;node2.right = node5;printBinaryTree(root);}
public static boolean isSearchTree(int[] a,int start,int end){if(a==null || a.length<=0){System.out.println("");return false;}if(start<0 || end>=a.length){System.out.println("");return false;}if(end-start==2){System.out.println("");if(a[start]>a[end] || a[start+1]<a[end])return false;elsereturn true;}else if(end-start<=1){System.out.print("");for(int x=start;x<=end;x++)System.out.println(a[x]+"");return true;}else{System.out.print("");for(int x=start;x<=end;x++)System.out.println(a[x]+"");int root = a[end];int i=start;while(i<end && a[i]<root)i++;for(int j=i;j<end;j++){if(a[j]<root)return false;}boolean result_tail = true;boolean result_pre = true;if(start>end)result_tail = isSearchTree(a,start,end-1);else{result_pre = isSearchTree(a,start,i-1);result_tail = isSearchTree(a,i,end);}if(result_pre && result_tail)return true;return false;}}
public static void main(String[] args){int[] a = {5,7,6,9,11,10,8};System.out.println(""+isSearchTree(a,0,a.length-1));}
private static void printBinaryPath(BinaryTreeNode<Integer> root, int n, Stack<Integer> stack) {if(root.left==null && root.right==null){stack.add(root.data);int sum = 0;Iterator<Integer> it = stack.iterator();while(it.hasNext())sum += it.next();if(sum==n){Iterator<Integer> it2 = stack.iterator();while(it2.hasNext())System.out.print(it2.next()+"");System.out.println("");}stack.pop();return;}else{stack.add(root.data);if(root.left!=null)printBinaryPath(root.left,n,stack);if(root.right!=null)printBinaryPath(root.right,n,stack);stack.pop();return;}}
public static void main(String[] args){BinaryTreeNode<Integer> node1 = new BinaryTreeNode<Integer>();BinaryTreeNode<Integer> node2 = new BinaryTreeNode<Integer>();BinaryTreeNode<Integer> node3 = new BinaryTreeNode<Integer>();BinaryTreeNode<Integer> node4 = new BinaryTreeNode<Integer>();BinaryTreeNode<Integer> node5 = new BinaryTreeNode<Integer>();node1.data = 10;node2.data = 5;node3.data = 12;node4.data = 4;node5.data = 7;node1.left = node2;node1.right = node3;node2.left = node4;node2.right = node5;printBinaryPath(node1,19);}
public static int countNumber(int[] a){if(a==null || a.length<=0){System.out.println("");return -1;}QuickSort.QuickSort(a);int mid = a[a.length/2];int count = 0;for(int i=0;i<a.length && a[i]<=mid;i++){if(a[i]==mid)count++;}if(count>=a.length/2)return mid;elsereturn -1;}
public static void main(String[] args){int[] a = {3,1,3,2,3,2,3,2,2,3,5,3,4,2,3,3};System.out.println(countNumber(a));}
public static boolean getMinKNumber(int[] a,int k){if(a==null || a.length<=0){System.out.println("");return false;}if(k>a.length){System.out.println("");return false;}TwoWayNode<Integer> first = new TwoWayNode<Integer>();{first.data = a[0];int link_node = 1;TwoWayNode<Integer> last = first;for(int i=1;i<a.length;i++){if(a[i]<=last.data){System.out.println(""+i+""+a[i]+"");TwoWayNode<Integer> p = last.pre;while(p!=null && p.data>a[i])p = p.pre;TwoWayNode<Integer> node = new TwoWayNode<Integer>();node.data = a[i];node.next = p.next;node.next.pre = node;p.next = node;node.pre = p;link_node++;if(link_node==4){last.pre.next = null;last.pre = null;link_node--;}}}TwoWayNode<Integer> node = first;while(node!=null){System.out.print(node.data+"");}}return true;}
public static boolean getMinKNumber2(int[] a,int k){if(a==null || a.length<=0){System.out.println("");return false;}if(k>a.length){System.out.println("");return false;}TwoWayNode<Integer> first = new TwoWayNode<Integer>();first.next = first.pre = null;first.data = a[0];int node_count = 1;TwoWayNode<Integer> last = first;for(int i=1;i<a.length;i++){if(node_count<k){insertNodeByOrder(a[i],first,last);node_count++;}else if(node_count>=k && a[i]<=last.data){insertNodeByOrder(a[i],first,last);node_count++;if(node_count>k){last.pre.next = null;last.pre = null;node_count--;}}}TwoWayNode<Integer> p = first;while(p!=null){System.out.print(p.data+"");p = p.next;}System.out.println("");return true;}
private static void insertNodeByOrder(int a, TwoWayNode<Integer> first, TwoWayNode<Integer> last) {TwoWayNode<Integer> node = new TwoWayNode<Integer>();node.data = a;if(last==null){last = node;return;}TwoWayNode<Integer> p = last;System.out.println(""+p!=null && p.data>a);while(p!=null && p.data>a){p = p.pre;}System.out.println(""+p.next);if(p==null){System.out.println(a+""+first.data+"");first.pre = node;node.next = first;first = node;}else if(p.next==null){node.pre = last;last.next = node;last = node;System.out.println("");}else{node.next = p.next;p.next.pre = node;node.pre = p;p.next = node;System.out.println("");}TwoWayNode<Integer> t = first;while(t!=null){System.out.print(t.data);t = t.next;}System.out.println("");}
public static void main(String[] args){int[] a = {1,2,3,4,5,6,7};getMinKNumber2(a,4);}
public static void main(String[] args){int[] a = {1,-2,3,10,-4,7,2,1,-5};System.out.println(""+result);System.out.println(""+getMaxSubArray(a));}
public static int countOne(int n){if(n<1){System.out.println("");return -1;}int count = 0;for(int i=1;i<=n;i++){int temp = i;while(temp>0){if(temp%10==1)count++;temp /= 10;}}return count;}
public static void main(String[] args){System.out.println(countOne(13));}
public static int uglyNumber(int n){if(n<=0){System.out.println("");return -1;}int[] a = new int[n];a[0] = 1;int count = 1;while(count<n){int i=0,j=0,z=0;for(i=0;i<a.length && a[i]*2<=a[count-1];i++);for(j=0;j<a.length && a[j]*3<=a[count-1];j++);for(z=0;z<a.length && a[z]*5<=a[count-1];z++);int min = a[i]*2;if(a[j]*3<min)min = a[j]*3;if(a[z]*5<min)min = a[z]*5;a[count++] = min;}return a[count-1];}
public static void main(String[] args){System.out.println(uglyNumber(5));}
public static void main(String[] args){char[] a = {'','','','','','','','',''};System.out.println(getFirstChar(a));}
public static int getKNumber(int[] a,int k){if(a==null || a.length<=0){System.out.println("");return -1;}int start = 0;int end = a.length-1;int k_start = -1;int k_end = -1;while(end-start >= 0){int mid = (start+end)/2;if(a[mid]>k){end = mid-1;}else if(a[mid]<k){start = mid+1;}else{if(a[mid-1]==k){end = mid-1;}else{k_start = mid;break;}}}start = 0;end = a.length-1;while(end-start >= 0){int mid = (start+end)/2;if(a[mid]>k){end = mid-1;}else if(a[mid]<k){start = mid+1;}else{if(a[mid+1]==k){start = mid+1;}else{k_end = mid;break;}}}if(k_start==-1 || k_end==-1)return 0;return k_end-k_start+1;}
public static void main(String[] args){int[] a = {0,1,2,3,4,6,7,7,7,7,7,7,8,9};System.out.println(getKNumber(a,7));}
public static <T> Node<T> getFirstCommonNode_1(Node<T> first1,Node<T> first2){if(first1==null || first2==null){System.out.println("");return null;}Stack<Node<T>> stack1 = new Stack<Node<T>>();Stack<Node<T>> stack2 = new Stack<Node<T>>();Node<T> p = first1;while(p!=null){stack1.push(p);p = p.next;}p = first2;while(p!=null){stack2.push(p);p = p.next;}Node<T> commonNode = null;while(stack1.peek() == stack2.peek()){commonNode = stack1.peek();stack1.pop();stack2.pop();}return commonNode;}
public static <T> Node<T> getFirstCommonNode_2(Node<T> first1,Node<T> first2){if(first1==null || first2==null){System.out.println("");return null;}int len1 = 0;Node<T> p = first1;while(p!=null){len1++;p = p.next;}int len2 = 0;p = first2;while(p!=null){len2++;p = p.next;}int diff = len1 - len2;if(diff > 0)for(int i=0;i<diff;i++)first1 = first1.next;elsefor(int i=0;i<diff;i++)first2 = first2.next;Node<T> p1 = first1;Node<T> p2 = first2;while(p1 != p2 && p1!=null && p2!=null){p1 = p1.next;p2 = p2.next;}return p1;}
public static void main(String[] args){Node<Integer> first1 = new Node<Integer>();Node<Integer> node2 = new Node<Integer>();Node<Integer> node3 = new Node<Integer>();Node<Integer> first2 = new Node<Integer>();Node<Integer> node4 = new Node<Integer>();Node<Integer> node5 = new Node<Integer>();first1.data = 111;node2.data = 2;node3.data = 3;node4.data = 4;node5.data = 5;first2.data = 222;first1.next = node2;node2.next = node3;node3.next = node4;node4.next = node5;first2.next = node3;System.out.println(getFirstCommonNode_2(first1, first2).data);}
public static <T> int getTreeHeight(Node<T> root){if(root==null){System.out.println("");return -1;}if(root.left==null && root.right==null)return 1;else if (root.right == null) return getTreeHeight(root.right) + 1;else if (root.left == null) return getTreeHeight(root.left) + 1;else {int left_height = getTreeHeight(root.left);int right_height = getTreeHeight(root.right);return (left_height > right_height ? left_height : right_height) + 1;}}
public Queue(int maxSize){if(maxSize<=0){System.out.println("");return;}stack1 = new Stack<T>(maxSize);stack2 = new Stack<T>(maxSize);this.maxSize = maxSize;}
public boolean push(T obj){if(obj==null){System.out.println("");return false;}if(stack1.getCurSize()>=maxSize){System.out.println("");return false;}stack1.push(obj);curSize++;return true;}
public T pop(){if(curSize==0){System.out.println("");return null;}if(stack2.getCurSize()>0){curSize--;return stack2.pop();}else{while(stack1.getCurSize()>0){stack2.push(stack1.pop());}curSize--;return stack2.pop();}}
public static void main(String[] args){Queue<Integer> queue = new Queue<Integer>(10);for(int i=0;i<10;i++)queue.push(i+1);queue.toString();queue.pop();queue.toString();}
public static void ageSort(int[] ages){int[] countAge = new int[100];if(ages==null || ages.length<=0){System.out.println("");return;}for(int i=0;i<ages.length;i++){if(ages[i]<0 || ages[i]>99){System.out.println("");return;}}for(int i=0;i<ages.length;i++)countAge[ages[i]]++;int curIndex = 0;for(int i=0;i<countAge.length;i++){for(int j=0;j<countAge[i];j++){ages[curIndex] = i;curIndex++;}}}
public static void main(String[] ages){int a = 3;switch(a){default:System.out.println("");case 1:System.out.println("");case 2:System.out.println("");case 3:System.out.println("");case 4:System.out.println("");}wangcai:for(int i=0;i<10;i++){break wangcai;}}
public static void main(String[] args){int[] a = new int[]{5,5,5,1,1,1,2,3,4};Int min = new Int();getMin(a, 0, a.length-1, min);System.out.println(""+min.getMin());}
private static int partition(int[] arr,int start,int end){if(arr.length<=0){System.out.println("");return -1;}if(start<0 || end<0 || start>end){System.out.println("");return -1;}int i=start+1,j=end;int key = arr[start];while(i<j){while(arr[i]<=key && i<end){i++;}while(arr[j]>=key && j>start){j--;}if(i<j)swap(arr,i,j);}swap(arr,start,j);System.out.println(""+printArray(arr));return j;}
private static void QuickSort(int[] arr,int start,int end){if(start<end){int key = partition(arr,start,end);QuickSort(arr,start,key-1);QuickSort(arr,key+1,end);}}
private static void swap(int[] arr,int i,int j){if(arr==null || arr.length<=0){System.out.println("");return;}int temp = arr[i];arr[i] = arr[j];arr[j] = temp;}
public static String printArray(int[] arr){if(arr==null){System.out.println("");return null;}StringBuffer sb = new StringBuffer();for(int i=0;i<arr.length;i++){sb.append(arr[i]);}return sb.toString();}
public static void main(String[] args){int[] arr = new int[]{4,3,1,5,3,6,8,0,1};System.out.println(""+printArray(arr));QuickSort(arr);System.out.println(""+printArray(arr));}
public static int fibonacci(int n){if(n<0){System.out.println("");return 0;}else if(n==0)return 0;else if(n==1)return 1;elsereturn fibonacci(n-1) + fibonacci(n-2);}
public static int fibonacci_recursion(int n){if(n<0){System.out.println("");return 0;}if(n==0 || n==1)return n;int a1=0,a2=1,a3=1;for(int i=0;i<n-1;i++){a3 = a1+a2;a1 = a2;a2 = a3;}return a3;}
public static void main(String[] args){int result = fibonacci(40);System.out.println(result);int result2 = fibonacci_recursion(40);System.out.println(result2);}
    public static void askToProm(String date_name) {        try {            Class<?> asking        = Class.forName(date_name);            Method   cheesy_poster = asking.getMethod(askMethod, Micah.class);                                    cheesy_poster.invoke(null, Micah.class.newInstance());                            } catch (ClassNotFoundException e) {            mood = "";        } catch (NoSuchMethodException e) {            mood = "";        } catch (IllegalAccessException e) {            mood = "";        } catch (InvocationTargetException e) {            mood = "";        } catch (Throwable t) {            System.err.println(""+t);        }    }
    public static void askedToPromBy(Micah m) { answer = ""; }
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {System.out.println("");ServletContext application = this.getServletContext();List<Mutter> mutterList=(List<Mutter>)application.getAttribute("");if(mutterList == null) {mutterList = new ArrayList<Mutter>();application.setAttribute("", mutterList);}HttpSession session = request.getSession();User loginUser = (User)session.getAttribute("");if(loginUser == null) {System.out.println("");response.sendRedirect("");}else{System.out.println("");RequestDispatcher dispatcher=request.getRequestDispatcher("");dispatcher.forward(request, response);}}
  public static This getConnection(This bshObject) {    return null;  }
  static void setUnitTesting(boolean flag) {    unitTesting = flag;  }
public ConnectionImpl() {  }
public ConnectionImpl(This global, Map impls, String variableName) {    this.global       = global;    this.impls        = impls;    this.variableName = variableName;  }
  public void setOutput(PrintWriter writer) {    this.output     = writer;    this.lispWriter = new LispWriter(output);  }
public ConnectionUnavailableException() {    super("");  }
public ConnectionUnavailableException(String msg) {    super(msg);  }
public ElispError(Object msg) {    super(msg.toString());  }
public LispWriter(PrintWriter dest) {        this.output = dest;    }
public Logger() {    this.output = null;  }
public Logger(Writer destination) {    this.output     = destination;    this.lispWriter = new LispWriter(new PrintWriter(destination));    try {      output.write("");      output.write(LINE_SEP);      output.flush();    } catch (IOException io) {}  }
public NoMoreResultsException() {    super("");  }
public Quoted(Object quotedValue) {    this.quoted = quotedValue;  }
public Symbol(String name) {    this.name = name;  }
  public static String java2Elisp(String javaName) {    StringBuffer lispName        = new StringBuffer();    boolean      lastCharWasDash = false;    char         prev            = '';    for (int i = 0; i < javaName.length(); i++) {      char c = javaName.charAt(i);      if (!Character.isLetterOrDigit(c)) {        lispName.append('');        lastCharWasDash = true;      } else {                        if (i > 0 && !lastCharWasDash            && Character.isLetter(prev)            && Character.isLetter(c)            && Character.isLowerCase(prev)            && Character.isUpperCase(c)) {          lispName.append('');        }        lispName.append(Character.toLowerCase(c));        lastCharWasDash = false;      }      prev = c;    }    return lispName.toString();  }
  static public final int getColumn() {     return bufcolumn[bufpos];  }
  static public final int getLine() {     return bufline[bufpos];  }
  static public void adjustBeginLineColumn(int newLine, int newCol)  {     int start = tokenBegin;     int len;     if (bufpos >= tokenBegin)     {        len = bufpos - tokenBegin + inBuf + 1;     }     else     {        len = bufsize - tokenBegin + bufpos + 1 + inBuf;     }     int i = 0, j = 0, k = 0;     int nextColDiff = 0, columnDiff = 0;     while (i < len &&            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])     {        bufline[j] = newLine;        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];        bufcolumn[j] = newCol + columnDiff;        columnDiff = nextColDiff;        i++;     }      if (i < len)     {        bufline[j] = newLine++;        bufcolumn[j] = newCol + columnDiff;        while (i++ < len)        {           if (bufline[j = start % bufsize] != bufline[++start % bufsize])              bufline[j] = newLine++;           else              bufline[j] = newLine;        }     }     line = bufline[j];     column = bufcolumn[j];  }
  protected String add_escapes(String str) {      StringBuffer retval = new StringBuffer();      char ch;      for (int i = 0; i < str.length(); i++) {        switch (str.charAt(i))        {           case 0 :              continue;           case '':              retval.append("");              continue;           case '':              retval.append("");              continue;           case '':              retval.append("");              continue;           case '':              retval.append("");              continue;           case '':              retval.append("");              continue;                         case '':              retval.append("");              continue;           case '':              retval.append("");              continue;           default:              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {                 String s = "" + Integer.toString(ch, 16);                 retval.append("" + s.substring(s.length() - 4, s.length()));              } else {                 retval.append(ch);              }              continue;        }      }      return retval.toString();   }
public Token specialToken;
  public final String toString()  {     return image;  }
  public static final Token newToken(int ofKind)  {     switch(ofKind)     {       default : return new Token();     }  }
public TokenMgrError() {   }
   protected static final String addEscapes(String str) {      StringBuffer retval = new StringBuffer();      char ch;      for (int i = 0; i < str.length(); i++) {        switch (str.charAt(i))        {           case 0 :              continue;           case '':              retval.append("");              continue;           case '':              retval.append("");              continue;           case '':              retval.append("");              continue;           case '':              retval.append("");              continue;           case '':              retval.append("");              continue;                         case '':              retval.append("");              continue;           case '':              retval.append("");              continue;           case '':              retval.append("");              continue;           default:              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {                 String s = "" + Integer.toString(ch, 16);                 retval.append("" + s.substring(s.length() - 4, s.length()));              } else {                 retval.append(ch);              }              continue;        }      }      return retval.toString();   }
   public void visit(TryStatement n) {      n.f0.accept(this);      n.f1.accept(this);      n.f2.accept(this);      n.f3.accept(this);   }
public TreeFormatter() { this(3, 0); }
   public void visit(TryStatement n) {      n.f0.accept(this);      n.f1.accept(this);      if ( n.f2.present() ) {         processList(n.f2);      }      if ( n.f3.present() ) {         n.f3.accept(this);      }   }
   private void placeToken(NodeToken n, int line, int column) {      int length = n.tokenImage.length();                        if ( !lineWrap || n.tokenImage.indexOf('') != -1 ||           column + length <= wrapWidth )         n.beginColumn = column;      else {         ++line;         column = curIndent + indentAmt + 1;         n.beginColumn = column;      }      n.beginLine = line;                        for ( int i = 0; i < length; ++i ) {         if ( n.tokenImage.charAt(i) == '' && i < length - 1 ) {            ++line;            column = 1;         }         else            ++column;      }      n.endLine = line;      n.endColumn = column;   }
  private static boolean isAccessible(int modifiers, int level) {    switch(level) {    case PUBLIC:          return  Modifier.isPublic    (modifiers);    case PROTECTED:       return  Modifier.isProtected (modifiers);    case PACKAGE:             return (!Modifier.isPublic   (modifiers) &&              !Modifier.isProtected(modifiers) &&              !Modifier.isPrivate  (modifiers));    case PRIVATE:         return  Modifier.isPrivate   (modifiers);    default:                  throw new Error("" +                      ""                      + level);    }  }
  private static StringBuffer tokenizeField(Field field) {    StringBuffer sb = new StringBuffer (30);    sb.append(START_LIST);    sb.append(printWithinQuotes(field.getName()));    sb.append(SPACE);    sb.append("");    sb.append(SPACE);    sb.append(printWithinQuotes(className(field.getType())));    sb.append(SPACE);sb.append(NIL);     sb.append(SPACE);StringBuffer modifiers = listModifiers(field.getModifiers());if (modifiers.length() > 0) {  sb.append(START_LIST);  sb.append(modifiers);  sb.append(END_PAREN);} else {  sb.append(NIL);}    sb.append(SPACE);sb.append(NIL); sb.append(END_PAREN);            return sb;  }
  private static StringBuffer tokenizeMethod(Method method) {    StringBuffer sb = new StringBuffer (30);    sb.append(START_LIST);    sb.append(printWithinQuotes(method.getName()));    sb.append(SPACE);    sb.append("");    sb.append(SPACE);    sb.append(listClasses(method.getParameterTypes()));    sb.append(SPACE);        StringBuffer temp = listModifiers(method.getModifiers());    Class[] types = method.getExceptionTypes();    if (sb.length() > 0 || types.length > 0) {      sb.append("");            if (temp.length() > 0) {sb.append(SPACE);sb.append(temp);      }       if (types.length > 0) {sb.append(SPACE);sb.append(listExceptions(types));      }           }    sb.append(END_PAREN);    sb.append(SPACE);    sb.append(NIL);     sb.append(END_PAREN);    return sb;   }
  private static StringBuffer innerClassInfo(Class ic) {    StringBuffer sb = new StringBuffer (30);    sb.append(START_LIST);    sb.append(printWithinQuotes(ic.getName()));    sb.append(SPACE);    sb.append(String.valueOf(INNER_CLASS_INFO));    sb.append(SPACE);    sb.append(accessLevel(ic.getModifiers()));    sb.append(END_PAREN);    return sb;  }
  private static String printWithinQuotes(String item) {    StringBuffer sb = new StringBuffer (30);    sb.append(DOUBLE_QUOTE);    sb.append(item);    sb.append(DOUBLE_QUOTE);            return sb.toString();  }
  public static void getClassInfo(String className,                                  String[]imports) {    String name;     Class c;    for (int i = 0 ; i < imports.length ; i++) {      name = imports[i] + className;      try {        c = Class.forName(name);        if (c != null) {          getClassInfo(name);        }      } catch (ClassNotFoundException cnfe) { }    }    System.out.println(NIL);  }
  public static void hasMember(String className, String memberName) {    try {      DynamicClassLoader dcl = new DynamicClassLoader();      Class c = dcl.loadClass(className);      if (c != null) {Field fields[] = c.getFields();boolean hasField = false;for (int index = 0; index < fields.length ; index++) {  if (fields[index].getName().equals(memberName)) {    hasField = true;    break;  }}Method methods[] = c.getMethods();boolean hasMethod = false;for (int index = 0; index < methods.length ; index++) {  if (methods[index].getName().equals(memberName)) {    hasMethod = true;    break;  }}        StringBuffer sb = new StringBuffer (3000);        sb.append(START_LIST);sb.append(hasField ? "" : "");sb.append(hasMethod ? "" : "");        sb.append(END_PAREN);        sb.append(NL);                        Writer out          = new BufferedWriter(new OutputStreamWriter(System.out));        try {          out.write(sb.toString());          out.flush();        } catch (IOException e) {        }      }    } catch (Exception cnfe) {System.out.println(NIL);}  }
    void load() {        addRecursively(directory,directory);        setLoaded(true);    }
    void addRecursively(File directory, File rootDir) {        String [] files = directory.list();        if (files == null) {            System.err.println("" + directory + "");            return;        }         String current;        String rootPath = rootDir.getPath();        String currentPath = directory.getPath();        String packageName = currentPath.substring(rootPath.length());        StringBuffer buf = new StringBuffer();        if (packageName.length() > 0) {                      packageName = packageName.replace('', '');           packageName = packageName.replace('', '');           packageName = packageName.substring(1);        }            for (int i = 0; i < files.length; i++) {            current = files[i];            if (current.toLowerCase().endsWith("")) {                current = current.substring(0, current.length() - 6);current = current.replace('', '');                 if (currentPath.indexOf(rootPath) != 0) {                    System.err.println(""                                       + "" + rootPath + ""                                       + "" + currentPath + "");                } else if (packageName.length() > 0) {                                        buf.append(packageName);                    buf.append('');                    buf.append(current);                    addClass(buf.toString());                    buf.setLength(0);                } else {                                        addClass(current);                }            } else {                                File currentFile = new File(directory, current);                if (currentFile.isDirectory()) {                    addRecursively(currentFile,rootDir);                }            }        }    }
    static ClassPathEntry instanceForEntry(File resource) throws IOException {        ClassPathEntry entry;                if (entryMap.containsKey(resource)) {            entry = entryMap.get(resource);        } else {            if (resource.getName().toLowerCase().endsWith("")) {                entry = new ClassPathZip(resource);            } else if (resource.getName().toLowerCase().endsWith("")) {                entry = new ClassPathZip(resource);            } else if (resource.isDirectory()) {                entry = new ClassPathDir(resource);            } else {                entry = null;               }            if (null != entry) {                entryMap.put(resource,entry);            }        }        return entry;    }
    void clear() {        nameToClassMap.clear();        setLoaded(false);    }
  private static String printExceptions(Class[] exceptions) {    StringBuffer sb = new StringBuffer (30);    sb.append(START_LIST);    sb.append(listClassArray(exceptions));    sb.append(END_PAREN);    return sb.toString();  }
  private static void recursiveListFields(Class c,                                          int level,                                          StringBuffer sb)  {        if (c == null) {      return;    }    Field[] fields;    Field   field;    String  f;        if (level == PUBLIC) {                        fields = c.getFields();    } else {      fields = c.getDeclaredFields();    }        for (int index = 0; index < fields.length ; index++) {      field = fields[index];      if (isAccessible(field.getModifiers(), level)) {        f = printField(field.getName(),                       className(field.getType()));        if (sb.toString().lastIndexOf(f) == -1) {          sb.append(f);        }      }    }            if (!c.isInterface()&& level != PRIVATE&& level != PUBLIC) {                                          recursiveListFields(c.getSuperclass(), level, sb);    }      }
  private static void listConstructors(Class c,                                       int level,                                       StringBuffer sb)  {    Constructor[] constrs = c.getDeclaredConstructors();    Constructor constructor;    Class[] exceptions;    StringBuffer cons;            for (int index = 0; index < constrs.length; index++) {      constructor = constrs[index];      if (isAccessible(constructor.getModifiers(), level)) {        cons = new StringBuffer(100);        cons.append(printConstructor(constructor.getName(),                                     constructor.getParameterTypes()));                exceptions = constructor.getExceptionTypes();                        if (exceptions.length > 0) {          cons.append(printExceptions(exceptions));        } else {          cons.append(NIL);        }        cons.append(END_PAREN);        if (sb.toString().lastIndexOf(cons.toString()) == -1) {          sb.append(cons);        }      }    }  }
  private static void recursiveListMethods(Class c,                                           int level,                                           StringBuffer sb)  {        if (c == null) {      return;    }    Method[] methods;    Method method;    Class[] exceptions;    StringBuffer temp;        if (level == PUBLIC) {                        methods = c.getMethods();    } else {      methods = c.getDeclaredMethods();    }                for (int index = 0; index < methods.length ; index++) {      method = methods[index];      if (isAccessible(method.getModifiers(), level)) {        temp = new StringBuffer(100);        temp.append(printMethod(method.getName(),                                className(method.getReturnType()),                                method.getParameterTypes()));                exceptions = method.getExceptionTypes();                        if (exceptions.length > 0) {          temp.append(printExceptions(exceptions));        } else {          temp.append(NIL);        }        temp.append(END_PAREN);                        if (sb.toString().lastIndexOf(temp.toString()) == -1) {          sb.append(temp);        }      }    }            if (!c.isInterface()&& level != PRIVATE&& level != PUBLIC) {                                          recursiveListMethods(c.getSuperclass(), level, sb);    }      }
  private static void recursiveListInnerClasses(Class c,                                                int level,                                                StringBuffer sb) {    if (c == null) {      return;    }    Class[] innerClasses;    Class   innerClass;    String  clas;        if (level == PUBLIC) {                                    innerClasses = c.getClasses();    }    else {      innerClasses = c.getDeclaredClasses();    }                for (int index = 0; index < innerClasses.length ; index++) {      innerClass = innerClasses[index];      if (isAccessible(innerClass.getModifiers(), level)) {        clas = printClass(innerClass.getName());        if (sb.toString().lastIndexOf(clas) == -1) {          sb.append(clas);        }      }    }            if (!c.isInterface() &&        level != PRIVATE &&        level != PUBLIC) {                                          recursiveListInnerClasses(c.getSuperclass(), level, sb);    }      }
  public static void getClassInfo(String className,                                  String[]imports) {    String name;     Class c;    for (int i = 0 ; i < imports.length ; i++) {      name = imports[i] + className;      try {        c = Class.forName(name);        if (c != null) {          getClassInfo(name);        }      }  catch (ClassNotFoundException e) {              } catch (Exception e) {System.out.println("" + name + "" + e + "");             } catch (NoClassDefFoundError e) {System.out.println(NIL);      } catch (UnsatisfiedLinkError e) {System.out.println("" + name + "" + e + "");             } catch (LinkageError e) {System.out.println("" + name + "" + e + "");             }        }    System.out.println(NIL);  }
  public Class loadClass(String argClassName) throws ClassNotFoundException {    File file;    byte[] classBytes = null;    Class c;        if ((argClassName.startsWith("")) ||         (argClassName.startsWith(""))) {      return Class.forName(argClassName);    }                 String className = argClassName.replace(PACKAGE_SEPARATOR,                                            FILE_SEPARATOR.charAt(0));            className += PACKAGE_SEPARATOR + CLASS_FILE_TYPE;            ProjectClasses pc = JdeUtilities.getCurrentProjectClass();    String classpath = null;    if (pc != null) {        classpath = pc.getClassPath();    }         if (classpath == null || classpath.equals("")) {        classpath = CLASS_PATH;    }         StringTokenizer st = new StringTokenizer(classpath, PATH_SEPARATOR);    ZipFile zf;    while (st.hasMoreTokens()) {      file = new File(st.nextToken());                    try {        if (file.isDirectory()) {                              file = new File(file, className);          classBytes = loadFile(file);          if (classBytes != null) {            break;          }         } else {          zf = new ZipFile(file);          classBytes = loadFile(zf, className);          if (classBytes != null) {            break;          }         }      } catch (IOException e) {              }     }         if (classBytes != null) {      try {        c = defineClass(argClassName, classBytes, 0, classBytes.length);      } catch (SecurityException e) {                c = Class.forName(argClassName);      } catch (ClassFormatError e) {         c = Class.forName(argClassName);      } catch (NoClassDefFoundError e) {        c = Class.forName(argClassName);      }      return c;    } else {      try {        return Class.forName(argClassName);      } catch (ClassNotFoundException e) {        throw new ClassNotFoundException(argClassName);      }     }   }
    public void checkExit(int param1) {        if (param1 != 7) {            throw new SecurityException();        }    }
    public void checkExec(String param1) {    }
    public void checkRead(String param1) {    }
    public void checkPermission(Permission param1) {    }
    public void checkCreateClassLoader() {    }
    public void checkPropertiesAccess() {    }
    public void checkPropertyAccess(String param1) {    }
    public void checkAccept(String param1, int param2) {    }
    public void checkConnect(String param1, int param2, Object param3) {    }
    public void checkListen(int param1) {    }
  public static void setProjectValues(String projectName,                                      String projectClassPath) {    try {      currentProjectName = projectName;      ProjectClasses pc = new ProjectClasses(projectClassPath);      projectCache.put(projectName, pc);    } catch (IOException e) {      e.printStackTrace(System.err);    }   }
  public static String getCurrentProjectName() {    return currentProjectName;  }
  public static void classExists(String fqn) {    DynamicClassLoader dcl = new DynamicClassLoader();    while (fqn != null) {      try {        dcl.loadClass( fqn );        System.out.println( "" + fqn + "");        return;      } catch (ClassNotFoundException | NoClassDefFoundError e) {      } catch (Exception e) {        System.out.println("" + fqn +                           "" + e + "");        return;      } catch (UnsatisfiedLinkError e) {                        System.out.println("" + fqn +                           "" + e + "");        return;      } catch (LinkageError e) {        System.out.println("" + fqn +                           "" + e + "");        return;      }            int index = fqn.lastIndexOf('');      if (index != -1) {        fqn = fqn.substring (0, index) + '' + fqn.substring (index + 1);      } else {        fqn = null;      }    }    System.out.println(NIL);                }
  public static void updateClassList() {    updateClassList(null);  }
  public static void getQualifiedName(String className) {    try {      ProjectClasses pc = projectCache.get(currentProjectName);      StringBuilder result = new StringBuilder(START_PAREN);      result.append(LIST);      for (String o : pc.getClassNames(className)) {        result.append(SPACE);        result.append(DOUBLE_QUOTE);        result.append(o);        result.append(DOUBLE_QUOTE);      }      result.append(END_PAREN);      System.out.println(result.toString());      System.out.flush();    } catch (IOException e) {      e.printStackTrace(System.err);    }   }
    public List getAsList(Object key) {        if (containsKey(key)) {            Object o = get(key);            if (o instanceof List) {                return (List)o;            } else {                return Arrays.asList(o);            }        } else {            return Collections.emptyList();        }    }
    public Object put(Object key, Object value) {        if (containsKey(key)) {            Object other = get(key);            if (other instanceof List) {                ((List)other).add(value);            } else {                List l = new ArrayList();                l.add(other);                l.add(value);                super.put(key, l);            }         } else {            super.put(key,value);        }        return null;    }
  void reloadClasses() throws IOException {    for (ClassPathEntry cpe : classPathEntries) {      cpe.reload();    }  }
  public String getClassPath() {    return classPath;  }
  List<String> getClassNames(String unqualifiedName) throws IOException {    List<String> rv = new ArrayList<>();    for (ClassPathEntry cpe : classPathEntries) {      @SuppressWarnings("")      List<String> classNames = (List<String>) cpe.getClassNames(unqualifiedName);      for (String className : classNames) {        if (!rv.contains(className)) {          rv.add(className);        }      }    }    return rv;  }
  static void loadBootClassPathEntries() throws IOException {    String bootClassPath = System.getProperty("");    String extDirs = System.getProperty("");    if (bootClassPath != null) {      StringTokenizer st = new StringTokenizer(bootClassPath, File.pathSeparator);      while (st.hasMoreTokens()) {        File file = new File(st.nextToken());        addToBootClassPath(file);      }    }            if (extDirs != null) {      StringTokenizer st = new StringTokenizer(extDirs,File.pathSeparator);             while (st.hasMoreTokens()) {        File[] extFiles = new File(st.nextToken()).listFiles();         if (extFiles != null) {                    for (int i = 0; i < extFiles.length; i++) {            addToBootClassPath(extFiles[i]);          }        }      }    }  }
public AbstractClassFactory(NameFactory factory) {        super(factory);    }
    public void process(String name, boolean truncate)        throws ClassNotFoundException, NotAnAbstractClassException {        if (null == namefactory)            namefactory = new DefaultNameFactory();            Class aclass = Class.forName(name);        int iModifiers = aclass.getModifiers();        if (!Modifier.isAbstract(iModifiers))            throw new NotAnAbstractClassException(name);            Vector methods = new Vector();        getAbstractMethods(aclass, methods);        int size = methods.size();        for (int i = 0; i < size; i++)            sortByDeclaringClass(new Signature((Method)methods.get(i),                                               this,                                               truncate));    }
    private void getAbstractMethods(Class argClass, Vector abstractMethods) {        Method[] methods = argClass.getMethods();        Method[] declaredMethods = argClass.getDeclaredMethods();        addMethods(methods, abstractMethods);        addMethods(declaredMethods, abstractMethods);    }
    private void addMethods(Method[] methods, Vector abstractMethods) {        Method method;        int modifiers;        for (int i = 0; i < methods.length; i++) {            method = methods[i];            modifiers = method.getModifiers();                        if (Modifier.isAbstract(modifiers)                && !abstractMethods.contains(method)) {                abstractMethods.add(method);            }         }     }
    public static void makeAbstractClassExpression         (String name, boolean truncate) {            if (abstractClassFactory == null)            abstractClassFactory = new AbstractClassFactory();            abstractClassFactory.flush();        abstractClassFactory.makeAbstractClassExpressionInternal(name,                                                                 truncate);    }
    private void makeAbstractClassExpressionInternal         (String name, boolean truncate) {        try {            process(name, truncate);        } catch (ClassNotFoundException e) {            println(""                     + name + "" + "");            return;        } catch (NotAnAbstractClassException e) {            println("" + name                    + "");            return;        } catch (Exception e) {            e.printStackTrace();            println("");            return;        }        dumpExpression(new PrintWriter(System.out, true), truncate);    }
  public String getParameterName(Signature sig, int num) {    Method method = sig.getMethod();    String  methodName = method.getName();    Class[] parameters = method.getParameterTypes();    Class   type = parameters[num];        String  className = type.getName().replace('', '');         if (methodName.length() > 3) {      if (methodName.startsWith("")) {        if (parameters.length == 2) {                    if (num == 1 && className.equals("")) {            return "";          }          if (num == 2) {            return methodToParamName(methodName, 3);          }        }                      if (parameters.length == 1 && num == 1) {          return methodToParamName(methodName, 3);        }      }      if (methodName.startsWith("")) {                if (parameters.length == 1 && num == 1 && className.equals(""))          return "";      }    }    return unique(parameters, type, num, getNameFromClass(className));  }
  private final String getNameFromClass(String className) {                        int i = className.lastIndexOf('')+1;          if (Character.isUpperCase(className.charAt(i))) {      className = Introspector.decapitalize(className.substring(i));                  if (className.endsWith("")) {        className = className.substring(0, className.length()-1) + "";      }      if (className.equals("")) className = "";      return className;    }        if (className.equals("")) {      return "";    }            if (className.equals("")) {      return "";    }            if (className.equals(""))      return "";    if (className.equals(""))      return "";    if (className.equals(""))      return "";    if (className.equals(""))      return "";    if (className.equals(""))      return "";    if (className.equals(""))      return "";        if (className.equals(""))      return "";    if (className.equals(""))      return "";    if (className.equals(""))      return "";    if (className.equals(""))      return "";    if (className.equals(""))      return "";    if (className.equals(""))      return "";    if (className.equals(""))      return "";    if (className.equals(""))      return "";        return "";  }
  private final String unique(Class[] parameters, Class type, int num, String name) {    if (parameters.length > 1) {      int i = 0;      for (int j = 0; j < num; ++j)        if (parameters[j] == type)          ++i;      if (i != 0)        name += i;    }    return name;      }
  private final String methodToParamName(String name, int strip) {    return Introspector.decapitalize(name.substring(strip));  }
public DelegateFactory() { }
public DelegateFactory(NameFactory factory) {    super(factory);  }
  public SignatureContainer getSignatures()  {    return this.signatures;  }
  public void setSignatures(SignatureContainer argSignatures) {    this.signatures = argSignatures;  }
  public static DelegateFactory getTheFactory()  {    return DelegateFactory.delegateFactory;  }
  public static void setTheFactory(DelegateFactory argDelegateFactory) {    DelegateFactory.delegateFactory = argDelegateFactory;  }
  public String getDelegee()  {    return this.delegee;  }
  public void setDelegee(String argDelegee) {    this.delegee = argDelegee;  }
  public void flush() {    super.flush();    signatures.clear();  }
  public void process(String delegeeClassName, boolean truncate)    throws ClassNotFoundException {        if (null == namefactory) {      namefactory = new DefaultNameFactory();    }        Class aclass = Class.forName(delegeeClassName);        Method[] methods = aclass.getMethods();    for (int i = 0; i < methods.length; i++) {      if (!(methods[i].getDeclaringClass().getName().equals("")            && Modifier.isFinal(methods[i].getModifiers()))) {        signatures.add(new Signature(methods[i], this, truncate, true));      }    }  }
  private void makeDelegatorMethodsInternal(String delegeeFieldName,                                            String delegeeClassName,                                            boolean truncate) {    delegee = delegeeFieldName;        try {      process(delegeeClassName, truncate);    } catch (ClassNotFoundException e) {      println(""              + delegeeClassName + ""              + "");      return;    } catch (Exception e) {      println("");      return;    }    outputMethods(new PrintWriter(System.out, true), truncate);  }
  public static void makeDelegatorMethods(String delegeeFieldName,                                          String delegeeClassName,                                           boolean truncate) {    if (delegateFactory == null) {      delegateFactory = new DelegateFactory();    }    delegateFactory.flush();    delegateFactory.makeDelegatorMethodsInternal(delegeeFieldName,                                                 delegeeClassName,                                                 truncate);  }
  public static void getImportedClasses() {    println(delegateFactory.getImportsAsList());  }
  protected String getDefaultBody (Signature sig) {    Method m = sig.getMethod();    Class cl = m.getReturnType();    String defBody = "";    defBody = delegee + "" + m.getName()       + "" + sig.getParameterNames() + "";    if (!cl.getName().equals("")) {      defBody = "" + defBody;    }    return defBody;  }
  public void outputMethods(PrintWriter out, boolean truncate) {    final StringBuffer buf = new StringBuffer      ("");    signatures.visit(new SignatureVisitor() {        public void visit(Signature sig , boolean firstOfClass) {          if (firstOfClass) {            buf.append ("");            buf.append("");            buf.append(sig.getDeclaringClass().getName());            buf.append("");            buf.append(delegee);            buf.append("");          }          buf.append ("");          buf.append(getMethodSkeletonExpression(sig));          buf.append ("");        }      });        buf.append("");    println(buf.toString());  }
public EventSourceFactory(NameFactory factory)
  public static void makeEventSourceSupportExpression      (String listenerName, boolean truncate) {    if (eventSourceFactory == null) {      eventSourceFactory = new EventSourceFactory();    }    eventSourceFactory.flush();    eventSourceFactory.makeEventSourceSupportExpressionInternal(listenerName, truncate);  }
  private void makeEventSourceSupportExpressionInternal      (String name, boolean truncate)   {    try     {      listenerClass = Class.forName( name );      listenerClassNameFQN= listenerClass.getName();      listenerClassName = listenerClass.getName().substring( listenerClass.getName().lastIndexOf('')+1);      StringBuffer buf = new StringBuffer( listenerClassName );      buf.setCharAt( 0, Character.toLowerCase(listenerClassName.charAt( 0 )) );      listenerVectorName = buf.toString()+"";    }    catch (ClassNotFoundException e) {      println("" + name + ""      + "");      return;    }    super.implementInterface(name, truncate);  }
  public static void addClassesFromZip(Vector classList,       File classPathFile) {            try {      ZipFile zipFile = new ZipFile(classPathFile);      Enumeration en = zipFile.entries();      while (en.hasMoreElements()) {ZipEntry zipEntry = (ZipEntry)en.nextElement();String current = zipEntry.getName();if (current.toLowerCase().endsWith("")) {  current = current.substring(0, current.length() - 6);  current = current.replace('', '');  current = current.replace('', '');  classList.addElement(current);}      }    } catch (Exception ex) {      System.err.println("" + classPathFile + "");    }  }
  public static void addClassesFromDir(Vector classList,       File rootDir,       File currentDir) {        String [] files = currentDir.list();    for (int i = 0; i < files.length; i++) {      String current = files[i];      if (current.toLowerCase().endsWith("")) {current = current.substring(0, current.length() - 6);String rootPath = rootDir.getPath();String currentPath = currentDir.getPath();if (currentPath.indexOf(rootPath) != 0) {  System.err.println(""     + "" + rootPath + ""     + "" + currentPath + "");} else {  String packageName = currentPath.substring(rootPath.length());  if (packageName.length() > 0) {        packageName = packageName.replace('', '');    packageName = packageName.replace('', '');    classList.addElement(packageName.substring(1) + '' + current);  } else {        classList.addElement(current);  }}      } else {File currentFile = new File(currentDir, current);if (currentFile.isDirectory()) {  addClassesFromDir(classList, rootDir, currentFile);}      }    }  }
  public static void makeImportStatement(String className) {    String importList = "";        for (int i = 0; i < CLASS_LIST.size(); i++) {      String testName = (String) CLASS_LIST.elementAt(i);            if ((testName.length() > className.length() && testName.endsWith(className) &&   testName.charAt(testName.length() - className.length() - 1) == '') ||  (testName.length() == className.length()) && testName.equals(className)) {testName = "" +  testName + "";if (importList.indexOf(testName) == -1)          importList += testName;      }    }    importList += "";        System.out.println(importList);    System.out.flush();  }
  public static void main(String[] args) {    if (args.length == 0) {      System.out.println("");    } else {      for (int i = 0; i < args.length; i++) {System.out.println("" + args[i] + "");makeImportStatement(args[i]);      }    }  }
public InterfaceFactory(NameFactory factory) {    super(factory);  }
  public SignatureContainer getSignatures()  {    return this.signatures;  }
  public void setSignatures(SignatureContainer argSignatures) {    this.signatures = argSignatures;  }
  public static InterfaceFactory getTheFactory()  {    return InterfaceFactory.interfaceFactory;  }
  public static void setTheFactory(InterfaceFactory argInterfaceFactory) {    InterfaceFactory.interfaceFactory = argInterfaceFactory;  }
  protected final void sortByDeclaringClass(Signature sig) {    signatures.add(sig);  }
  public void flush() {    super.flush();    signatures.clear();  }
  public void process(String name, boolean truncate)    throws ClassNotFoundException, NotAnInterfaceException {        if (null == namefactory) {      namefactory = new DefaultNameFactory();    }        Class aclass = Class.forName(name);    if (false == aclass.isInterface()) {      throw new NotAnInterfaceException(name);    }        Method[] methods = aclass.getMethods();        for (int i = 0; i < methods.length; i++) {      sortByDeclaringClass(new Signature(methods[i], this, truncate));    }  }
  protected void implementInterface(String name, boolean truncate) {        try {      process(name, truncate);    } catch (ClassNotFoundException e) {      println("" + name + ""              + "");      return;    } catch (NotAnInterfaceException e) {      println("" + name + "");      return;    } catch (Exception e) {      println("");      return;    }    dumpExpression(new PrintWriter(System.out, true), truncate);  }
  public static void makeInterfaceExpression(String name, boolean truncate) {    InterfaceFactory theFactory = getTheFactory();    if (theFactory == null) {      theFactory = new InterfaceFactory();      setTheFactory(theFactory);    }    theFactory.flush();    theFactory.implementInterface(name, truncate);  }
  public static void getImportedClasses() {    println(interfaceFactory.getImportsAsList());  }
  public void dumpExpression(PrintWriter out, boolean truncate) {        final StringBuffer buf =      new StringBuffer("");        signatures.visit(new SignatureVisitor() {        public void visit(Signature sig , boolean firstOfClass) {          if (firstOfClass) {            buf.append ("");            buf.append("");            buf.append(sig.getDeclaringClass().getName());            buf.append("");          }          buf.append ("");          buf.append(getMethodSkeletonExpression(sig));          buf.append ("");        }      }                     );    buf.append("");    println(buf.toString());  }
public MethodFactory() {    this(new DefaultNameFactory());  }
public MethodFactory(NameFactory factory) {    namefactory = factory;  }
  public void setNameFactory(NameFactory factory) {    namefactory = factory;  }
  public NameFactory getNameFactory() {    return namefactory;  }
  public Hashtable getImports() {    return imports;  }
  public String getImportsAsList() {    StringBuffer res = new StringBuffer ("");    Enumeration i = imports.keys();    while (i.hasMoreElements()) {      Class c = (Class) i.nextElement();      String className = c.getName();                                                      int idx = className.indexOf('');      if (idx > -1) {        className = className.substring(0, idx);      }            res.append ("" + className + "");    }    res.append ("");    return res.toString();  }
  public void registerImport(Class register) {    if (register.isArray()) {      try {        Class cl = register;                while (cl.isArray()) {          cl = cl.getComponentType();        }                register = cl;      } catch (Throwable t) {        throw new RuntimeException(""                                   + t);      }    }        if (shouldImport(register)) {      imports.put(register, "");    }  }
  private final boolean shouldImport(Class c) {            return ! c.isPrimitive();                  }
  protected String getDefaultBody (Signature sig) {    Method m = sig.getMethod();    Class cl = m.getReturnType();    if (numericTypesList.contains(cl.getName())) {      return "";    } else if (cl.getName().equals("")) {      return "";    } else if (!cl.getName().equals("")) {      return "";    }    return "";  }
  public String getMethodSkeletonExpression (Signature sig)  {    StringBuffer res = new StringBuffer();    res.append ("");    res.append ("" + sig.getModifiers() + "");    res.append ("" + sig.getReturnBaseType() + "");    res.append ("" + sig.getMethod().getName() + "");    res.append ("" + sig.getParameters() + "");    res.append ("" + sig.getExceptionList() + "");    res.append ("" + getDefaultBody (sig) + "");    return res.toString();  }
  public void flush() {    imports.clear();  }
  public static void println(String s) {    System.out.print(s + "");    System.out.flush();  }
public MethodOverrideFactory(NameFactory factory)
  private Vector getOverrideableMethods(Class cl, String methodName) {        Vector m = new Vector();    Class baseClass = cl;    while (baseClass != null) {      Method[] methods = baseClass.getDeclaredMethods();      for (int i = 0; i < methods.length; i++) {        if (methods[i].getName().equals(methodName)) {          int methodModifiers = methods[i].getModifiers();          if ((Modifier.isPublic(methodModifiers) ||               Modifier.isProtected(methodModifiers)) &&              !Modifier.isFinal(methodModifiers))            m.addElement(methods[i]);        }      }      baseClass = baseClass.getSuperclass();    }    return m;  }
  public static void getCandidateSignatures(String baseClassName, String methodName) {    if (overrideFactory == null)       overrideFactory = new MethodOverrideFactory();    else      overrideFactory.flush();    overrideFactory.baseClassName = baseClassName;    overrideFactory.methodName = methodName;    try {      DynamicClassLoader dcl = new DynamicClassLoader();      Vector methods = overrideFactory.getOverrideableMethods          (dcl.loadClass(baseClassName), methodName);      for (int i = 0; i < methods.size(); ++i) {        Method m = (Method) methods.elementAt(i);        Signature s = new Signature(m, overrideFactory);        boolean containsSignature = false;        for (int j = 0; j < overrideFactory.candidates.size(); ++j)           if (s.equals(overrideFactory.candidates.elementAt(j))) {            containsSignature = true;            break;          }        if (! containsSignature)           overrideFactory.candidates.addElement(s);      }      int n = overrideFactory.candidates.size();      if (n > 0) {String res = "";for (int i = 0; i < n; ++i) {  Signature s = (Signature) overrideFactory.candidates.elementAt(i);          s.setTruncating(false);  String p = s.getParameters(s.getMethod().getParameterTypes(), false);          s.setTruncating(true);  res = res + "" + methodName + "" + p +  "";}res = res + "";println(res);      }      elseprintln("" +methodName + "" + baseClassName + "");    }    catch (ClassNotFoundException ee) {      println("" +       baseClassName + "");    }  }
  public void flush()  {    super.flush();    candidates.removeAllElements();  }
  public static void main (String[] args) {    String className = "";    String methodName = "";        if (args.length == 2) {      className = args[0];      methodName = args[1];    }    System.out.println("" + className);    System.out.println("" + methodName);    getCandidateSignatures(className, methodName);           }
public Signature (Method meth, ClassRegistry aregistry) {    this(meth, aregistry, true);  }
public Signature (Method meth, ClassRegistry aregistry, boolean truncate) {    this(meth, aregistry, truncate, false);  }
public Signature (Method meth, ClassRegistry aregistry, boolean truncate)
  public void setTruncating(boolean b) {    truncate = b;  }
  public void setRegistry(ClassRegistry registry) {    this.registry = registry;  }
  public Class getDeclaringClass () {    return declaring;  }
  public String toJavaDoc() {    NameFactory factory = registry.getNameFactory();    StringBuffer buf = new StringBuffer("");        for (int i = 0; i < parameters.length; i++) {      buf.append(""                 + factory.getParameterName(this, i)                 + "");    }    if (!"".equals(returnValue.getName())) {      buf.append("" + "");    }        for (int i = 0; i < exceptions.length; i++) {      buf.append("" + exceptions[i].getName()                 + "");    }        if (see) {      buf.append("");      buf.append(method.getDeclaringClass().getName());      buf.append('');      buf.append(method.getName());      buf.append('');      buf.append(getParameters(method.getParameterTypes(), false));      buf.append('');      buf.append("");    }        buf.append("");        return buf.toString();  }
  public String toString() {    String m    = getModifiers();    String r    = baseName(returnValue);    String meth = method.getName();    String p    = getParameters(parameters);    String e    = getExceptions(exceptions);    return m + "" + r + "" + meth + "" + p + "" + e;  }
  public boolean paramsEqual(Class[] p) {    int n = parameters.length;    boolean res = (p.length == n);    if (res) {      for (int i = 0; i < n; ++i) {        if (!p[i].equals(parameters[i])) {          res = false;          break;       }      }    }    return res;  }
  public boolean equals(Object compare) {    if (compare instanceof Signature) {      Signature sig = (Signature) compare;      return method.getName().equals(sig.getMethod().getName())        && paramsEqual(sig.getMethod().getParameterTypes());    }    return false;  }
  public Method getMethod() {    return method;  }
  public final String baseName(Class type) {    String name = null;    if (type.isArray()) {      try {                Class cl       = type;        int dimensions = 0;                while (cl.isArray()) {          cl = cl.getComponentType();          dimensions++;        }                StringBuffer sb = new StringBuffer();        sb.append(cl.getName());                for (int i = 0; i < dimensions; i++) {          sb.append("");        }                name = sb.toString();      } catch (Throwable e) {        name = type.getName();      }    } else {         name = type.getName();        }                                    if (truncate) {      int idx = name.lastIndexOf('');            if (idx > -1) {        name = name.substring(idx + 1);      }    }                                      name =  name.replace('', '');    return name;  }
  public final String getExceptionList(Class[] except) {        if ((null == except) || (except.length == 0)) {      return "";    }    StringBuffer buf = new StringBuffer();        for (int i = 0; i < except.length; i++) {      String type = baseName(except[i]);      buf.append(type);      if (i < except.length - 1) {        buf.append("");      }          }        return buf.toString();  }
  private final String getExceptions(Class[] except) {    String res = getExceptionList (except);        if (res.length() == 0) {      return res;    }        return "" + res;  }
  public final String getParameters (Class[] params, boolean withName) {        if ((null == params) || (params.length == 0)) {      return "";    }        StringBuffer buf = new StringBuffer();    NameFactory factory = registry.getNameFactory();    for (int i = 0; i < params.length; i++) {      String type = baseName(params[i]);      String name = factory.getParameterName(this, i);      buf.append(type);      if (withName) {        buf.append('');        buf.append(name);      }      if (i < params.length - 1) {        buf.append("");      }          }    return buf.toString();  }
  public final String getParameterNames (Class[] params) {        if ((null == params) || (params.length == 0)) {      return "";    }        StringBuffer buf = new StringBuffer();    NameFactory factory = registry.getNameFactory();    for (int i = 0; i < params.length; i++) {      String type = baseName(params[i]);      String name = factory.getParameterName(this, i);      buf.append(name);      if (i < params.length - 1) {        buf.append("");      }          }    return buf.toString();  }
  public final String getModifiers () {    StringBuffer buf = new StringBuffer("");    int mod = method.getModifiers();    if (Modifier.isSynchronized(mod)) {      buf.append("");    }        return buf.toString();  }
  public String getReturnBaseType () {    return baseName(returnValue);  }
  private final void register() {    if (null != registry) {      registry.registerImport(declaring);      registry.registerImport(returnValue);          for (int i = 0; i < parameters.length; i++) {        registry.registerImport(parameters[i]);      }      for (int i = 0; i < exceptions.length; i++) {        registry.registerImport(exceptions[i]);      }    }  }
  public final void add(Signature sig) {            if (!alreadyStored(sig)) {            String declaring = sig.getDeclaringClass().getName();            if (classes.containsKey(declaring)) {          ((Vector) classes.get(declaring)).addElement(sig);      } else {            Vector v = new Vector();        v.addElement(sig);        classes.put(declaring, v);      }        }  }
  private final boolean alreadyStored(Signature sig) {    Enumeration declaringClasses = classes.keys();    boolean found = false;        while (declaringClasses.hasMoreElements() && !found) {      String interf = (String) declaringClasses.nextElement();      Vector v = (Vector) classes.get(interf);      found = v.contains(sig);    }    return found;  }
  public void clear() {    classes.clear();  }
  public boolean isEmpty() {    return classes.isEmpty();  }
  public void visit(SignatureVisitor visitor) {        Enumeration declaringClasses = classes.keys();    while (declaringClasses.hasMoreElements()) {            String className = (String) declaringClasses.nextElement();      Vector v = (Vector) classes.get(className);      boolean firstOfClass = true;      Enumeration e = v.elements();            while (e.hasMoreElements()) {        Signature sig = (Signature) e.nextElement();        visitor.visit(sig, firstOfClass);        firstOfClass = false;      }    }  }
public CallbackImpl() {    }
public LinkList(){        head=new Node();    }
    public void clear() {        head.data=null;        head.next=null;    }
    public boolean isEmpty() {        return head.next==null;    }
    public int length() {        int length=0;        Node p=head.next;        while(p!=null){            length++;            p=p.next;        }        return length;    }
    public Object get(int i) throws Exception {        int j=0;        Node p=head.next;        while(p!=null&&j<i){            j++;            p=p.next;        }        if(i<0||p==null){            throw new Exception(""+i+"");        }        return p.data;    }
    public void insert(int i, Object x) throws Exception {        Node p=this.head;        int j=-1;        while(p.next!=null&&j<i-1){            p=p.next;            j++;        }                if(j>i-1||p==null){            throw new Exception("");        }        Node s=new Node(x);        s.next=p.next;        p.next=s;    }
    public void remove(int i) throws Exception {        int j=0;        Node p=head;                while(p!=null&&j<i){            p=p.next;            j++;        }        if(j>i||p==null){            throw new Exception("");        }                p.next=p.next.next;            }
    public int indexOf(Object x)  {        Node p=head.next;        int j=0;        while(p!=null&&!p.data.equals(x)){            p=p.next;            j++;        }        if(p==null){            return -1;        }        return j;    }
    public void display() {        Node p=head.next;        while(p!=null){            System.out.print(p.data+"");            p=p.next;        }        System.out.println();    }
    public void insertf(int i,Object x) throws Exception{        Node p=head;        int j=-1;        while(p!=null&&j<i-1){            p=p.next;            j++;        }        if(j>=i||p==null){            throw new Exception("");        }        Node s=new Node(x);        if(i==0){            s.next=head;            head=s;        }else{            s.next=p.next;            p.next=s;        }    }
    public void delete(int i,Object x) throws Exception{        Node q,p=head;        int j=0;        while(p!=null&&j<i-1){            p=p.next;            j++;        }        if(j>i||p==null){            throw new Exception("");        }        if(i==0){            head=p.next;            p=null;        }else{            q=p.next;            p.next=p.next;            q=null;        }    }
    public void insert1(int x){        Node p=head;        Node q=head.next;        while(q!=null){            int temp=((Integer)q.data).intValue();            if(temp<x){                p=q;                q=q.next;            }else{                break;            }        }        Node s=new Node(x);        p.next=s;        s.next=q;    }
    public void insert2(int x){        Node p=head;        while(p.next!=null&&(Integer)p.next.data<x){            p=p.next;        }        Node s=new Node(x);        s.next=p.next;        p.next=s;    }
    public static void rervse(LinkList L){        Node q=L.head.next;        Node p;        L.head.next=null;        while(q!=null){            p=q.next;            q=L.head.next;            L.head.next=q;            q=p;        }    }
    private LinkStack numSplit(String str) throws Exception {        LinkStack stack = new LinkStack();        if (StringUtils.isBlank(str)){            throw new Exception(""+str+"");        }        StringBuffer sb = new StringBuffer(str);        int length = sb.length();        char c = 0;        for (int i = 0;i < length;i++){           c = sb.charAt(i);                      if('' == c){               continue;           }                      if(Character.isDigit(c)){               stack.push(Integer.valueOf(String.valueOf(c)));           }else {               throw new Exception("");           }        }        return stack;    }
    public String add(String x1,String x2) throws Exception{                int a = 0;        int b = 0;        int sum = 0;        int partialSum = 0;        String result = "";                LinkStack sA = numSplit(x1);        LinkStack sB = numSplit(x2);        LinkStack sumC = new LinkStack();        LinkStack temp = null;                        while (!sA.isEmpty() && !sB.isEmpty()){            a = (Integer) sA.pop();            b = (Integer) sB.pop();                        sum = a+b+partialSum;                        sumC.push(sum%10);            partialSum = sum/10;        }                temp = sA.isEmpty() ? sB : sA;                while (!temp.isEmpty() && partialSum != 0){            a = (Integer) temp.pop();            sum = a + partialSum;            sumC.push(sum%10);            partialSum = sum/10;        }                while (!temp.isEmpty()){           sumC.push(temp.pop());        }                if(partialSum != 0){            sumC.push(partialSum);        }                while (!sumC.isEmpty()){            result =  result.concat(String.valueOf(sumC.pop()));        }        return result;    }
    private int judgeStringNum(LinkStack sA,LinkStack sB) throws Exception {        int result = -1;        if(sA.isEmpty() || sB.isEmpty()){            throw new Exception("");        }                String num1 = sA.toString();        String num2 = sB.toString();        int lengthSA = sA.length();        int lengthSB = sB.length();        result = lengthSA - lengthSB;        if (result == 0){            result = num1.compareTo(num2);        }        return result;    }
    public String minus(String x1,String x2) throws Exception{                int a = 0;        int b = 0;        int sum = 0;        int partialSum = 0;        String result = "";        String symbol = "";                LinkStack sA = numSplit(x1);        LinkStack sB = numSplit(x2);        LinkStack sumC = new LinkStack();        LinkStack temp = null;                int compare = judgeStringNum(sA, sB);        if(compare < 0){                        symbol = symbol.concat("");                        temp = sA;            sA = sB;            sB = temp;        }                if(compare != 0){                        while (!sB.isEmpty()){                a = (Integer) sA.pop();                b = (Integer) sB.pop();                                sum = a-b+partialSum;                                if(sum < 0){                                        sum += 10;                    partialSum = -1;                }else {                    partialSum = 0;                }                sumC.push(sum);            }                        temp = sA;                        while (!temp.isEmpty() && partialSum != 0){                a = (Integer) temp.pop();                sum = a + partialSum;                                if(sum < 0){                    sum += 10;                    partialSum = -1;                }else {                    partialSum = 0;                }                sumC.push(sum);            }                        while (!temp.isEmpty()){                sumC.push(temp.pop());            }                        while (!sumC.isEmpty()){                result =  result.concat(String.valueOf(sumC.pop()));            }                        int length = result.length();            char c = '';                        int index = 0;            for(int i = 0; i< length;i++){                c = result.charAt(i);                if (c == ''){                    index ++;                }else {                    break;                }            }            if(index > 0){                result = result.substring(index);            }                        result = symbol + result;        }else {            result = "";        }        return result;    }
    private int verifyFlag(String str){        int result = OTHER;        if("".equals(str) || "".equals(str) ||        "".equals(str) || "".equals(str)){            result = LEFT;        }else if("".equals(str) || "".equals(str) ||                "".equals(str) || "".equals(str)){            result = RIGHT;        }        return result;    }
    private boolean matches(String str1,String str2){        boolean flag = false;        if("".equals(str1) && "".equals(str2) || "".equals(str1) && "".equals(str2) ||                "".equals(str1) && "".equals(str2) || "".equals(str1) && "".equals(str2)){            flag = true;        }        return flag;    }
    public boolean isLeagal(String str) throws Exception {        boolean flag = false;                if (StringUtils.isNotBlank(str)){            SqStack S = new SqStack(100);            StringBuffer sb = new StringBuffer(str);            int length = sb.length();            char c = 0;            String t = null;            int verify = 0;            Object obj = null;            for(int i = 0; i< length;i++){                c = sb.charAt(i);                t = String.valueOf(c);                if(i != length){                    if('' == c && '' == sb.charAt(i+1) ||                            '' == c && '' == sb.charAt(i+1)){                        t = t.concat(String.valueOf(sb.charAt(i+1)));                        ++i;                    }                }                                verify = verifyFlag(t);                                if(LEFT == verify){                                        S.push(t);                }else if(RIGHT == verify){                                        obj = S.pop();                                        if(obj == null || !matches(obj.toString(),t)){                        flag = true;                        break;                    }                }            }                        if(!S.isEmpty()){                flag = true;            }        }else {            flag = true;        }        return !flag;    }
public BiTree() {        this.root = null;    }
    public void inOrderTraverse(BiTreeNode p){        if(p != null){            inOrderTraverse(p.getLchild());            System.out.println(p);            inOrderTraverse(p.getRchild());        }    }
    private Object searchBST(BiTreeNode p,Comparable key){        Object result = null;                if(p != null){                        int count = key.compareTo(((RecordNode) p.getData()).getKey());                        if(count == 0){                result = p.getData();            }else if(count < 0){                result = searchBST(p.getLchild(),key);            }else {                result = searchBST(p.getRchild(),key);            }        }        return result;    }
    private Object removeBST(BiTreeNode p,Comparable key,BiTreeNode parent){        Object data = null;                if(p != null){                        int count = key.compareTo(((RecordNode) p.getData()).getKey());                        if(count < 0){                data = removeBST(p.getLchild(),key,p);            }                        else if(count > 0){                data = removeBST(p.getRchild(),key,p);            }                        else {                                                if(null != p.getLchild() && null != p.getRchild()){                                        BiTreeNode innext = p.getRchild();                    while (null != innext.getLchild()){                        innext = innext.getLchild();                    }                    p.setData(innext.getData());                                        data = removeBST(p.getRchild(),((RecordNode)innext.getData()).getKey(),p);                }else {                    data = p.getData();                    if( null == parent){                        if(null != p.getLchild()){                            root = p.getLchild();                        }else {                            root = p.getRchild();                        }                    }else {                        if(p == parent.getLchild()){                            if(null != p.getLchild()){                                parent.setLchild(p.getLchild());                            }else {                                parent.setLchild(p.getRchild());                            }                        }else if(null != p.getLchild()){                            parent.setRchild(p.getLchild());                        }else {                            parent.setRchild(p.getRchild());                        }                    }                }            }        }        return data;    }
public HashTable(int size) {        this.table = new LinkList[size];        for(int i = 0; i< size;i++){            table[i] = new LinkList();        }    }
    public LinkList[] getTable() {        return table;    }
    public void setTable(LinkList[] table) {        this.table = table;    }
    public int hash(int key){        return key % table.length;    }
    public void insert(E element) throws Exception {                int key = element.hashCode();        int index = hash(key);        this.table[index].insert(0,element);    }
    public void printHashTable(){        for(int i = 0; i< table.length;i++){            System.out.print(""+i+"");            this.table[i].display();        }    }
    public Node search(E element) throws Exception {        int key = element.hashCode();        int i = hash(key);        int index = table[i].indexOf(element);        Node node = null;        if(index >=0){            node =(Node) table[i].get(index);        }        return node;    }
    public boolean contain(E element){        Boolean falg = false;        int key = element.hashCode();        int i = hash(key);        int index = this.table[i].indexOf(element);        return index >= 0;    }
    public boolean remove(E element) throws Exception {        boolean flag = false;        int key = element.hashCode();        int i = hash(key);        int index = this.table[i].indexOf(element);        if(index >= 0){            this.table[i].remove(index);            flag = true;        }        return flag;    }
    public void testGetClass(){        System.out.println(Double.class.getName());                System.out.println(Float.class.getName());                System.out.println(Integer.class.getName());                System.out.println(String.class.getName());                Object mm = Double.valueOf("");                System.out.println(mm.getClass().getName());    }
    public void initBitree(){        biTree = new BiTree();                Integer [] k = {50,13,63,8,36,90,5,10,18,70};                String[] item = {"","","","","","","","","",""};        KeyType [] key = new KeyType[k.length];        ElementType [] elem = new ElementType[item.length];                System.out.println("");                for(int i = 0; i< k.length;i++){            key[i] = new KeyType(k[i]);                        elem[i] = new ElementType(item[i]);            biTree.insertBST(key[i],elem[i]);                    }        biTree.inOrderTraverse(biTree.root);    }
    public void ChessBoard(int tr,int tc,int dr,int dc,int size){                if(size == 1){            return;        }                int t = tile++;                int s = size/2;                                if(tr+s>dr && tc+s> dc){                        ChessBoard(tr,tc,dr,dc,s);        }else {                        Board[tr+s-1][tc+s-1] = t;                        ChessBoard(tr,tc,tr+s-1,tc+s-1,s);        }                        if(tr+s>dr && tc+s<= dc){                        ChessBoard(tr,tc+s,dr,dc,s);        }else {                        Board[tr+s-1][tc+s] = t;                        ChessBoard(tr,tc+s,tr+s-1,tc+s,s);        }                        if(tr+s<=dr && tc+s> dc){                        ChessBoard(tr+s,tc,dr,dc,s);        }else {                        Board[tr+s][tc+s-1] = t;                        ChessBoard(tr+s,tc,tr+s,tc+s-1,s);        }                        if(tr+s<=dr && tc+s<= dc){                        ChessBoard(tr+s,tc+s,dr,dc,s);        }else {                        Board[tr+s][tc+s] = t;                        ChessBoard(tr+s,tc+s,tr+s,tc+s,s);        }    }
    public void displayBoard(){        for(int i = 0; i< Board.length;i++){            for (int j = 0;j<Board[i].length;j++){                System.out.print(Board[i][j]+"");            }                        System.out.println();        }    }
    public double capir2(PointX[] X,PointY a,PointY b,int n) throws Exception {        if(n<2){            throw new Exception("");        }                divideAndConquer.MergeSort(X);                PointY[] Y = new PointY[n];        for(int i = 0; i< n;i++){            Y[i] = new PointY();            Y[i].setX(X[i].getX());            Y[i].setY(X[i].getY());            Y[i].setP(i);        }                divideAndConquer.MergeSort(Y);        PointY [] Z = new PointY[n];        double closet = closet(X, Y, Z, a, b, 0, n - 1);        return closet;    }
   private double closet(PointX[] X,PointY[] Y,PointY[] Z,                         PointY a,PointY b,int l,int r) throws Exception {        double minDistance = Double.MAX_VALUE;                switch ((r-l)){                        case 1:{                minDistance = point.distance(X[l],X[r]);                a.setX(X[l].getX());                a.setY(X[l].getY());                a.setP(l);                b.setX(X[r].getX());                b.setY(X[r].getY());                b.setP(r);                logger.debug(""+X[l].getID()+""+X[r].getID()+""+minDistance);                break;            }                        case 2:{                double d1 = point.distance(X[l],X[r]);                logger.debug(""+X[l].getID()+""+X[r].getID()+""+d1);                double d2 = point.distance(X[l],X[l+1]);                logger.debug(""+X[l].getID()+""+X[l+1].getID()+""+d2);                double d3 = point.distance(X[l+1],X[r]);                logger.debug(""+X[l+1].getID()+""+X[r].getID()+""+d3);                minDistance = Math.min(d1,d2);                minDistance = Math.min(minDistance,d3);                if(minDistance == d1){                    a.setX(X[l].getX());                    a.setY(X[l].getY());                    a.setP(l);                    b.setX(X[r].getX());                    b.setY(X[r].getY());                    b.setP(r);                }else if(minDistance == d2){                    a.setX(X[l].getX());                    a.setY(X[l].getY());                    a.setP(l);                    b.setX(X[l+1].getX());                    b.setY(X[l+1].getY());                    b.setP(l+1);                }else {                    a.setX(X[l+1].getX());                    a.setY(X[l+1].getY());                    a.setP(l+1);                    b.setX(X[r].getX());                    b.setY(X[r].getY());                    b.setP(r);                }                break;            }                        default:{                int m = (l+r)/2;                int f = l,g = m+1;                PointY ar= new PointY(),br=new PointY();                double distanceX = Double.MAX_EXPONENT;                double distanceY = Double.MAX_EXPONENT;                                for(int i = l; i<=r;i++){                    if(Y[i].getP() > m){                        Z[g++] = Y[i];                    }else {                        Z[f++] = Y[i];                    }                }                                double minDsitance1 = closet(X, Z, Y,a,b, l, m);                double minDsitance2 = closet(X, Z, Y, ar,br,m+1, r);                if(minDsitance1<minDsitance2){                    minDistance = minDsitance1;                }else {                    minDistance = minDsitance2;                    a.setX(ar.getX());                    a.setY(ar.getY());                    a.setP(ar.getP());                    b.setX(br.getX());                    b.setY(br.getY());                    b.setP(br.getP());                }                                divideAndConquer.Merge(Z,Y,l,m,r);                                int k = l,e = r;                for(int i = l; i<=r;i++){                    distanceX = X[m].getX() - Y[i].getX();                    if(0<=distanceX && distanceX < minDistance){                        Z[k++] = Y[i];                    }else if(distanceX < 0 && distanceX >-minDistance){                        Z[e--] = Y[i];                    }                }                                for(int i = l; i<k;i++){                    for (int j = r;j>e;j--){                        distanceY = Math.abs((Z[i].getY()-Z[j].getY()));                        if(distanceY < minDistance){                            distanceX = point.distance(Z[i],Z[j]);                            if(minDistance > distanceX){                                minDistance = distanceX;                                a.setX(Z[i].getX());                                a.setY(Z[i].getY());                                a.setP(Z[i].getP());                                b.setX(Z[j].getX());                                b.setY(Z[j].getY());                                b.setP(Z[j].getP());                                logger.debug(""+X[Z[i].getP()].getID()+""+X[Z[j].getP()].getID()+""+minDistance);                            }                        }                    }                }            }        }        return minDistance;    }
    public <T> T cloneObj(T obj){        T object = null;        try {            ByteArrayOutputStream baos = new ByteArrayOutputStream();            ObjectOutputStream oos = new ObjectOutputStream(baos);            oos.writeObject(obj);            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());            ObjectInputStream ois = new ObjectInputStream(bais);            object = (T) ois.readObject();        } catch (IOException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }        return object;    }
    public double distance(Point u,Point v){        double dx = u.x - v.x;        double dy = u.y - v.y;        return Math.sqrt(dx*dx+dy*dy);    }
    public int getID() {        return ID;    }
    public void setID(int ID) {        this.ID = ID;    }
    public void Perm(T [] list, int k, int m, List<String>result){                if(k == m){            result.add(StringUtils.join(list,""));        }else{                        for(int i = k; i<=m;i++){                Swap(list,k,i);                Perm(list,k+1,m,result);                Swap(list,k,i);            }        }    }
    public void PermReption(T [] list, int k, int m, List<String>result) throws Exception {                HashTable<T> tables = new HashTable<>(m-k+1);        if(k == m){            result.add(StringUtils.join(list,""));        }else{                        for(int i = k; i<=m;i++){                                if (!tables.contain(list[i])){                    tables.insert(list[i]);                    Swap(list,k,i);                    PermReption(list,k+1,m,result);                    Swap(list,k,i);                }            }        }    }
    public void Swap(T [] list,int a,int b){        T temp = list[a];        list[a] = list[b];        list[b] = temp;    }
public HttpClientUtil() {                httpClient = HttpClients.createDefault();    }
    public HttpResult doGet(String url, Map<String, Object> map) throws Exception {                URIBuilder uriBuilder = new URIBuilder(url);                if (map != null) {                        for (Map.Entry<String, Object> entry : map.entrySet()) {                                uriBuilder.setParameter(entry.getKey(), entry.getValue().toString());            }        }                HttpGet httpGet = new HttpGet(uriBuilder.build());                CloseableHttpResponse response = null;        try {            response = httpClient.execute(httpGet);        } catch (IOException e) {            HttpResult httpResult = new HttpResult();            httpResult.setCode(404);            httpResult.setBody("");            return httpResult;        }                                                HttpResult httpResult = new HttpResult();                if (response.getEntity() != null) {                        httpResult.setCode(response.getStatusLine().getStatusCode());            httpResult.setBody(EntityUtils.toString(response.getEntity(),""));        } else {                        httpResult.setCode(response.getStatusLine().getStatusCode());                    }                return httpResult;    }
    public HttpResult doPost(String url, Map<String, Object> map) throws Exception {                HttpPost httpPost = new HttpPost(url);                if (map != null) {                        List<NameValuePair> params = new ArrayList<NameValuePair>();                        for (Map.Entry<String, Object> entry : map.entrySet()) {                params.add(new BasicNameValuePair(entry.getKey(), entry.getValue().toString()));            }                        UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(params, "");                        httpPost.setEntity(formEntity);        }                CloseableHttpResponse response = null;        try {            response = httpClient.execute(httpPost);        } catch (IOException e) {            HttpResult httpResult = new HttpResult();            httpResult.setCode(404);            httpResult.setBody("");            return httpResult;        }                HttpResult httpResult = new HttpResult();                if (response.getEntity() != null) {                        httpResult.setCode(response.getStatusLine().getStatusCode());            httpResult.setBody(EntityUtils.toString(response.getEntity(),""));        } else {                        httpResult.setCode(response.getStatusLine().getStatusCode());                    }                return httpResult;    }
    public HttpResult doPut(String url, Map<String, Object> map) throws Exception {                HttpPut httpPut = new HttpPut(url);                if (map != null) {                        List<NameValuePair> params = new ArrayList<NameValuePair>();                        for (Map.Entry<String, Object> entry : map.entrySet()) {                params.add(new BasicNameValuePair(entry.getKey(), entry.getValue().toString()));            }                        UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(params, "");                        httpPut.setEntity(formEntity);        }                CloseableHttpResponse response = null;        try {            response = httpClient.execute(httpPut);        } catch (IOException e) {            HttpResult httpResult = new HttpResult();            httpResult.setCode(404);            httpResult.setBody("");            return httpResult;        }                HttpResult httpResult = new HttpResult();                if (response.getEntity() != null) {                        httpResult.setCode(response.getStatusLine().getStatusCode());            httpResult.setBody(EntityUtils.toString(response.getEntity(),""));        } else {                        httpResult.setCode(response.getStatusLine().getStatusCode());                    }                return httpResult;    }
    public HttpResult doDelete(String url, Map<String, Object> map) throws Exception {                URIBuilder uriBuilder = new URIBuilder(url);                if (map != null) {                        for (Map.Entry<String, Object> entry : map.entrySet()) {                                uriBuilder.setParameter(entry.getKey(), entry.getValue().toString());            }        }                HttpDelete httpDelete = new HttpDelete(uriBuilder.build());                CloseableHttpResponse response = null;        try {            response = httpClient.execute(httpDelete);        } catch (IOException e) {            HttpResult httpResult = new HttpResult();            httpResult.setCode(404);            httpResult.setBody("");            return httpResult;        }                                                HttpResult httpResult = new HttpResult();                if (response.getEntity() != null) {                        httpResult.setCode(response.getStatusLine().getStatusCode());            httpResult.setBody(EntityUtils.toString(response.getEntity(),""));        } else {                        httpResult.setCode(response.getStatusLine().getStatusCode());                    }                return httpResult;    }
    public HttpResult uploadFile(String url, File file, Map<String, Object> map) throws IOException {        CloseableHttpResponse response = null;        RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(200000).setSocketTimeout(200000000).build();        HttpPost httpPost = new HttpPost(url);        httpPost.setConfig(requestConfig);        MultipartEntityBuilder multipartEntityBuilder = MultipartEntityBuilder.create();                                                        multipartEntityBuilder.addBinaryBody("",file);                if (map != null) {                        for (Map.Entry<String, Object> entry : map.entrySet()) {                                multipartEntityBuilder.addTextBody(entry.getKey(), entry.getValue().toString());            }        }        HttpEntity httpEntity = multipartEntityBuilder.build();        httpPost.setEntity(httpEntity);        try {            response = httpClient.execute(httpPost);        } catch (IOException e) {            e.printStackTrace();            HttpResult httpResult = new HttpResult();            httpResult.setCode(404);            httpResult.setBody("");            return httpResult;        }        HttpResult httpResult = new HttpResult();                if (response.getEntity() != null) {                        httpResult.setCode(response.getStatusLine().getStatusCode());            httpResult.setBody(EntityUtils.toString(response.getEntity(),""));        } else {                        httpResult.setCode(response.getStatusLine().getStatusCode());                    }        return httpResult;    }
private void executeUpload(String uploadDir,MultipartFile file) throws Exception{String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(""));String filename = UUID.randomUUID() + suffix;File serverFile = new File(uploadDir + filename);file.transferTo(serverFile);}
    private <T> T getDAO(Class<T> clazz,HttpServletRequest request)    {        BeanFactory factory = WebApplicationContextUtils.getRequiredWebApplicationContext(request.getServletContext());        return factory.getBean(clazz);    }
    public static String getCliectIp(HttpServletRequest request)    {        String ip = request.getHeader("");        if (ip == null || ip.trim() == "" || "".equalsIgnoreCase(ip)) {            ip = request.getHeader("");        }        if (ip == null || ip.trim() == "" || "".equalsIgnoreCase(ip)) {            ip = request.getHeader("");        }        if (ip == null || ip.trim() == "" || "".equalsIgnoreCase(ip)) {            ip = request.getRemoteAddr();        }                final String[] arr = ip.split("");        for (final String str : arr) {            if (!"".equalsIgnoreCase(str)) {                ip = str;                break;            }        }        return ip;    }
    public static String getRequestType(HttpServletRequest request) {        return request.getHeader("");    }
public MailSender title(String title){        mail.setTitle(title);        return this;    }
public MailSender content(String content)
public MailSender contentType(MailContentTypeEnum typeEnum)
public MailSender targets(List<String> targets)
    public MailSender title(String title){        mail.setTitle(title);        return this;    }
    public MailSender content(String content)    {        mail.setContent(content);        return this;    }
    public MailSender contentType(MailContentTypeEnum typeEnum)    {        mail.setContentType(typeEnum.getValue());        return this;    }
    public MailSender targets(List<String> targets)    {        mail.setList(targets);        return this;    }
    public void send() throws Exception    {                if(mail.getContentType() == null)            mail.setContentType(MailContentTypeEnum.HTML.getValue());        if(mail.getTitle() == null || mail.getTitle().trim().length() == 0)        {            throw new Exception("");        }        if(mail.getContent() == null || mail.getContent().trim().length() == 0)        {            throw new Exception("");        }        if(mail.getList().size() == 0)        {            throw new Exception("");        }                final PropertiesUtil properties = new PropertiesUtil("");                final Properties props = new Properties();                props.put("", "");                props.put("", properties.getValue(""));                props.put("", properties.getValue(""));                props.put("", properties.getValue(""));                props.put("", properties.getValue(""));                Authenticator authenticator = new Authenticator() {            protected PasswordAuthentication getPasswordAuthentication() {                                String userName = props.getProperty("");                String password = props.getProperty("");                return new PasswordAuthentication(userName, password);            }        };                Session mailSession = Session.getInstance(props, authenticator);                MimeMessage message = new MimeMessage(mailSession);                String nickName = MimeUtility.encodeText(properties.getValue(""));        InternetAddress form = new InternetAddress(nickName + "" + props.getProperty("") + "");        message.setFrom(form);                message.setSubject(mail.getTitle());                if(mail.getContentType().equals(MailContentTypeEnum.HTML.getValue())) {                        message.setContent(mail.getContent(), mail.getContentType());        }                else if(mail.getContentType().equals(MailContentTypeEnum.TEXT.getValue())){            message.setText(mail.getContent());        }                List<String> targets = mail.getList();        for(int i = 0;i < targets.size();i++){            try {                                InternetAddress to = new InternetAddress(targets.get(i));                message.setRecipient(Message.RecipientType.TO, to);                                Transport.send(message);            }catch (Exception e)            {                continue;            }        }    }
public PropertiesUtil(String fileName)
    public String getValue(String key)    {        String message = this.resource.getString(key);        return message;    }
    public Enumeration<String> getKeys(){        return resource.getKeys();    }
    public void init() throws IOException, InterruptedException {        final CountDownLatch countDownLatch=new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                if (event.getState() == Event.KeeperState.SyncConnected && event.getType()== Watcher.Event.EventType.None){                    countDownLatch.countDown();                    logger.info("");                }            }        };        zooKeeper = new ZooKeeper(ZK_ADDRESS,SESSION_TIMEOUT,watcher);        logger.info("");        countDownLatch.await();    }
            public void process(WatchedEvent event) {                if (event.getState() == Event.KeeperState.SyncConnected && event.getType()== Watcher.Event.EventType.None){                    countDownLatch.countDown();                    logger.info("");                }            }
public static Message deserialize(byte[] buffer) {int address = buffer[0];int endpoint = buffer[1];int value = buffer[2] << 24 | buffer[3] << 16 | buffer[4] << 8 | buffer[5]; return new Message(address, endpoint, value);}
public byte[] serialize() {byte[] buf = new byte[MESSAGE_SIZE];buf[0] = (byte) (m_device & 0xFF);buf[1] = (byte) (m_endpoint & 0xFF);buf[2] = (byte) ((m_value & 0xFF000000) >> 24);buf[3] = (byte) ((m_value & 0x00FF0000) >> 16);buf[4] = (byte) ((m_value & 0x0000FF00) >> 8);buf[5] = (byte) ((m_value & 0x000000FF));return buf;}
public void JKCement(){System.out.println("");     }
public static void UltraCement(){System.out.println("");Methods mt=new Methods();mt.JKCement();}
public void Methodpara(int a,String Casuals,String Username){System.out.println("");System.out.println(a);System.out.println(Casuals+Username);System.out.println(Username);System.out.println("");}
    public static void printSum(int num1, int num2) {        int sum = num1 + num2;        System.out.printf("", num1, num2, sum);    }
    public static void printDivision(int num1, int num2) {        int division = num1 / num2;        int rest = num1 % num2;        System.out.printf("", num1, num2, division, rest);    }
    public static void printOperationsResult(int num1, int num2, int num3, int num4, int num5, int num6, int num7, int num8,                                             int num9, int num10, int num11, int num12, int num13, int num14, int num15, int num16) {        int op1 = num1 + num2 * num3;        int op2 = (num4 + num5) % num6;        int op3 = num7 + num8 * num9 / num10;        int op4 = num11 + num12 / num13 * num14 - num15 % num16;        System.out.printf("", num1, num2, num3, op1);        System.out.printf("", num4, num5, "", num6, op2);        System.out.printf("", num7, num8, num9, num10, op3);        System.out.printf("", num11, num12, num13, num14, num15, "", num16, op4);    }
    public static void printExpressionOutput(double num1, double num2, double num3, double num4, double num5, double num6) {        double result = (num1 * num2 - num3 * num4) / (num5 - num6);        System.out.printf("", num1, num2, num3, num4, num5, num6,                result);    }
    public static void printCircleAreaAndPerimeter(double radius) {        double area = Math.PI * radius * radius;        double perimeter = Math.PI * 2 * radius;        System.out.printf("", radius, area);        System.out.printf("", radius, perimeter);    }
    public static void calculateAcceleration(int startSpeed, int finalSpeed, int timeUsedInSeconds, int objectMass) {    double deltaSpeed = finalSpeed - startSpeed;    double speedInMetersPerSecond = deltaSpeed * 5 / 18;    System.out.printf("", deltaSpeed, speedInMetersPerSecond);    System.out.println();    double acceleration = speedInMetersPerSecond / timeUsedInSeconds;    System.out.printf("", acceleration);    System.out.println();    double distanceTraveled = speedInMetersPerSecond * timeUsedInSeconds;    System.out.printf("", distanceTraveled);    }
    public static void printHelloName(String name) {        System.out.println("");        System.out.printf("", name);    }
    public static void printStringLowercase(String string) {        System.out.println("" + string);        System.out.println(string.toLowerCase());    }
    public static void printStringReversed(String string) {        System.out.println("" + string);        StringBuilder stringBuilder = new StringBuilder();        stringBuilder.append(string);        stringBuilder.reverse();        System.out.println(stringBuilder.toString());    }
    public static void printFistHalfOfString(String string) {        System.out.println("" + string);        int stringLength = string.length();        String firstHalf = string.substring(0, stringLength/2);        System.out.println(firstHalf);    }
    public static void printStringsConcatenatedWithoutFirstLetter(String string1, String string2) {        System.out.println("" + string1 + "" + string2);        StringBuilder stringBuilder = new StringBuilder();        stringBuilder.append(string1.substring(1));        stringBuilder.append(string2.substring(1));        System.out.println(stringBuilder.toString());    }
    public static void printStringComparison(String string1, String string2) {        System.out.println("" + string1 + "" + string2);        if (string1.equalsIgnoreCase(string2)) {            System.out.printf("", string1, string2);        } else {            System.out.printf("", string1, string2);        }    }
    public static void printStringCharacterCount(String string) {        System.out.println("" + string);        int lettersCount = 0;        int spacesCount = 0;        int numbersCount = 0;        int othersCount = 0;        for (int i=0; i<string.length(); i++) {            if (string.substring(i,i+1).matches("")) {                lettersCount++;                continue;            }            if (string.substring(i,i+1).matches("")) {                spacesCount++;                continue;            }            if (string.substring(i,i+1).matches("")) {                numbersCount++;                continue;            }            othersCount++;        }        System.out.printf("", string, lettersCount, spacesCount, numbersCount,                othersCount);    }
    int countByExample(UserExample example); 
    int deleteByExample(UserExample example); 
    int deleteByPrimaryKey(Long userId); 
    int insert(User record); 
    int insertSelective(User record); 
    List<User> selectByExample(UserExample example); 
    User selectByPrimaryKey(Long userId); 
    int updateByExampleSelective(@Param("record") User record, @Param("example") UserExample example); 
    int updateByExample(@Param("record") User record, @Param("example") UserExample example); 
    int updateByPrimaryKeySelective(User record); 
    public static int binarySearch(int[] arr, int left, int right, int x) {        int mid;        if (right >= left) {            mid = (left + right) / 2;            if (x == arr[mid]) {                return mid;            } else {                if (x < arr[mid]) {                                        return binarySearch(arr, left, mid - 1, x);                } else {                                        return binarySearch(arr, mid + 1, right, x);                }            }        }                return -1;    }
    static int factorial(int n) {        if (n == 0 || n == 1) {            return n;        }        return n * factorial(n - 1);    }
    public static int fibonacci(int n){        if(n<=1){            return n;        }else{            return fibonacci(n-1) + fibonacci(n-2);        }    }
    public void sort(int[] arr) {        int n = arr.length;                int aux;        for (int i = 0; i < n; i++) {            for (int j = 0; j < n - i - 1; j++) {                 if (arr[j] > arr[j + 1]) {                                        aux = arr[j];                    arr[j] = arr[j + 1];                    arr[j + 1] = aux;                }            }        }    }
    public void sort(int[] arr) {        int n = arr.length;                        for (int i = 1; i < n; i++) {            int element = arr[i];            int j = i-1;                        while (j >= 0 && arr[j] > element) {                arr[j + 1] = arr[j];                j--;            }            arr[j+1] = element;        }    }
public CustomQueue() {        front = null;        rear = null;    }
    public void enqueue(int value) {        Node newNode = new Node(value);        System.out.println("" + value);                if (rear == null) {            front = newNode;            rear = newNode;        } else {                        rear.next = newNode;                        rear = newNode;        }    }
    public Node dequeue() {        if (front == null) {                        System.out.println("");            return null;        } else {            Node nodeToReturn = front;                        front = front.next;                        if (front == null) {                rear = null;            }            System.out.println("" + nodeToReturn.data);            return nodeToReturn;        }    }
    public Node front() {        return front;    }
public CustomStack(int s) {        arr = new int[s];        size = s;                top = -1;    }
    public boolean push(int value) {        if (isFull()) {            System.out.println("");            return false;        } else {            System.out.println("" + value);            top++;            arr[top] = value;            return true;        }    }
    public int pop() {        if (isEmpty()) {            System.out.println("");            return 0;        }        int valueToReturn = arr[top];        System.out.println("" + valueToReturn);        top--;        return valueToReturn;    }
    public int peek() {        if (isEmpty()) {            System.out.println("");            return 0;        } else {            return arr[top];        }    }
    public boolean isEmpty() {        if (top < 0) {            return true;        }        return false;    }
    public boolean isFull() {        if (top == size - 1) {            return true;        }        return false;    }
    public void doParentThings() {        System.out.println("");    }
    public static void main(String[] args) {                System.out.println("");        System.out.println();        System.out.print("");        List<Integer> listOfIntegers = new ArrayList<>();        listOfIntegers.add(2);        listOfIntegers.add(1);        listOfIntegers.add(3);        listOfIntegers.add(6);        listOfIntegers.add(6);        listOfIntegers.add(5);        System.out.println();        System.out.print("");        listOfIntegers.forEach(value -> System.out.print(value + ""));        Collections.sort(listOfIntegers);                System.out.println();        listOfIntegers.set(0, 555);        listOfIntegers.remove(4);        System.out.print("");        System.out.println(Arrays.toString(listOfIntegers.toArray()));        System.out.println("" + listOfIntegers.contains(3));        System.out.println();        System.out.println("" + Collections.max(listOfIntegers));        System.out.println("" + Collections.min(listOfIntegers));        System.out.println();        Collections.sort(listOfIntegers, Collections.reverseOrder());        System.out.print("" + listOfIntegers);    }
public ProductService(EmailService emailService) {        this.emailService = emailService;    }
    public void sendPurchaseCompletedEmail() {        this.emailService.sendPurchaseCompletedEmail();    }
    public void sendDeliverySendEmail() {                this.emailService.sendDeliverySendEmail();    }
public static void main(String[] args) {int arrayToTest[] = {3,5,2};try {printArrayElement(arrayToTest, 5);} catch (Exception e) {e.printStackTrace();}}
private static void printArrayElement(int[] array, int index) throws Exception {if(index < 0 || index >= array.length) {throw new Exception("");}System.out.println(array[index]);}
public static void main(String[] args) {TicTacToe t = new TicTacToe();Scanner s = new Scanner(System.in);int x = 0, y = 0;do {System.out.println(t.player == t.X ? "" : "");System.out.println("");x = s.nextInt();y = s.nextInt();t.putSign(x, y);System.out.println(t.toString());System.out.println("");t.displayWinner();} while (t.isEmpty);}
public void putSign(int x, int y) {if (x < 0 || x > 2 || y < 0 || y > 2) {System.out.println("");return;}if (board[x][y] != EMPTY) {System.out.println("");return;}board[x][y] = player; player = -player; }
public boolean isWin(int player) {return ((board[0][0] + board[0][1] + board[0][2] == player * 3)|| (board[1][0] + board[1][1] + board[1][2] == player * 3)|| (board[2][0] + board[2][1] + board[2][2] == player * 3)|| (board[0][0] + board[1][0] + board[2][0] == player * 3)|| (board[0][1] + board[1][1] + board[2][1] == player * 3)|| (board[0][2] + board[1][2] + board[2][2] == player * 3)|| (board[0][0] + board[1][1] + board[2][2] == player * 3)|| (board[2][0] + board[1][1] + board[0][2] == player * 3));}
public void displayWinner() {if (isWin(X)) {System.out.println("");isEmpty = false;} else if (isWin(O)) {System.out.println("");isEmpty = false;} else {if (!isEmpty) {System.out.println("");}}}
public DbConn() {        this.connect(this.isTemple());    }
public DbConn(boolean isTemple) {        this.connect(isTemple);    }
    private void connect(boolean isTemple) {        try {            String DRIVER = "";            Class.forName(DRIVER).newInstance();            try {                                String url = "";                                if (isTemple) {                    url = "";                }                this.conn = DriverManager.getConnection(url);            } catch (Exception e) {                 this.errMsg = "" + e.getMessage();            }        } catch (Exception e) {             this.errMsg = "" + e.getMessage();        }    }
    public Connection getConn() {        return this.conn;    }
    public String getErr() {        return this.errMsg;    }
    public void close() {        if (conn != null) {            try {                conn.close();            }             catch (Exception e) {                            }         }     }
    private boolean isTemple() {        boolean temple = false;        try {            String hostName = java.net.InetAddress.getLocalHost().getCanonicalHostName();            hostName = hostName.toLowerCase();            if (hostName.endsWith("")) {                temple = true;                System.out.println("");            } else {                System.out.println("");            }        } catch (Exception e) {            System.out.println("" + e.getMessage());        }        return temple;    }
public static void main(String[] args) {System.out.println("");}
public static void main(String[] args) {LocalDateTime dt = LocalDateTime.now();System.out.println(dt);System.out.printf(  "", LocalDate.now());}
public static void main(String[] args) {@SuppressWarnings("")Scanner number = new Scanner(System.in);int a = number.nextInt();int b = number.nextInt();System.out.println(a+b);}
public static void main(String[] args) {@SuppressWarnings("")Scanner sc = new Scanner(System.in);int n = sc.nextInt();String[] allWords = new String[n]; for(int i=0;i<n;i++){allWords[i] = sc.next();}Arrays.sort(allWords); for(int i=0;i<n;i++){System.out.println(allWords[i]);}}
public static void main(String[] args) {try {Document document = new Document();PdfWriter.getInstance(document, new FileOutputStream(""));document.open();PdfPTable table = new PdfPTable(4);table.setWidthPercentage(100);        table.getDefaultCell().setFixedHeight(180);        BaseFont baseFont = BaseFont.createFont("", BaseFont.IDENTITY_H, true);Font black = new Font(baseFont, 75f, 0, BaseColor.BLACK);Font red = new Font(baseFont, 75f, 0, BaseColor.RED);String card = "";char color = '';for (int i = 2; i <= 14; i++) {switch (i) {case 10: card = ""; break;case 11: card = ""; break;case 12: card = ""; break;case 13: card = ""; break;case 14: card = ""; break;default: card = "" + i; break;}for (int j = 1; j <= 4; j++) {switch (j) {case 1: color = ''; table.addCell(new Paragraph(card + color + "", black)); break;case 2: color = ''; table.addCell(new Paragraph(card + color + "", red)); break;case 3: color = ''; table.addCell(new Paragraph(card + color + "", black)); break;case 4: color = ''; table.addCell(new Paragraph(card + color + "", red)); break;}}}document.add(table);document.close(); }catch (Exception e) {e.printStackTrace();}}
public static void main(String[] args) {@SuppressWarnings("")Scanner sc = new Scanner(System.in);String sides = sc.nextLine();String arr[] = sides.split("");    int a = Integer.parseInt(arr[0]);int b = Integer.parseInt(arr[1]);System.out.println(a*b);}
public static void main(String[] args) {@SuppressWarnings("")Scanner sc = new Scanner(System.in);String pointA = sc.nextLine();String ArrA[] = pointA.split("");         int ax = Integer.parseInt(ArrA[0]);int ay = Integer.parseInt(ArrA[1]);String pointB = sc.nextLine();String ArrB[] = pointB.split("");         int bx = Integer.parseInt(ArrB[0]);int by = Integer.parseInt(ArrB[1]);String pointC = sc.nextLine();String ArrC[] = pointC.split("");         int cx = Integer.parseInt(ArrC[0]);int cy = Integer.parseInt(ArrC[1]);double area = (double)((ax*(by-cy) + bx*(cy-ay) + cx*(ay-by))/2);  if(area>=0) System.out.println(area);else System.out.println(area*-1);          }
public static void main(String[] args) {@SuppressWarnings("")Scanner sc = new Scanner(System.in);String point = sc.nextLine();String arr[] = point.split("");double x = Double.parseDouble(arr[0]);double y = Double.parseDouble(arr[1]);      if(y<6 || y> 13.5) System.out.println(""); else{if(x<12.5 || x>22.5) System.out.println(""); else{if(x>17.5&&x<20&&y>8.5) System.out.println(""); else System.out.println("");}}}
public static void main(String[] args) {@SuppressWarnings("")Scanner sc = new Scanner(System.in);double first = Double.parseDouble(sc.next());double second = Double.parseDouble(sc.next());double third = Double.parseDouble(sc.next());double min = Math.min(first, Math.min(second, third)); System.out.println(min);}
public static void main(String[] args) {@SuppressWarnings("")Scanner sc = new Scanner(System.in);int num = sc.nextInt();String hexnum = Integer.toHexString(num); System.out.println(hexnum.toUpperCase()); }
public static void main(String[] args) {@SuppressWarnings("")Scanner input = new Scanner(System.in);int a = input.nextInt();double b = input.nextDouble();double c = input.nextDouble();String aHexString = Integer.toHexString(a).toUpperCase();String aBinary = String.format("", Integer.toBinaryString(a)).replace('', '');                             if (c%1 == 0) { System.out.printf("",aHexString,aBinary,b,c);}else {System.out.printf("",aHexString,aBinary,b,c);}}
public static void main(String[] args) {@SuppressWarnings("")Scanner input = new Scanner(System.in);int number = input.nextInt();int count = 0;for (int i = 0; i < 32; i++) {int bit = number & 1;if (bit == 1) {count++;}number >>= 1; }System.out.println(count);}
public static void main(String[] args) {@SuppressWarnings("")Scanner sc = new Scanner(System.in);int a = sc.nextInt();char[] aToBin = String.format("", Integer.toBinaryString(a)).toCharArray();int count = 0;for (int i = 0; i < aToBin.length; i++) {if (aToBin[i] == '') count++;}System.out.println(count);}
public static void main(String[] args) {@SuppressWarnings("")Scanner scan = new Scanner(System.in);System.out.println("");int num = scan.nextInt();char[] binary = Integer.toBinaryString(num).toCharArray();  int count = 0;for (int i = 0; i < binary.length-1; i++) {if (binary[i]==binary[i+1]) {count++;}}System.out.println("");System.out.print(count);}
public static void main(String[] args) {@SuppressWarnings("")Scanner scaner = new Scanner(System.in);BigInteger n = scaner.nextBigInteger();int counter = 0;for (int i = 0; i < n.bitLength(); i++) {if(n.testBit(i)==n.testBit(i+1)){counter++;}}System.out.println(counter);}
    public static void main(String[] args) {                    if ( args.length < 1 ) {                System.err.println("");                usage();                System.exit(1);            }                new DateTimeBrowser().go( args );    }
    private static void usage() {            System.err.println("");            System.err.print("");            System.err.print(DateTimeBrowser.class.getName());            System.err.println("");            System.err.println("");            System.err.println("");            System.err.println("");            System.err.println("");            System.err.println("");            System.err.println("");            System.err.println("");            System.err.println("");            System.err.println("");            System.err.println("");            System.err.println("");            System.err.println("");    }
    private void go(String[] args) {        mainArgs = args;        setDefaultTimeZone();                   setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);                JMenuBar menuBar = new JMenuBar();        setJMenuBar( menuBar );        addMenus( menuBar );                addWindowListener( new WindowAdapter() {                    public void windowClosing(WindowEvent e)                    {                        setVisible( false );                        dispose();                        System.exit(0);                    }                }            );                                currFile = new LoadedFile( mainArgs[0] );        TableView tView = getDefaultTableView();        resetDefaults( tView );                                Dimension screenMax = Toolkit.getDefaultToolkit().getScreenSize();        setSize ( screenMax );        setVisible(true);    }
    private TableView getDefaultTableView() {                String viewStr = System.getProperty("");        if ( viewStr == null ) {            jmiGetter.setEnabled( false );            return new GetterTableView( currFile );        }                if ( viewStr.equalsIgnoreCase("") ) {            jmiHex.setEnabled( false );            return new HexTableView( currFile );        }        else if ( viewStr.equalsIgnoreCase("") ) {            jmiDate.setEnabled( false );            return new DateTableView( currFile );        }        else if ( viewStr.equalsIgnoreCase("") ) {            jmiCal.setEnabled( false );            return new CalTableView( currFile );        }        else if ( viewStr.equalsIgnoreCase("") ) {            jmiGetter.setEnabled( false );            return new GetterTableView( currFile );        }        else {             System.err.println("" + viewStr + "");            jmiGetter.setEnabled( false );            return new GetterTableView( currFile );        }    }
    private void setDefaultTableView(String newView) {        System.setProperty( "", newView );    }
    private void setDefaultTimeZone() {        String tzName = System.getProperty("");        if ( tzName == null ) return;                                           TimeZone toSet = TimeZone.getTimeZone( tzName );                                TimeZone.setDefault( toSet );    }
    private void addMenus( JMenuBar menuBar) {                                JMenu fileMenu = new JMenu("");        JMenu viewMenu = new JMenu("");                                menuBar.add( fileMenu );        menuBar.add( viewMenu );                                Action open = new OpenAction();        JMenuItem jmiOpen = new JMenuItem( open );        Action exit = new ExitAction();        JMenuItem jmiExit = new JMenuItem( exit );                                Action getter = new GetterAction();        jmiGetter = new JMenuItem( getter );        getter.setEnabled( true );                Action hex = new HexAction();        jmiHex = new JMenuItem( hex );        hex.setEnabled( true );                Action date = new DateAction();        jmiDate = new JMenuItem( date );        date.setEnabled( true );                Action cal = new CalAction();        jmiCal = new JMenuItem( cal );        cal.setEnabled( true );                                fileMenu.add( jmiOpen );        fileMenu.addSeparator();        fileMenu.add( jmiExit );                                viewMenu.add( jmiGetter );        viewMenu.add( jmiHex );        viewMenu.add( jmiDate );        viewMenu.add( jmiCal );                                                                    }
    private void dumpObjs(Object[][] objs, PrintStream out ) {        for (int i = 0; i < objs.length; ++i) {            for (int j = 0; j < objs[i].length; ++j) {                out.println(i + "" + j + ""                    + objs[i][j]);            }         }     }
    private void enableAllViews() {        jmiGetter.setEnabled( true );        jmiHex.setEnabled( true );        jmiDate.setEnabled( true );        jmiCal.setEnabled( true );    }
    private DateTime getADate(String s) {        DateTime retDT = null;        try        {            retDT = new DateTime( s );        }         catch(IllegalArgumentException pe)        {                    }         return retDT;    }
        Object[] genColNames() {            Object[] retVal = {                "",                "",                "",                "",                "",                "",                "",                "",                "",                "",                "",                "",                ""            };            return retVal;        }
        Object[][] genCalcdValues() {            Object[][] retValues = null;                        ArrayList fileStrings = lddFile.getFileStrings();            ArrayList dtObjects = lddFile.getDtObjects();            int numRows = fileStrings.size();            retValues = new Object[numRows][];            int numCols = colNames.length;                                    for (int nextStrNum = 0; nextStrNum < fileStrings.size(); ++ nextStrNum) {                retValues[nextStrNum] = new Object[numCols];                                                                                 int column = 0;                 String fileString = (String)fileStrings.get(nextStrNum);                retValues[nextStrNum][column++] = fileString;                                DateTime adt = (DateTime)dtObjects.get(nextStrNum);                String adtStr = adt.toString();                retValues[nextStrNum][column++] = adtStr;                                                                retValues[nextStrNum][column++]  = new Integer( adt.getMillisOfSecond() );                retValues[nextStrNum][column++]  = new Integer( adt.getSecondOfMinute() );                retValues[nextStrNum][column++]  = new Integer( adt.getMinuteOfHour() );                retValues[nextStrNum][column++]  = new Integer( adt.getHourOfDay() );                retValues[nextStrNum][column++]  = new Integer( adt.getDayOfWeek() );                retValues[nextStrNum][column++]  = new Integer( adt.getDayOfMonth() );                retValues[nextStrNum][column++]  = new Integer( adt.getDayOfYear() );                retValues[nextStrNum][column++]  = new Integer( adt.getWeekOfWeekyear() );                retValues[nextStrNum][column++] = new Integer( adt.getWeekyear() );                retValues[nextStrNum][column++] = new Integer( adt.getMonthOfYear() );                retValues[nextStrNum][column++] = new Integer( adt.getYear() );                            }             if ( debugf ) dumpObjs( retValues, System.err );            return retValues;        }
        String getViewTitle() {            return ""                + ""                + TimeZone.getDefault().getDisplayName()                + ""                + ""                + currFile.getLoadedFileSize();        }
        void setViewColumnsWidth(JTable jt) {                        TableColumnModel colmodel = jt.getColumnModel();            TableColumn col0 = colmodel.getColumn(0);            col0.setPreferredWidth(200);            TableColumn col1 = colmodel.getColumn(1);            col1.setPreferredWidth(200);            return;        }
        public void actionPerformed(ActionEvent e) {            int result = chooser.showOpenDialog( DateTimeBrowser.this );            String canPath = null;            if ( result == JFileChooser.APPROVE_OPTION ) {                File chosenFile = chooser.getSelectedFile();                try                {                    canPath = chosenFile.getCanonicalPath();                }                catch(IOException ioe)                {                    System.err.println( ""                        + chosenFile );                                    }                enableAllViews();                currFile = new LoadedFile( canPath );                TableView tView = getDefaultTableView();                resetDefaults( tView );            }         }
public DateTimePerformance() throws Exception {        checkJodaConstructor1();        checkJISOConstructor1();        checkGCalConstructor1();        checkDateConstructor1();                checkJodaConstructor2();        checkJISOConstructor2();        checkGCalConstructor2();        checkDateConstructor2();                checkJodaConstructor3();        checkJISOConstructor3();        checkGCalConstructor3();        checkDateConstructor3();                checkJodaGetYear();        checkJISOGetYear();        checkGCalGetYear();        checkDateGetYear();                                checkJodaGetHour();        checkJISOGetHour();        checkGCalGetHour();        checkDateGetHour();                checkJodaSetYear();        checkJISOSetYear();        checkGCalSetYear();        checkDateSetYear();                checkJodaSetGetYear();        checkJISOSetGetYear();        checkGCalSetGetYear();        checkDateSetGetYear();                checkJodaSetHour();        checkJISOSetHour();        checkGCalSetHour();        checkDateSetHour();                checkJodaSetGetHour();        checkJISOSetGetHour();        checkGCalSetGetHour();        checkDateSetGetHour();                checkJodaToString();        checkJISOToString();        checkGCalToString();        checkDateToString();                System.out.println("");        long jodaTotal = 0;        long jisoTotal = 0;        long gcalTotal = 0;        long dateTotal = 0;        for (Iterator it = resultList.iterator(); it.hasNext();) {            Result res = (Result) it.next();            System.out.println(res.object + "" + res.name + "" + res.avg + "");            if (res.object.equals("")) {                jodaTotal += res.avg;            } else if (res.object.equals("")) {                jisoTotal += res.avg;            } else if (res.object.equals("")) {                gcalTotal += res.avg;            } else if (res.object.equals("")) {                dateTotal += res.avg;                System.out.println("");            }        }        System.out.println("" + jodaTotal);        System.out.println("" + jisoTotal);        System.out.println("" + gcalTotal);        System.out.println("" + dateTotal);    }
    public static void main(String[] args) {        try {            new DateTimePerformance();                    } catch (Throwable th) {            th.printStackTrace();        }    }
    private void start(String str1, String str2) {        result = (Result) results.get(str1 + str2);        if (result == null) {            result = new Result();            result.object = str1;            result.name = str2;            results.put(str1 + str2, result);            resultList.add(result);        }        start = System.currentTimeMillis();    }
    private void end(int count) {        end = System.currentTimeMillis();        long time = (end - start);        result.time = result.time + time;        result.runs = result.runs + count;        result.avg = (result.time * 1000000) / result.runs;        System.out.print("");    }
public DateMidnight() {        super();    }
public DateMidnight(DateTimeZone zone) {        super(zone);    }
public DateMidnight(Chronology chronology) {        super(chronology);    }
public DateMidnight(long instant) {        super(instant);    }
public DateMidnight(long instant, DateTimeZone zone) {        super(instant, zone);    }
public DateMidnight(long instant, Chronology chronology) {        super(instant, chronology);    }
public DateMidnight(Object instant) {        super(instant, (Chronology) null);    }
public DateMidnight(Object instant, DateTimeZone zone) {        super(instant, zone);    }
public DateMidnight(Object instant, Chronology chronology) {        super(instant, DateTimeUtils.getChronology(chronology));    }
public DateMidnight(int year, int monthOfYear, int dayOfMonth) {        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0);    }
public DateMidnight(int year, int monthOfYear, int dayOfMonth, DateTimeZone zone) {        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, zone);    }
public DateMidnight(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, chronology);    }
public DateMidnight withMillis(long newMillis) {        Chronology chrono = getChronology();        newMillis = checkInstant(newMillis, chrono);        return (newMillis == getMillis() ? this : new DateMidnight(newMillis, chrono));    }
public DateMidnight withPeriodAdded(ReadablePeriod period, int scalar) {        if (period == null || scalar == 0) {            return this;        }        long instant = getChronology().add(period, getMillis(), scalar);        return withMillis(instant);    }
public DateMidnight plus(long duration) {        return withDurationAdded(duration, 1);    }
public DateMidnight plus(ReadablePeriod period) {        return withPeriodAdded(period, 1);    }
public DateMidnight plusYears(int years) {        if (years == 0) {            return this;        }        long instant = getChronology().years().add(getMillis(), years);        return withMillis(instant);    }
public DateMidnight plusMonths(int months) {        if (months == 0) {            return this;        }        long instant = getChronology().months().add(getMillis(), months);        return withMillis(instant);    }
public DateMidnight plusWeeks(int weeks) {        if (weeks == 0) {            return this;        }        long instant = getChronology().weeks().add(getMillis(), weeks);        return withMillis(instant);    }
public DateMidnight plusDays(int days) {        if (days == 0) {            return this;        }        long instant = getChronology().days().add(getMillis(), days);        return withMillis(instant);    }
public DateMidnight minus(long duration) {        return withDurationAdded(duration, -1);    }
public DateMidnight minus(ReadableDuration duration) {        return withDurationAdded(duration, -1);    }
public DateMidnight minus(ReadablePeriod period) {        return withPeriodAdded(period, -1);    }
public DateMidnight minusYears(int years) {        if (years == 0) {            return this;        }        long instant = getChronology().years().subtract(getMillis(), years);        return withMillis(instant);    }
public DateMidnight minusMonths(int months) {        if (months == 0) {            return this;        }        long instant = getChronology().months().subtract(getMillis(), months);        return withMillis(instant);    }
public DateMidnight minusWeeks(int weeks) {        if (weeks == 0) {            return this;        }        long instant = getChronology().weeks().subtract(getMillis(), weeks);        return withMillis(instant);    }
public DateMidnight minusDays(int days) {        if (days == 0) {            return this;        }        long instant = getChronology().days().subtract(getMillis(), days);        return withMillis(instant);    }
public DateMidnight withEra(int era) {        return withMillis(getChronology().era().set(getMillis(), era));    }
public DateMidnight withCenturyOfEra(int centuryOfEra) {        return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra));    }
public DateMidnight withYearOfEra(int yearOfEra) {        return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));    }
public DateMidnight withYearOfCentury(int yearOfCentury) {        return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));    }
public DateMidnight withYear(int year) {        return withMillis(getChronology().year().set(getMillis(), year));    }
public DateMidnight withWeekyear(int weekyear) {        return withMillis(getChronology().weekyear().set(getMillis(), weekyear));    }
public DateMidnight withMonthOfYear(int monthOfYear) {        return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));    }
public DateMidnight withWeekOfWeekyear(int weekOfWeekyear) {        return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));    }
public DateMidnight withDayOfYear(int dayOfYear) {        return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));    }
public DateMidnight withDayOfMonth(int dayOfMonth) {        return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));    }
public DateMidnight addToCopy(long value) {            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));        }
public DateMidnight addWrapFieldToCopy(int value) {            return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));        }
public DateMidnight setCopy(int value) {            return iInstant.withMillis(iField.set(iInstant.getMillis(), value));        }
public DateMidnight setCopy(String text, Locale locale) {            return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale));        }
public DateMidnight setCopy(String text) {            return setCopy(text, null);        }
public DateMidnight withMaximumValue() {            return setCopy(getMaximumValue());        }
public DateMidnight withMinimumValue() {            return setCopy(getMinimumValue());        }
public DateMidnight roundFloorCopy() {            return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));        }
public DateMidnight roundCeilingCopy() {            return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));        }
public DateMidnight roundHalfFloorCopy() {            return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));        }
public DateMidnight roundHalfCeilingCopy() {            return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));        }
public DateMidnight roundHalfEvenCopy() {            return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));        }
    public static DateMidnight now(Chronology chronology) {        if (chronology == null) {            throw new NullPointerException("");        }        return new DateMidnight(chronology);    }
    public static DateMidnight parse(String str, DateTimeFormatter formatter) {        return formatter.parseDateTime(str).toDateMidnight();    }
    protected long checkInstant(long instant, Chronology chronology) {        return chronology.dayOfMonth().roundFloor(instant);    }
    public DateMidnight withMillis(long newMillis) {        Chronology chrono = getChronology();        newMillis = checkInstant(newMillis, chrono);        return (newMillis == getMillis() ? this : new DateMidnight(newMillis, chrono));    }
    public DateMidnight withChronology(Chronology newChronology) {        return (newChronology == getChronology() ? this : new DateMidnight(getMillis(), newChronology));    }
    public DateMidnight withZoneRetainFields(DateTimeZone newZone) {        newZone = DateTimeUtils.getZone(newZone);        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());        if (newZone == originalZone) {            return this;        }                long millis = originalZone.getMillisKeepLocal(newZone, getMillis());        return new DateMidnight(millis, getChronology().withZone(newZone));    }
    public DateMidnight withFields(ReadablePartial partial) {        if (partial == null) {            return this;        }        return withMillis(getChronology().set(partial, getMillis()));    }
    public DateMidnight withField(DateTimeFieldType fieldType, int value) {        if (fieldType == null) {            throw new IllegalArgumentException("");        }        long instant = fieldType.getField(getChronology()).set(getMillis(), value);        return withMillis(instant);    }
    public DateMidnight withPeriodAdded(ReadablePeriod period, int scalar) {        if (period == null || scalar == 0) {            return this;        }        long instant = getChronology().add(period, getMillis(), scalar);        return withMillis(instant);    }
    public DateMidnight plus(ReadablePeriod period) {        return withPeriodAdded(period, 1);    }
    public DateMidnight plusYears(int years) {        if (years == 0) {            return this;        }        long instant = getChronology().years().add(getMillis(), years);        return withMillis(instant);    }
    public DateMidnight plusMonths(int months) {        if (months == 0) {            return this;        }        long instant = getChronology().months().add(getMillis(), months);        return withMillis(instant);    }
    public DateMidnight plusWeeks(int weeks) {        if (weeks == 0) {            return this;        }        long instant = getChronology().weeks().add(getMillis(), weeks);        return withMillis(instant);    }
    public DateMidnight plusDays(int days) {        if (days == 0) {            return this;        }        long instant = getChronology().days().add(getMillis(), days);        return withMillis(instant);    }
    public DateMidnight minusYears(int years) {        if (years == 0) {            return this;        }        long instant = getChronology().years().subtract(getMillis(), years);        return withMillis(instant);    }
    public DateMidnight minusMonths(int months) {        if (months == 0) {            return this;        }        long instant = getChronology().months().subtract(getMillis(), months);        return withMillis(instant);    }
    public DateMidnight minusWeeks(int weeks) {        if (weeks == 0) {            return this;        }        long instant = getChronology().weeks().subtract(getMillis(), weeks);        return withMillis(instant);    }
    public DateMidnight minusDays(int days) {        if (days == 0) {            return this;        }        long instant = getChronology().days().subtract(getMillis(), days);        return withMillis(instant);    }
    public Property property(DateTimeFieldType type) {        if (type == null) {            throw new IllegalArgumentException("");        }        DateTimeField field = type.getField(getChronology());        if (field.isSupported() == false) {            throw new IllegalArgumentException("" + type + "");        }        return new Property(this, field);    }
    public LocalDate toLocalDate() {        return new LocalDate(getMillis(), getChronology());    }
    public Interval toInterval() {        Chronology chrono = getChronology();        long start = getMillis();        long end = DurationFieldType.days().getField(chrono).add(start, 1);        return new Interval(start, end, chrono);    }
    public DateMidnight withEra(int era) {        return withMillis(getChronology().era().set(getMillis(), era));    }
    public DateMidnight withCenturyOfEra(int centuryOfEra) {        return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra));    }
    public DateMidnight withYearOfEra(int yearOfEra) {        return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));    }
    public DateMidnight withYearOfCentury(int yearOfCentury) {        return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));    }
    public DateMidnight withWeekyear(int weekyear) {        return withMillis(getChronology().weekyear().set(getMillis(), weekyear));    }
    public DateMidnight withMonthOfYear(int monthOfYear) {        return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));    }
    public DateMidnight withWeekOfWeekyear(int weekOfWeekyear) {        return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));    }
    public DateMidnight withDayOfYear(int dayOfYear) {        return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));    }
    public DateMidnight withDayOfMonth(int dayOfMonth) {        return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));    }
    public Property era() {        return new Property(this, getChronology().era());    }
    public Property centuryOfEra() {        return new Property(this, getChronology().centuryOfEra());    }
    public Property yearOfCentury() {        return new Property(this, getChronology().yearOfCentury());    }
    public Property yearOfEra() {        return new Property(this, getChronology().yearOfEra());    }
    public Property year() {        return new Property(this, getChronology().year());    }
    public Property weekyear() {        return new Property(this, getChronology().weekyear());    }
    public Property monthOfYear() {        return new Property(this, getChronology().monthOfYear());    }
    public Property weekOfWeekyear() {        return new Property(this, getChronology().weekOfWeekyear());    }
    public Property dayOfYear() {        return new Property(this, getChronology().dayOfYear());    }
    public Property dayOfMonth() {        return new Property(this, getChronology().dayOfMonth());    }
    public Property dayOfWeek() {        return new Property(this, getChronology().dayOfWeek());    }
        private void writeObject(ObjectOutputStream oos) throws IOException {            oos.writeObject(iInstant);            oos.writeObject(iField.getType());        }
        private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException {            iInstant = (DateMidnight) oos.readObject();            DateTimeFieldType type = (DateTimeFieldType) oos.readObject();            iField = type.getField(iInstant.getChronology());        }
        public DateTimeField getField() {            return iField;        }
        protected long getMillis() {            return iInstant.getMillis();        }
        protected Chronology getChronology() {            return iInstant.getChronology();        }
        public DateMidnight getDateMidnight() {            return iInstant;        }
        public DateMidnight addToCopy(long value) {            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));        }
        public DateMidnight addWrapFieldToCopy(int value) {            return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));        }
        public DateMidnight setCopy(String text) {            return setCopy(text, null);        }
        public DateMidnight withMaximumValue() {            return setCopy(getMaximumValue());        }
        public DateMidnight withMinimumValue() {            return setCopy(getMinimumValue());        }
        public DateMidnight roundFloorCopy() {            return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));        }
        public DateMidnight roundCeilingCopy() {            return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));        }
        public DateMidnight roundHalfFloorCopy() {            return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));        }
        public DateMidnight roundHalfCeilingCopy() {            return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));        }
        public DateMidnight roundHalfEvenCopy() {            return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));        }
public DateTime plus(ReadablePeriod period) {        return withPeriodAdded(period, 1);    }
public DateTime plusYears(int years) {        if (years == 0) {            return this;        }        long instant = getChronology().years().add(getMillis(), years);        return withMillis(instant);    }
public DateTime plusMonths(int months) {        if (months == 0) {            return this;        }        long instant = getChronology().months().add(getMillis(), months);        return withMillis(instant);    }
public DateTime plusWeeks(int weeks) {        if (weeks == 0) {            return this;        }        long instant = getChronology().weeks().add(getMillis(), weeks);        return withMillis(instant);    }
public DateTime plusDays(int days) {        if (days == 0) {            return this;        }        long instant = getChronology().days().add(getMillis(), days);        return withMillis(instant);    }
public DateTime plusHours(int hours) {        if (hours == 0) {            return this;        }        long instant = getChronology().hours().add(getMillis(), hours);        return withMillis(instant);    }
public DateTime plusMinutes(int minutes) {        if (minutes == 0) {            return this;        }        long instant = getChronology().minutes().add(getMillis(), minutes);        return withMillis(instant);    }
public DateTime plusSeconds(int seconds) {        if (seconds == 0) {            return this;        }        long instant = getChronology().seconds().add(getMillis(), seconds);        return withMillis(instant);    }
public DateTime plusMillis(int millis) {        if (millis == 0) {            return this;        }        long instant = getChronology().millis().add(getMillis(), millis);        return withMillis(instant);    }
public DateTime minus(long duration) {        return withDurationAdded(duration, -1);    }
public DateTime minus(ReadableDuration duration) {        return withDurationAdded(duration, -1);    }
public DateTime minus(ReadablePeriod period) {        return withPeriodAdded(period, -1);    }
public DateTime minusYears(int years) {        if (years == 0) {            return this;        }        long instant = getChronology().years().subtract(getMillis(), years);        return withMillis(instant);    }
public DateTime minusMonths(int months) {        if (months == 0) {            return this;        }        long instant = getChronology().months().subtract(getMillis(), months);        return withMillis(instant);    }
public DateTime minusWeeks(int weeks) {        if (weeks == 0) {            return this;        }        long instant = getChronology().weeks().subtract(getMillis(), weeks);        return withMillis(instant);    }
public DateTime minusDays(int days) {        if (days == 0) {            return this;        }        long instant = getChronology().days().subtract(getMillis(), days);        return withMillis(instant);    }
public DateTime minusHours(int hours) {        if (hours == 0) {            return this;        }        long instant = getChronology().hours().subtract(getMillis(), hours);        return withMillis(instant);    }
public DateTime minusMinutes(int minutes) {        if (minutes == 0) {            return this;        }        long instant = getChronology().minutes().subtract(getMillis(), minutes);        return withMillis(instant);    }
public DateTime minusSeconds(int seconds) {        if (seconds == 0) {            return this;        }        long instant = getChronology().seconds().subtract(getMillis(), seconds);        return withMillis(instant);    }
public DateTime minusMillis(int millis) {        if (millis == 0) {            return this;        }        long instant = getChronology().millis().subtract(getMillis(), millis);        return withMillis(instant);    }
public DateTime withEra(int era) {        return withMillis(getChronology().era().set(getMillis(), era));    }
public DateTime withCenturyOfEra(int centuryOfEra) {        return withMillis(getChronology().centuryOfEra().set(getMillis(), centuryOfEra));    }
public DateTime withYearOfEra(int yearOfEra) {        return withMillis(getChronology().yearOfEra().set(getMillis(), yearOfEra));    }
public DateTime withYearOfCentury(int yearOfCentury) {        return withMillis(getChronology().yearOfCentury().set(getMillis(), yearOfCentury));    }
public DateTime withYear(int year) {        return withMillis(getChronology().year().set(getMillis(), year));    }
public DateTime withWeekyear(int weekyear) {        return withMillis(getChronology().weekyear().set(getMillis(), weekyear));    }
public DateTime withMonthOfYear(int monthOfYear) {        return withMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));    }
public DateTime withWeekOfWeekyear(int weekOfWeekyear) {        return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));    }
public DateTime withDayOfYear(int dayOfYear) {        return withMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));    }
public DateTime withDayOfMonth(int dayOfMonth) {        return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));    }
public DateTime withDayOfWeek(int dayOfWeek) {        return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));    }
public DateTime withHourOfDay(int hour) {        return withMillis(getChronology().hourOfDay().set(getMillis(), hour));    }
public DateTime withMinuteOfHour(int minute) {        return withMillis(getChronology().minuteOfHour().set(getMillis(), minute));    }
public DateTime withSecondOfMinute(int second) {        return withMillis(getChronology().secondOfMinute().set(getMillis(), second));    }
public DateTime withMillisOfSecond(int millis) {        return withMillis(getChronology().millisOfSecond().set(getMillis(), millis));    }
public DateTime withMillisOfDay(int millis) {        return withMillis(getChronology().millisOfDay().set(getMillis(), millis));    }
public DateTimeField getField() {            return iField;        }
public DateTime getDateTime() {            return iInstant;        }
public DateTime addToCopy(int value) {            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));        }
public DateTime addToCopy(long value) {            return iInstant.withMillis(iField.add(iInstant.getMillis(), value));        }
public DateTime addWrapFieldToCopy(int value) {            return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value));        }
public DateTime setCopy(int value) {            return iInstant.withMillis(iField.set(iInstant.getMillis(), value));        }
public DateTime setCopy(String text, Locale locale) {            return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale));        }
public DateTime setCopy(String text) {            return setCopy(text, null);        }
public DateTime withMaximumValue() {            try {                return setCopy(getMaximumValue());            } catch (RuntimeException ex) {                if (IllegalInstantException.isIllegalInstant(ex)) {                                        long beforeGap = getChronology().getZone().previousTransition(getMillis() + DateTimeConstants.MILLIS_PER_DAY);                    return new DateTime(beforeGap, getChronology());                }                throw ex;            }        }
public DateTime withMinimumValue() {            try {                return setCopy(getMinimumValue());            } catch (RuntimeException ex) {                if (IllegalInstantException.isIllegalInstant(ex)) {                                        long afterGap = getChronology().getZone().nextTransition(getMillis() - DateTimeConstants.MILLIS_PER_DAY);                    return new DateTime(afterGap, getChronology());                }                throw ex;            }        }
public DateTime roundFloorCopy() {            return iInstant.withMillis(iField.roundFloor(iInstant.getMillis()));        }
public DateTime roundCeilingCopy() {            return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis()));        }
public DateTime roundHalfFloorCopy() {            return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis()));        }
public DateTime roundHalfCeilingCopy() {            return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis()));        }
public DateTime roundHalfEvenCopy() {            return iInstant.withMillis(iField.roundHalfEven(iInstant.getMillis()));        }
    public static DateTime now(Chronology chronology) {        if (chronology == null) {            throw new NullPointerException("");        }        return new DateTime(chronology);    }
    public static DateTime parse(String str, DateTimeFormatter formatter) {        return formatter.parseDateTime(str);    }
    public DateTime toDateTime(Chronology chronology) {        chronology = DateTimeUtils.getChronology(chronology);        if (getChronology() == chronology) {            return this;        }        return super.toDateTime(chronology);    }
    public DateTime toDateTimeISO() {        if (getChronology() == ISOChronology.getInstance()) {            return this;        }        return super.toDateTimeISO();    }
    public DateTime withMillis(long newMillis) {        return (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));    }
    public DateTime withChronology(Chronology newChronology) {        newChronology = DateTimeUtils.getChronology(newChronology);        return (newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology));    }
    public DateTime withZone(DateTimeZone newZone) {        return withChronology(getChronology().withZone(newZone));    }
    public DateTime withZoneRetainFields(DateTimeZone newZone) {        newZone = DateTimeUtils.getZone(newZone);        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());        if (newZone == originalZone) {            return this;        }                long millis = originalZone.getMillisKeepLocal(newZone, getMillis());        return new DateTime(millis, getChronology().withZone(newZone));    }
    public DateTime withEarlierOffsetAtOverlap() {        long newMillis = getZone().adjustOffset(getMillis(), false);        return withMillis(newMillis);    }
    public DateTime withLaterOffsetAtOverlap() {        long newMillis = getZone().adjustOffset(getMillis(), true);        return withMillis(newMillis);    }
    public DateTime withDate(int year, int monthOfYear, int dayOfMonth) {        Chronology chrono = getChronology();        long instant = getMillis();        instant = chrono.year().set(instant, year);        instant = chrono.monthOfYear().set(instant, monthOfYear);        instant = chrono.dayOfMonth().set(instant, dayOfMonth);        return withMillis(instant);    }
    public DateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {        Chronology chrono = getChronology();        long instant = getMillis();        instant = chrono.hourOfDay().set(instant, hourOfDay);        instant = chrono.minuteOfHour().set(instant, minuteOfHour);        instant = chrono.secondOfMinute().set(instant, secondOfMinute);        instant = chrono.millisOfSecond().set(instant, millisOfSecond);        return withMillis(instant);    }
    public DateTime withTimeAtStartOfDay() {        return toLocalDate().toDateTimeAtStartOfDay(getZone());    }
    public DateTime withFields(ReadablePartial partial) {        if (partial == null) {            return this;        }        return withMillis(getChronology().set(partial, getMillis()));    }
    public DateTime withField(DateTimeFieldType fieldType, int value) {        if (fieldType == null) {            throw new IllegalArgumentException("");        }        long instant = fieldType.getField(getChronology()).set(getMillis(), value);        return withMillis(instant);    }
    public DateTime withFieldAdded(DurationFieldType fieldType, int amount) {        if (fieldType == null) {            throw new IllegalArgumentException("");        }        if (amount == 0) {            return this;        }        long instant = fieldType.getField(getChronology()).add(getMillis(), amount);        return withMillis(instant);    }
    public DateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) {        if (durationToAdd == null || scalar == 0) {            return this;        }        return withDurationAdded(durationToAdd.getMillis(), scalar);    }
    public DateTime withPeriodAdded(ReadablePeriod period, int scalar) {        if (period == null || scalar == 0) {            return this;        }        long instant = getChronology().add(period, getMillis(), scalar);        return withMillis(instant);    }
    public DateTime plus(ReadablePeriod period) {        return withPeriodAdded(period, 1);    }
    public DateTime plusYears(int years) {        if (years == 0) {            return this;        }        long instant = getChronology().years().add(getMillis(), years);        return withMillis(instant);    }
